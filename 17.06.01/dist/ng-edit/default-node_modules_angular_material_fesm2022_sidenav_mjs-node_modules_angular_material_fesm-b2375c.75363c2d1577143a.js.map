{"version":3,"file":"default-node_modules_angular_material_fesm2022_sidenav_mjs-node_modules_angular_material_fesm-b2375c.75363c2d1577143a.js","mappings":"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","names":["_c0","_c1","MatDrawerContainer_Conditional_0_Template","rf","ctx","_r3","i0","ctx_r2","_onBackdropClicked","ctx_r0","_isShowingBackdrop","MatDrawerContainer_Conditional_3_Template","_c2","_c3","MatSidenavContainer_Conditional_0_Template","MatSidenavContainer_Conditional_3_Template","_c4","_c5","matDrawerAnimations","transformDrawer","trigger","state","style","transform","visibility","transition","animate","MAT_DRAWER_DEFAULT_AUTOSIZE","InjectionToken","providedIn","factory","MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY","MAT_DRAWER_CONTAINER","MatDrawerContent","CdkScrollable","constructor","_changeDetectorRef","_container","elementRef","scrollDispatcher","ngZone","super","this","ngAfterContentInit","_contentMarginChanges","subscribe","markForCheck","static","ɵfac","t","forwardRef","MatDrawerContainer","i1","ɵcmp","type","selectors","hostAttrs","hostVars","hostBindings","_contentMargins","left","right","features","provide","useExisting","ngContentSelectors","decls","vars","template","encapsulation","changeDetection","MatDrawer","position","_position","value","_isAttached","_updatePositionInParent","onPositionChanged","emit","mode","_mode","_updateFocusTrapState","_modeChanged","next","disableClose","_disableClose","coerceBooleanProperty","autoFocus","_autoFocus","opened","_opened","toggle","_elementRef","_focusTrapFactory","_focusMonitor","_platform","_ngZone","_interactivityChecker","_doc","_elementFocusedBeforeDrawerWasOpened","_enableAnimations","_animationStarted","Subject","_animationEnd","_animationState","openedChange","EventEmitter","_openedStream","pipe","filter","o","map","openedStart","e","fromState","toState","indexOf","mapTo","undefined","_closedStream","closedStart","_destroyed","activeElement","_takeFocus","_isFocusWithinDrawer","_restoreFocus","_openedVia","runOutsideAngular","fromEvent","nativeElement","event","keyCode","ESCAPE","hasModifierKey","takeUntil","run","close","stopPropagation","preventDefault","distinctUntilChanged","x","y","_forceFocus","element","options","isFocusable","tabIndex","callback","removeEventListener","removeAttribute","addEventListener","focus","_focusByCssSelector","selector","elementToFocus","querySelector","_focusTrap","focusInitialElementWhenReady","then","hasMovedFocus","focusOrigin","focusVia","blur","activeEl","contains","ngAfterViewInit","create","ngAfterContentChecked","isBrowser","ngOnDestroy","destroy","_anchor","remove","complete","open","openedVia","_closeViaBackdropClick","_setOpen","isOpen","result","restoreFocus","Promise","resolve","take","_getWidth","offsetWidth","enabled","hasBackdrop","newPosition","parent","parentNode","createComment","insertBefore","appendChild","i2","i3","DOCUMENT","viewQuery","_t","_content","first","$event","inputs","outputs","exportAs","consts","dependencies","data","animation","start","_start","end","_end","autosize","_autosize","_drawerHasBackdrop","_backdropOverride","scrollable","_userContent","_dir","_element","viewportRuler","defaultAutosize","_animationMode","_drawers","QueryList","backdropClick","_doCheckSubject","change","_validateDrawers","updateContentMargins","_allDrawers","changes","startWith","drawer","reset","item","notifyOnChanges","forEach","_watchDrawerToggle","_watchDrawerPosition","_watchDrawerMode","length","_isDrawerOpen","debounceTime","_left","width","_right","ngDoCheck","_isPushed","classList","add","_setContainerClass","onMicrotaskEmpty","merge","isAdd","className","_closeModalDrawersViaBackdrop","i4","ANIMATION_MODULE_TYPE","contentQueries","dirIndex","styles","MatSidenavContent","changeDetectorRef","container","MatSidenavContainer","MatSidenav","arguments","_fixedInViewport","_fixedTopGap","_fixedBottomGap","fixedInViewport","fixedTopGap","coerceNumberProperty","fixedBottomGap","ɵMatSidenav_BaseFactory","ɵMatSidenavContainer_BaseFactory","MatSidenavModule","ɵmod","ɵinj","imports","MatCommonModule","CdkScrollableModule","_MatToolbarBase","mixinColor","MatToolbarRow","ɵdir","MatToolbar","document","_document","_checkToolbarMixedModes","_toolbarRows","color","MatToolbarModule"],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/material/fesm2022/sidenav.mjs","./node_modules/@angular/material/fesm2022/toolbar.mjs"],"sourcesContent":["import * as i1 from '@angular/cdk/scrolling';\nimport { CdkScrollable, CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, EventEmitter, Optional, Input, Output, ViewChild, QueryList, ContentChildren, ContentChild, NgModule } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nimport * as i2 from '@angular/cdk/a11y';\nimport * as i4 from '@angular/cdk/bidi';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport * as i3 from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport { Subject, fromEvent, merge } from 'rxjs';\nimport { filter, map, mapTo, takeUntil, distinctUntilChanged, take, startWith, debounceTime } from 'rxjs/operators';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * Animations used by the Material drawers.\n * @docs-private\n */\nconst matDrawerAnimations = {\n    /** Animation that slides a drawer in and out. */\n    transformDrawer: trigger('transform', [\n        // We remove the `transform` here completely, rather than setting it to zero, because:\n        // 1. Having a transform can cause elements with ripples or an animated\n        //    transform to shift around in Chrome with an RTL layout (see #10023).\n        // 2. 3d transforms causes text to appear blurry on IE and Edge.\n        state('open, open-instant', style({\n            'transform': 'none',\n            'visibility': 'visible',\n        })),\n        state('void', style({\n            // Avoids the shadow showing up when closed in SSR.\n            'box-shadow': 'none',\n            'visibility': 'hidden',\n        })),\n        transition('void => open-instant', animate('0ms')),\n        transition('void <=> open, open-instant => void', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),\n    ]),\n};\n\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nfunction throwMatDuplicatedDrawerError(position) {\n    throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n/** Configures whether drawers should use auto sizing by default. */\nconst MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE', {\n    providedIn: 'root',\n    factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\n});\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\nconst MAT_DRAWER_CONTAINER = new InjectionToken('MAT_DRAWER_CONTAINER');\n/** @docs-private */\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\n    return false;\n}\nclass MatDrawerContent extends CdkScrollable {\n    constructor(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {\n        super(elementRef, scrollDispatcher, ngZone);\n        this._changeDetectorRef = _changeDetectorRef;\n        this._container = _container;\n    }\n    ngAfterContentInit() {\n        this._container._contentMarginChanges.subscribe(() => {\n            this._changeDetectorRef.markForCheck();\n        });\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatDrawerContent, deps: [{ token: i0.ChangeDetectorRef }, { token: forwardRef(() => MatDrawerContainer) }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: MatDrawerContent, selector: \"mat-drawer-content\", host: { attributes: { \"ngSkipHydration\": \"\" }, properties: { \"style.margin-left.px\": \"_container._contentMargins.left\", \"style.margin-right.px\": \"_container._contentMargins.right\" }, classAttribute: \"mat-drawer-content\" }, providers: [\n            {\n                provide: CdkScrollable,\n                useExisting: MatDrawerContent,\n            },\n        ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatDrawerContent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'mat-drawer-content',\n                    template: '<ng-content></ng-content>',\n                    host: {\n                        'class': 'mat-drawer-content',\n                        '[style.margin-left.px]': '_container._contentMargins.left',\n                        '[style.margin-right.px]': '_container._contentMargins.right',\n                        'ngSkipHydration': '',\n                    },\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    providers: [\n                        {\n                            provide: CdkScrollable,\n                            useExisting: MatDrawerContent,\n                        },\n                    ],\n                }]\n        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: MatDrawerContainer, decorators: [{\n                    type: Inject,\n                    args: [forwardRef(() => MatDrawerContainer)]\n                }] }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.NgZone }] });\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nclass MatDrawer {\n    /** The side that the drawer is attached to. */\n    get position() {\n        return this._position;\n    }\n    set position(value) {\n        // Make sure we have a valid value.\n        value = value === 'end' ? 'end' : 'start';\n        if (value !== this._position) {\n            // Static inputs in Ivy are set before the element is in the DOM.\n            if (this._isAttached) {\n                this._updatePositionInParent(value);\n            }\n            this._position = value;\n            this.onPositionChanged.emit();\n        }\n    }\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n    get mode() {\n        return this._mode;\n    }\n    set mode(value) {\n        this._mode = value;\n        this._updateFocusTrapState();\n        this._modeChanged.next();\n    }\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n    get disableClose() {\n        return this._disableClose;\n    }\n    set disableClose(value) {\n        this._disableClose = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the drawer should focus the first focusable element automatically when opened.\n     * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n     * enabled, focus will be moved into the sidenav in `side` mode as well.\n     * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or AutoFocusTarget\n     * instead.\n     */\n    get autoFocus() {\n        const value = this._autoFocus;\n        // Note that usually we don't allow autoFocus to be set to `first-tabbable` in `side` mode,\n        // because we don't know how the sidenav is being used, but in some cases it still makes\n        // sense to do it. The consumer can explicitly set `autoFocus`.\n        if (value == null) {\n            if (this.mode === 'side') {\n                return 'dialog';\n            }\n            else {\n                return 'first-tabbable';\n            }\n        }\n        return value;\n    }\n    set autoFocus(value) {\n        if (value === 'true' || value === 'false' || value == null) {\n            value = coerceBooleanProperty(value);\n        }\n        this._autoFocus = value;\n    }\n    /**\n     * Whether the drawer is opened. We overload this because we trigger an event when it\n     * starts or end.\n     */\n    get opened() {\n        return this._opened;\n    }\n    set opened(value) {\n        this.toggle(coerceBooleanProperty(value));\n    }\n    constructor(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _interactivityChecker, _doc, _container) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this._focusMonitor = _focusMonitor;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._interactivityChecker = _interactivityChecker;\n        this._doc = _doc;\n        this._container = _container;\n        this._elementFocusedBeforeDrawerWasOpened = null;\n        /** Whether the drawer is initialized. Used for disabling the initial animation. */\n        this._enableAnimations = false;\n        this._position = 'start';\n        this._mode = 'over';\n        this._disableClose = false;\n        this._opened = false;\n        /** Emits whenever the drawer has started animating. */\n        this._animationStarted = new Subject();\n        /** Emits whenever the drawer is done animating. */\n        this._animationEnd = new Subject();\n        /** Current state of the sidenav animation. */\n        this._animationState = 'void';\n        /** Event emitted when the drawer open state is changed. */\n        this.openedChange = \n        // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n        new EventEmitter(/* isAsync */ true);\n        /** Event emitted when the drawer has been opened. */\n        this._openedStream = this.openedChange.pipe(filter(o => o), map(() => { }));\n        /** Event emitted when the drawer has started opening. */\n        this.openedStart = this._animationStarted.pipe(filter(e => e.fromState !== e.toState && e.toState.indexOf('open') === 0), mapTo(undefined));\n        /** Event emitted when the drawer has been closed. */\n        this._closedStream = this.openedChange.pipe(filter(o => !o), map(() => { }));\n        /** Event emitted when the drawer has started closing. */\n        this.closedStart = this._animationStarted.pipe(filter(e => e.fromState !== e.toState && e.toState === 'void'), mapTo(undefined));\n        /** Emits when the component is destroyed. */\n        this._destroyed = new Subject();\n        /** Event emitted when the drawer's position changes. */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onPositionChanged = new EventEmitter();\n        /**\n         * An observable that emits when the drawer mode changes. This is used by the drawer container to\n         * to know when to when the mode changes so it can adapt the margins on the content.\n         */\n        this._modeChanged = new Subject();\n        this.openedChange.subscribe((opened) => {\n            if (opened) {\n                if (this._doc) {\n                    this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;\n                }\n                this._takeFocus();\n            }\n            else if (this._isFocusWithinDrawer()) {\n                this._restoreFocus(this._openedVia || 'program');\n            }\n        });\n        /**\n         * Listen to `keydown` events outside the zone so that change detection is not run every\n         * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n         * and we don't have close disabled.\n         */\n        this._ngZone.runOutsideAngular(() => {\n            fromEvent(this._elementRef.nativeElement, 'keydown')\n                .pipe(filter(event => {\n                return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);\n            }), takeUntil(this._destroyed))\n                .subscribe(event => this._ngZone.run(() => {\n                this.close();\n                event.stopPropagation();\n                event.preventDefault();\n            }));\n        });\n        // We need a Subject with distinctUntilChanged, because the `done` event\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\n        this._animationEnd\n            .pipe(distinctUntilChanged((x, y) => {\n            return x.fromState === y.fromState && x.toState === y.toState;\n        }))\n            .subscribe((event) => {\n            const { fromState, toState } = event;\n            if ((toState.indexOf('open') === 0 && fromState === 'void') ||\n                (toState === 'void' && fromState.indexOf('open') === 0)) {\n                this.openedChange.emit(this._opened);\n            }\n        });\n    }\n    /**\n     * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n     * attribute to forcefully focus it. The attribute is removed after focus is moved.\n     * @param element The element to focus.\n     */\n    _forceFocus(element, options) {\n        if (!this._interactivityChecker.isFocusable(element)) {\n            element.tabIndex = -1;\n            // The tabindex attribute should be removed to avoid navigating to that element again\n            this._ngZone.runOutsideAngular(() => {\n                const callback = () => {\n                    element.removeEventListener('blur', callback);\n                    element.removeEventListener('mousedown', callback);\n                    element.removeAttribute('tabindex');\n                };\n                element.addEventListener('blur', callback);\n                element.addEventListener('mousedown', callback);\n            });\n        }\n        element.focus(options);\n    }\n    /**\n     * Focuses the first element that matches the given selector within the focus trap.\n     * @param selector The CSS selector for the element to set focus to.\n     */\n    _focusByCssSelector(selector, options) {\n        let elementToFocus = this._elementRef.nativeElement.querySelector(selector);\n        if (elementToFocus) {\n            this._forceFocus(elementToFocus, options);\n        }\n    }\n    /**\n     * Moves focus into the drawer. Note that this works even if\n     * the focus trap is disabled in `side` mode.\n     */\n    _takeFocus() {\n        if (!this._focusTrap) {\n            return;\n        }\n        const element = this._elementRef.nativeElement;\n        // When autoFocus is not on the sidenav, if the element cannot be focused or does\n        // not exist, focus the sidenav itself so the keyboard navigation still works.\n        // We need to check that `focus` is a function due to Universal.\n        switch (this.autoFocus) {\n            case false:\n            case 'dialog':\n                return;\n            case true:\n            case 'first-tabbable':\n                this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {\n                    if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\n                        element.focus();\n                    }\n                });\n                break;\n            case 'first-heading':\n                this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]');\n                break;\n            default:\n                this._focusByCssSelector(this.autoFocus);\n                break;\n        }\n    }\n    /**\n     * Restores focus to the element that was originally focused when the drawer opened.\n     * If no element was focused at that time, the focus will be restored to the drawer.\n     */\n    _restoreFocus(focusOrigin) {\n        if (this.autoFocus === 'dialog') {\n            return;\n        }\n        if (this._elementFocusedBeforeDrawerWasOpened) {\n            this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, focusOrigin);\n        }\n        else {\n            this._elementRef.nativeElement.blur();\n        }\n        this._elementFocusedBeforeDrawerWasOpened = null;\n    }\n    /** Whether focus is currently within the drawer. */\n    _isFocusWithinDrawer() {\n        const activeEl = this._doc.activeElement;\n        return !!activeEl && this._elementRef.nativeElement.contains(activeEl);\n    }\n    ngAfterViewInit() {\n        this._isAttached = true;\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n        this._updateFocusTrapState();\n        // Only update the DOM position when the sidenav is positioned at\n        // the end since we project the sidenav before the content by default.\n        if (this._position === 'end') {\n            this._updatePositionInParent('end');\n        }\n    }\n    ngAfterContentChecked() {\n        // Enable the animations after the lifecycle hooks have run, in order to avoid animating\n        // drawers that are open by default. When we're on the server, we shouldn't enable the\n        // animations, because we don't want the drawer to animate the first time the user sees\n        // the page.\n        if (this._platform.isBrowser) {\n            this._enableAnimations = true;\n        }\n    }\n    ngOnDestroy() {\n        if (this._focusTrap) {\n            this._focusTrap.destroy();\n        }\n        this._anchor?.remove();\n        this._anchor = null;\n        this._animationStarted.complete();\n        this._animationEnd.complete();\n        this._modeChanged.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Open the drawer.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    open(openedVia) {\n        return this.toggle(true, openedVia);\n    }\n    /** Close the drawer. */\n    close() {\n        return this.toggle(false);\n    }\n    /** Closes the drawer with context that the backdrop was clicked. */\n    _closeViaBackdropClick() {\n        // If the drawer is closed upon a backdrop click, we always want to restore focus. We\n        // don't need to check whether focus is currently in the drawer, as clicking on the\n        // backdrop causes blurs the active element.\n        return this._setOpen(/* isOpen */ false, /* restoreFocus */ true, 'mouse');\n    }\n    /**\n     * Toggle this drawer.\n     * @param isOpen Whether the drawer should be open.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    toggle(isOpen = !this.opened, openedVia) {\n        // If the focus is currently inside the drawer content and we are closing the drawer,\n        // restore the focus to the initially focused element (when the drawer opened).\n        if (isOpen && openedVia) {\n            this._openedVia = openedVia;\n        }\n        const result = this._setOpen(isOpen, \n        /* restoreFocus */ !isOpen && this._isFocusWithinDrawer(), this._openedVia || 'program');\n        if (!isOpen) {\n            this._openedVia = null;\n        }\n        return result;\n    }\n    /**\n     * Toggles the opened state of the drawer.\n     * @param isOpen Whether the drawer should open or close.\n     * @param restoreFocus Whether focus should be restored on close.\n     * @param focusOrigin Origin to use when restoring focus.\n     */\n    _setOpen(isOpen, restoreFocus, focusOrigin) {\n        this._opened = isOpen;\n        if (isOpen) {\n            this._animationState = this._enableAnimations ? 'open' : 'open-instant';\n        }\n        else {\n            this._animationState = 'void';\n            if (restoreFocus) {\n                this._restoreFocus(focusOrigin);\n            }\n        }\n        this._updateFocusTrapState();\n        return new Promise(resolve => {\n            this.openedChange.pipe(take(1)).subscribe(open => resolve(open ? 'open' : 'close'));\n        });\n    }\n    _getWidth() {\n        return this._elementRef.nativeElement ? this._elementRef.nativeElement.offsetWidth || 0 : 0;\n    }\n    /** Updates the enabled state of the focus trap. */\n    _updateFocusTrapState() {\n        if (this._focusTrap) {\n            // Trap focus only if the backdrop is enabled. Otherwise, allow end user to interact with the\n            // sidenav content.\n            this._focusTrap.enabled = !!this._container?.hasBackdrop;\n        }\n    }\n    /**\n     * Updates the position of the drawer in the DOM. We need to move the element around ourselves\n     * when it's in the `end` position so that it comes after the content and the visual order\n     * matches the tab order. We also need to be able to move it back to `start` if the sidenav\n     * started off as `end` and was changed to `start`.\n     */\n    _updatePositionInParent(newPosition) {\n        const element = this._elementRef.nativeElement;\n        const parent = element.parentNode;\n        if (newPosition === 'end') {\n            if (!this._anchor) {\n                this._anchor = this._doc.createComment('mat-drawer-anchor');\n                parent.insertBefore(this._anchor, element);\n            }\n            parent.appendChild(element);\n        }\n        else if (this._anchor) {\n            this._anchor.parentNode.insertBefore(element, this._anchor);\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatDrawer, deps: [{ token: i0.ElementRef }, { token: i2.FocusTrapFactory }, { token: i2.FocusMonitor }, { token: i3.Platform }, { token: i0.NgZone }, { token: i2.InteractivityChecker }, { token: DOCUMENT, optional: true }, { token: MAT_DRAWER_CONTAINER, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: MatDrawer, selector: \"mat-drawer\", inputs: { position: \"position\", mode: \"mode\", disableClose: \"disableClose\", autoFocus: \"autoFocus\", opened: \"opened\" }, outputs: { openedChange: \"openedChange\", _openedStream: \"opened\", openedStart: \"openedStart\", _closedStream: \"closed\", closedStart: \"closedStart\", onPositionChanged: \"positionChanged\" }, host: { attributes: { \"tabIndex\": \"-1\", \"ngSkipHydration\": \"\" }, listeners: { \"@transform.start\": \"_animationStarted.next($event)\", \"@transform.done\": \"_animationEnd.next($event)\" }, properties: { \"attr.align\": \"null\", \"class.mat-drawer-end\": \"position === \\\"end\\\"\", \"class.mat-drawer-over\": \"mode === \\\"over\\\"\", \"class.mat-drawer-push\": \"mode === \\\"push\\\"\", \"class.mat-drawer-side\": \"mode === \\\"side\\\"\", \"class.mat-drawer-opened\": \"opened\", \"@transform\": \"_animationState\" }, classAttribute: \"mat-drawer\" }, viewQueries: [{ propertyName: \"_content\", first: true, predicate: [\"content\"], descendants: true }], exportAs: [\"matDrawer\"], ngImport: i0, template: \"<div class=\\\"mat-drawer-inner-container\\\" cdkScrollable #content>\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\", dependencies: [{ kind: \"directive\", type: i1.CdkScrollable, selector: \"[cdk-scrollable], [cdkScrollable]\" }], animations: [matDrawerAnimations.transformDrawer], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatDrawer, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-drawer', exportAs: 'matDrawer', animations: [matDrawerAnimations.transformDrawer], host: {\n                        'class': 'mat-drawer',\n                        // must prevent the browser from aligning text based on value\n                        '[attr.align]': 'null',\n                        '[class.mat-drawer-end]': 'position === \"end\"',\n                        '[class.mat-drawer-over]': 'mode === \"over\"',\n                        '[class.mat-drawer-push]': 'mode === \"push\"',\n                        '[class.mat-drawer-side]': 'mode === \"side\"',\n                        '[class.mat-drawer-opened]': 'opened',\n                        'tabIndex': '-1',\n                        '[@transform]': '_animationState',\n                        '(@transform.start)': '_animationStarted.next($event)',\n                        '(@transform.done)': '_animationEnd.next($event)',\n                        'ngSkipHydration': '',\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, template: \"<div class=\\\"mat-drawer-inner-container\\\" cdkScrollable #content>\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\" }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i2.FocusTrapFactory }, { type: i2.FocusMonitor }, { type: i3.Platform }, { type: i0.NgZone }, { type: i2.InteractivityChecker }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: MatDrawerContainer, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_DRAWER_CONTAINER]\n                }] }], propDecorators: { position: [{\n                type: Input\n            }], mode: [{\n                type: Input\n            }], disableClose: [{\n                type: Input\n            }], autoFocus: [{\n                type: Input\n            }], opened: [{\n                type: Input\n            }], openedChange: [{\n                type: Output\n            }], _openedStream: [{\n                type: Output,\n                args: ['opened']\n            }], openedStart: [{\n                type: Output\n            }], _closedStream: [{\n                type: Output,\n                args: ['closed']\n            }], closedStart: [{\n                type: Output\n            }], onPositionChanged: [{\n                type: Output,\n                args: ['positionChanged']\n            }], _content: [{\n                type: ViewChild,\n                args: ['content']\n            }] } });\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nclass MatDrawerContainer {\n    /** The drawer child with the `start` position. */\n    get start() {\n        return this._start;\n    }\n    /** The drawer child with the `end` position. */\n    get end() {\n        return this._end;\n    }\n    /**\n     * Whether to automatically resize the container whenever\n     * the size of any of its drawers changes.\n     *\n     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n     * the drawers on every change detection cycle. Can be configured globally via the\n     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n     */\n    get autosize() {\n        return this._autosize;\n    }\n    set autosize(value) {\n        this._autosize = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n     * mode as well.\n     */\n    get hasBackdrop() {\n        return this._drawerHasBackdrop(this._start) || this._drawerHasBackdrop(this._end);\n    }\n    set hasBackdrop(value) {\n        this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\n    }\n    /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n    get scrollable() {\n        return this._userContent || this._content;\n    }\n    constructor(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize = false, _animationMode) {\n        this._dir = _dir;\n        this._element = _element;\n        this._ngZone = _ngZone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._animationMode = _animationMode;\n        /** Drawers that belong to this container. */\n        this._drawers = new QueryList();\n        /** Event emitted when the drawer backdrop is clicked. */\n        this.backdropClick = new EventEmitter();\n        /** Emits when the component is destroyed. */\n        this._destroyed = new Subject();\n        /** Emits on every ngDoCheck. Used for debouncing reflows. */\n        this._doCheckSubject = new Subject();\n        /**\n         * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n         * drawer is open. We use margin rather than transform even for push mode because transform breaks\n         * fixed position elements inside of the transformed element.\n         */\n        this._contentMargins = { left: null, right: null };\n        this._contentMarginChanges = new Subject();\n        // If a `Dir` directive exists up the tree, listen direction changes\n        // and update the left/right properties to point to the proper start/end.\n        if (_dir) {\n            _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n                this._validateDrawers();\n                this.updateContentMargins();\n            });\n        }\n        // Since the minimum width of the sidenav depends on the viewport width,\n        // we need to recompute the margins if the viewport changes.\n        viewportRuler\n            .change()\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(() => this.updateContentMargins());\n        this._autosize = defaultAutosize;\n    }\n    ngAfterContentInit() {\n        this._allDrawers.changes\n            .pipe(startWith(this._allDrawers), takeUntil(this._destroyed))\n            .subscribe((drawer) => {\n            this._drawers.reset(drawer.filter(item => !item._container || item._container === this));\n            this._drawers.notifyOnChanges();\n        });\n        this._drawers.changes.pipe(startWith(null)).subscribe(() => {\n            this._validateDrawers();\n            this._drawers.forEach((drawer) => {\n                this._watchDrawerToggle(drawer);\n                this._watchDrawerPosition(drawer);\n                this._watchDrawerMode(drawer);\n            });\n            if (!this._drawers.length ||\n                this._isDrawerOpen(this._start) ||\n                this._isDrawerOpen(this._end)) {\n                this.updateContentMargins();\n            }\n            this._changeDetectorRef.markForCheck();\n        });\n        // Avoid hitting the NgZone through the debounce timeout.\n        this._ngZone.runOutsideAngular(() => {\n            this._doCheckSubject\n                .pipe(debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps\n            takeUntil(this._destroyed))\n                .subscribe(() => this.updateContentMargins());\n        });\n    }\n    ngOnDestroy() {\n        this._contentMarginChanges.complete();\n        this._doCheckSubject.complete();\n        this._drawers.destroy();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Calls `open` of both start and end drawers */\n    open() {\n        this._drawers.forEach(drawer => drawer.open());\n    }\n    /** Calls `close` of both start and end drawers */\n    close() {\n        this._drawers.forEach(drawer => drawer.close());\n    }\n    /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     */\n    updateContentMargins() {\n        // 1. For drawers in `over` mode, they don't affect the content.\n        // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n        //    left margin (for left drawer) or right margin (for right the drawer).\n        // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n        //    adding to the left or right margin and simultaneously subtracting the same amount of\n        //    margin from the other side.\n        let left = 0;\n        let right = 0;\n        if (this._left && this._left.opened) {\n            if (this._left.mode == 'side') {\n                left += this._left._getWidth();\n            }\n            else if (this._left.mode == 'push') {\n                const width = this._left._getWidth();\n                left += width;\n                right -= width;\n            }\n        }\n        if (this._right && this._right.opened) {\n            if (this._right.mode == 'side') {\n                right += this._right._getWidth();\n            }\n            else if (this._right.mode == 'push') {\n                const width = this._right._getWidth();\n                right += width;\n                left -= width;\n            }\n        }\n        // If either `right` or `left` is zero, don't set a style to the element. This\n        // allows users to specify a custom size via CSS class in SSR scenarios where the\n        // measured widths will always be zero. Note that we reset to `null` here, rather\n        // than below, in order to ensure that the types in the `if` below are consistent.\n        left = left || null;\n        right = right || null;\n        if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\n            this._contentMargins = { left, right };\n            // Pull back into the NgZone since in some cases we could be outside. We need to be careful\n            // to do it only when something changed, otherwise we can end up hitting the zone too often.\n            this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\n        }\n    }\n    ngDoCheck() {\n        // If users opted into autosizing, do a check every change detection cycle.\n        if (this._autosize && this._isPushed()) {\n            // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n            this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\n        }\n    }\n    /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     */\n    _watchDrawerToggle(drawer) {\n        drawer._animationStarted\n            .pipe(filter((event) => event.fromState !== event.toState), takeUntil(this._drawers.changes))\n            .subscribe((event) => {\n            // Set the transition class on the container so that the animations occur. This should not\n            // be set initially because animations should only be triggered via a change in state.\n            if (event.toState !== 'open-instant' && this._animationMode !== 'NoopAnimations') {\n                this._element.nativeElement.classList.add('mat-drawer-transition');\n            }\n            this.updateContentMargins();\n            this._changeDetectorRef.markForCheck();\n        });\n        if (drawer.mode !== 'side') {\n            drawer.openedChange\n                .pipe(takeUntil(this._drawers.changes))\n                .subscribe(() => this._setContainerClass(drawer.opened));\n        }\n    }\n    /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     */\n    _watchDrawerPosition(drawer) {\n        if (!drawer) {\n            return;\n        }\n        // NOTE: We need to wait for the microtask queue to be empty before validating,\n        // since both drawers may be swapping positions at the same time.\n        drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\n            this._ngZone.onMicrotaskEmpty.pipe(take(1)).subscribe(() => {\n                this._validateDrawers();\n            });\n        });\n    }\n    /** Subscribes to changes in drawer mode so we can run change detection. */\n    _watchDrawerMode(drawer) {\n        if (drawer) {\n            drawer._modeChanged\n                .pipe(takeUntil(merge(this._drawers.changes, this._destroyed)))\n                .subscribe(() => {\n                this.updateContentMargins();\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n    _setContainerClass(isAdd) {\n        const classList = this._element.nativeElement.classList;\n        const className = 'mat-drawer-container-has-open';\n        if (isAdd) {\n            classList.add(className);\n        }\n        else {\n            classList.remove(className);\n        }\n    }\n    /** Validate the state of the drawer children components. */\n    _validateDrawers() {\n        this._start = this._end = null;\n        // Ensure that we have at most one start and one end drawer.\n        this._drawers.forEach(drawer => {\n            if (drawer.position == 'end') {\n                if (this._end != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throwMatDuplicatedDrawerError('end');\n                }\n                this._end = drawer;\n            }\n            else {\n                if (this._start != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throwMatDuplicatedDrawerError('start');\n                }\n                this._start = drawer;\n            }\n        });\n        this._right = this._left = null;\n        // Detect if we're LTR or RTL.\n        if (this._dir && this._dir.value === 'rtl') {\n            this._left = this._end;\n            this._right = this._start;\n        }\n        else {\n            this._left = this._start;\n            this._right = this._end;\n        }\n    }\n    /** Whether the container is being pushed to the side by one of the drawers. */\n    _isPushed() {\n        return ((this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\n            (this._isDrawerOpen(this._end) && this._end.mode != 'over'));\n    }\n    _onBackdropClicked() {\n        this.backdropClick.emit();\n        this._closeModalDrawersViaBackdrop();\n    }\n    _closeModalDrawersViaBackdrop() {\n        // Close all open drawers where closing is not disabled and the mode is not `side`.\n        [this._start, this._end]\n            .filter(drawer => drawer && !drawer.disableClose && this._drawerHasBackdrop(drawer))\n            .forEach(drawer => drawer._closeViaBackdropClick());\n    }\n    _isShowingBackdrop() {\n        return ((this._isDrawerOpen(this._start) && this._drawerHasBackdrop(this._start)) ||\n            (this._isDrawerOpen(this._end) && this._drawerHasBackdrop(this._end)));\n    }\n    _isDrawerOpen(drawer) {\n        return drawer != null && drawer.opened;\n    }\n    // Whether argument drawer should have a backdrop when it opens\n    _drawerHasBackdrop(drawer) {\n        if (this._backdropOverride == null) {\n            return !!drawer && drawer.mode !== 'side';\n        }\n        return this._backdropOverride;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatDrawerContainer, deps: [{ token: i4.Directionality, optional: true }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: i1.ViewportRuler }, { token: MAT_DRAWER_DEFAULT_AUTOSIZE }, { token: ANIMATION_MODULE_TYPE, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.0.0\", version: \"17.0.4\", type: MatDrawerContainer, selector: \"mat-drawer-container\", inputs: { autosize: \"autosize\", hasBackdrop: \"hasBackdrop\" }, outputs: { backdropClick: \"backdropClick\" }, host: { attributes: { \"ngSkipHydration\": \"\" }, properties: { \"class.mat-drawer-container-explicit-backdrop\": \"_backdropOverride\" }, classAttribute: \"mat-drawer-container\" }, providers: [\n            {\n                provide: MAT_DRAWER_CONTAINER,\n                useExisting: MatDrawerContainer,\n            },\n        ], queries: [{ propertyName: \"_content\", first: true, predicate: MatDrawerContent, descendants: true }, { propertyName: \"_allDrawers\", predicate: MatDrawer, descendants: true }], viewQueries: [{ propertyName: \"_userContent\", first: true, predicate: MatDrawerContent, descendants: true }], exportAs: [\"matDrawerContainer\"], ngImport: i0, template: \"@if (hasBackdrop) {\\n  <div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\"\\n       [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div>\\n}\\n\\n<ng-content select=\\\"mat-drawer\\\"></ng-content>\\n\\n<ng-content select=\\\"mat-drawer-content\\\">\\n</ng-content>\\n\\n@if (!_content) {\\n  <mat-drawer-content>\\n    <ng-content></ng-content>\\n  </mat-drawer-content>\\n}\\n\", styles: [\".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color);background-color:var(--mat-sidenav-content-background-color);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color)}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{box-shadow:0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);position:relative;z-index:4;color:var(--mat-sidenav-container-text-color);background-color:var(--mat-sidenav-container-background-color);border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*=\\\"visibility: hidden\\\"]{display:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\"], dependencies: [{ kind: \"component\", type: MatDrawerContent, selector: \"mat-drawer-content\" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatDrawerContainer, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-drawer-container', exportAs: 'matDrawerContainer', host: {\n                        'class': 'mat-drawer-container',\n                        '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\n                        'ngSkipHydration': '',\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, providers: [\n                        {\n                            provide: MAT_DRAWER_CONTAINER,\n                            useExisting: MatDrawerContainer,\n                        },\n                    ], template: \"@if (hasBackdrop) {\\n  <div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\"\\n       [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div>\\n}\\n\\n<ng-content select=\\\"mat-drawer\\\"></ng-content>\\n\\n<ng-content select=\\\"mat-drawer-content\\\">\\n</ng-content>\\n\\n@if (!_content) {\\n  <mat-drawer-content>\\n    <ng-content></ng-content>\\n  </mat-drawer-content>\\n}\\n\", styles: [\".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color);background-color:var(--mat-sidenav-content-background-color);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color)}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{box-shadow:0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);position:relative;z-index:4;color:var(--mat-sidenav-container-text-color);background-color:var(--mat-sidenav-container-background-color);border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*=\\\"visibility: hidden\\\"]{display:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\"] }]\n        }], ctorParameters: () => [{ type: i4.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i1.ViewportRuler }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_DRAWER_DEFAULT_AUTOSIZE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ANIMATION_MODULE_TYPE]\n                }] }], propDecorators: { _allDrawers: [{\n                type: ContentChildren,\n                args: [MatDrawer, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }], _content: [{\n                type: ContentChild,\n                args: [MatDrawerContent]\n            }], _userContent: [{\n                type: ViewChild,\n                args: [MatDrawerContent]\n            }], autosize: [{\n                type: Input\n            }], hasBackdrop: [{\n                type: Input\n            }], backdropClick: [{\n                type: Output\n            }] } });\n\nclass MatSidenavContent extends MatDrawerContent {\n    constructor(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {\n        super(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavContent, deps: [{ token: i0.ChangeDetectorRef }, { token: forwardRef(() => MatSidenavContainer) }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: MatSidenavContent, selector: \"mat-sidenav-content\", host: { attributes: { \"ngSkipHydration\": \"\" }, properties: { \"style.margin-left.px\": \"_container._contentMargins.left\", \"style.margin-right.px\": \"_container._contentMargins.right\" }, classAttribute: \"mat-drawer-content mat-sidenav-content\" }, providers: [\n            {\n                provide: CdkScrollable,\n                useExisting: MatSidenavContent,\n            },\n        ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavContent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'mat-sidenav-content',\n                    template: '<ng-content></ng-content>',\n                    host: {\n                        'class': 'mat-drawer-content mat-sidenav-content',\n                        '[style.margin-left.px]': '_container._contentMargins.left',\n                        '[style.margin-right.px]': '_container._contentMargins.right',\n                        'ngSkipHydration': '',\n                    },\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    providers: [\n                        {\n                            provide: CdkScrollable,\n                            useExisting: MatSidenavContent,\n                        },\n                    ],\n                }]\n        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: MatSidenavContainer, decorators: [{\n                    type: Inject,\n                    args: [forwardRef(() => MatSidenavContainer)]\n                }] }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.NgZone }] });\nclass MatSidenav extends MatDrawer {\n    constructor() {\n        super(...arguments);\n        this._fixedInViewport = false;\n        this._fixedTopGap = 0;\n        this._fixedBottomGap = 0;\n    }\n    /** Whether the sidenav is fixed in the viewport. */\n    get fixedInViewport() {\n        return this._fixedInViewport;\n    }\n    set fixedInViewport(value) {\n        this._fixedInViewport = coerceBooleanProperty(value);\n    }\n    /**\n     * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n     * mode.\n     */\n    get fixedTopGap() {\n        return this._fixedTopGap;\n    }\n    set fixedTopGap(value) {\n        this._fixedTopGap = coerceNumberProperty(value);\n    }\n    /**\n     * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n     * fixed mode.\n     */\n    get fixedBottomGap() {\n        return this._fixedBottomGap;\n    }\n    set fixedBottomGap(value) {\n        this._fixedBottomGap = coerceNumberProperty(value);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenav, deps: null, target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: MatSidenav, selector: \"mat-sidenav\", inputs: { fixedInViewport: \"fixedInViewport\", fixedTopGap: \"fixedTopGap\", fixedBottomGap: \"fixedBottomGap\" }, host: { attributes: { \"tabIndex\": \"-1\", \"ngSkipHydration\": \"\" }, properties: { \"attr.align\": \"null\", \"class.mat-drawer-end\": \"position === \\\"end\\\"\", \"class.mat-drawer-over\": \"mode === \\\"over\\\"\", \"class.mat-drawer-push\": \"mode === \\\"push\\\"\", \"class.mat-drawer-side\": \"mode === \\\"side\\\"\", \"class.mat-drawer-opened\": \"opened\", \"class.mat-sidenav-fixed\": \"fixedInViewport\", \"style.top.px\": \"fixedInViewport ? fixedTopGap : null\", \"style.bottom.px\": \"fixedInViewport ? fixedBottomGap : null\" }, classAttribute: \"mat-drawer mat-sidenav\" }, exportAs: [\"matSidenav\"], usesInheritance: true, ngImport: i0, template: \"<div class=\\\"mat-drawer-inner-container\\\" cdkScrollable #content>\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\", dependencies: [{ kind: \"directive\", type: i1.CdkScrollable, selector: \"[cdk-scrollable], [cdkScrollable]\" }], animations: [matDrawerAnimations.transformDrawer], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenav, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-sidenav', exportAs: 'matSidenav', animations: [matDrawerAnimations.transformDrawer], host: {\n                        'class': 'mat-drawer mat-sidenav',\n                        'tabIndex': '-1',\n                        // must prevent the browser from aligning text based on value\n                        '[attr.align]': 'null',\n                        '[class.mat-drawer-end]': 'position === \"end\"',\n                        '[class.mat-drawer-over]': 'mode === \"over\"',\n                        '[class.mat-drawer-push]': 'mode === \"push\"',\n                        '[class.mat-drawer-side]': 'mode === \"side\"',\n                        '[class.mat-drawer-opened]': 'opened',\n                        '[class.mat-sidenav-fixed]': 'fixedInViewport',\n                        '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',\n                        '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null',\n                        'ngSkipHydration': '',\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, template: \"<div class=\\\"mat-drawer-inner-container\\\" cdkScrollable #content>\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\" }]\n        }], propDecorators: { fixedInViewport: [{\n                type: Input\n            }], fixedTopGap: [{\n                type: Input\n            }], fixedBottomGap: [{\n                type: Input\n            }] } });\nclass MatSidenavContainer extends MatDrawerContainer {\n    constructor() {\n        super(...arguments);\n        this._allDrawers = undefined;\n        // We need an initializer here to avoid a TS error.\n        this._content = undefined;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavContainer, deps: null, target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.0.0\", version: \"17.0.4\", type: MatSidenavContainer, selector: \"mat-sidenav-container\", host: { attributes: { \"ngSkipHydration\": \"\" }, properties: { \"class.mat-drawer-container-explicit-backdrop\": \"_backdropOverride\" }, classAttribute: \"mat-drawer-container mat-sidenav-container\" }, providers: [\n            {\n                provide: MAT_DRAWER_CONTAINER,\n                useExisting: MatSidenavContainer,\n            },\n        ], queries: [{ propertyName: \"_content\", first: true, predicate: MatSidenavContent, descendants: true }, { propertyName: \"_allDrawers\", predicate: MatSidenav, descendants: true }], exportAs: [\"matSidenavContainer\"], usesInheritance: true, ngImport: i0, template: \"@if (hasBackdrop) {\\n  <div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\"\\n       [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div>\\n}\\n\\n<ng-content select=\\\"mat-sidenav\\\"></ng-content>\\n\\n<ng-content select=\\\"mat-sidenav-content\\\">\\n</ng-content>\\n\\n@if (!_content) {\\n  <mat-sidenav-content>\\n    <ng-content></ng-content>\\n  </mat-sidenav-content>\\n}\\n\", styles: [\".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color);background-color:var(--mat-sidenav-content-background-color);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color)}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{box-shadow:0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);position:relative;z-index:4;color:var(--mat-sidenav-container-text-color);background-color:var(--mat-sidenav-container-background-color);border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*=\\\"visibility: hidden\\\"]{display:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\"], dependencies: [{ kind: \"component\", type: MatSidenavContent, selector: \"mat-sidenav-content\" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavContainer, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-sidenav-container', exportAs: 'matSidenavContainer', host: {\n                        'class': 'mat-drawer-container mat-sidenav-container',\n                        '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\n                        'ngSkipHydration': '',\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, providers: [\n                        {\n                            provide: MAT_DRAWER_CONTAINER,\n                            useExisting: MatSidenavContainer,\n                        },\n                    ], template: \"@if (hasBackdrop) {\\n  <div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\"\\n       [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div>\\n}\\n\\n<ng-content select=\\\"mat-sidenav\\\"></ng-content>\\n\\n<ng-content select=\\\"mat-sidenav-content\\\">\\n</ng-content>\\n\\n@if (!_content) {\\n  <mat-sidenav-content>\\n    <ng-content></ng-content>\\n  </mat-sidenav-content>\\n}\\n\", styles: [\".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color);background-color:var(--mat-sidenav-content-background-color);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color)}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{box-shadow:0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);position:relative;z-index:4;color:var(--mat-sidenav-container-text-color);background-color:var(--mat-sidenav-container-background-color);border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape);border-bottom-left-radius:var(--mat-sidenav-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape);border-bottom-right-radius:var(--mat-sidenav-container-shape);border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*=\\\"visibility: hidden\\\"]{display:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\"] }]\n        }], propDecorators: { _allDrawers: [{\n                type: ContentChildren,\n                args: [MatSidenav, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }], _content: [{\n                type: ContentChild,\n                args: [MatSidenavContent]\n            }] } });\n\nclass MatSidenavModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavModule, declarations: [MatDrawer,\n            MatDrawerContainer,\n            MatDrawerContent,\n            MatSidenav,\n            MatSidenavContainer,\n            MatSidenavContent], imports: [MatCommonModule, CdkScrollableModule], exports: [CdkScrollableModule,\n            MatCommonModule,\n            MatDrawer,\n            MatDrawerContainer,\n            MatDrawerContent,\n            MatSidenav,\n            MatSidenavContainer,\n            MatSidenavContent] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavModule, imports: [MatCommonModule, CdkScrollableModule, CdkScrollableModule,\n            MatCommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatSidenavModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, CdkScrollableModule],\n                    exports: [\n                        CdkScrollableModule,\n                        MatCommonModule,\n                        MatDrawer,\n                        MatDrawerContainer,\n                        MatDrawerContent,\n                        MatSidenav,\n                        MatSidenavContainer,\n                        MatSidenavContent,\n                    ],\n                    declarations: [\n                        MatDrawer,\n                        MatDrawerContainer,\n                        MatDrawerContent,\n                        MatSidenav,\n                        MatSidenavContainer,\n                        MatSidenavContent,\n                    ],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_DRAWER_DEFAULT_AUTOSIZE, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent, MatSidenavModule, matDrawerAnimations, throwMatDuplicatedDrawerError };\n","import * as i0 from '@angular/core';\nimport { Directive, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, ContentChildren, NgModule } from '@angular/core';\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\nimport * as i1 from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\n\n// Boilerplate for applying mixins to MatToolbar.\n/** @docs-private */\nconst _MatToolbarBase = mixinColor(class {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n});\nclass MatToolbarRow {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbarRow, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: MatToolbarRow, selector: \"mat-toolbar-row\", host: { classAttribute: \"mat-toolbar-row\" }, exportAs: [\"matToolbarRow\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbarRow, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'mat-toolbar-row',\n                    exportAs: 'matToolbarRow',\n                    host: { 'class': 'mat-toolbar-row' },\n                }]\n        }] });\nclass MatToolbar extends _MatToolbarBase {\n    constructor(elementRef, _platform, document) {\n        super(elementRef);\n        this._platform = _platform;\n        // TODO: make the document a required param when doing breaking changes.\n        this._document = document;\n    }\n    ngAfterViewInit() {\n        if (this._platform.isBrowser) {\n            this._checkToolbarMixedModes();\n            this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes());\n        }\n    }\n    /**\n     * Throws an exception when developers are attempting to combine the different toolbar row modes.\n     */\n    _checkToolbarMixedModes() {\n        if (this._toolbarRows.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            // Check if there are any other DOM nodes that can display content but aren't inside of\n            // a <mat-toolbar-row> element.\n            const isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes)\n                .filter(node => !(node.classList && node.classList.contains('mat-toolbar-row')))\n                .filter(node => node.nodeType !== (this._document ? this._document.COMMENT_NODE : 8))\n                .some(node => !!(node.textContent && node.textContent.trim()));\n            if (isCombinedUsage) {\n                throwToolbarMixedModesError();\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbar, deps: [{ token: i0.ElementRef }, { token: i1.Platform }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.4\", type: MatToolbar, selector: \"mat-toolbar\", inputs: { color: \"color\" }, host: { properties: { \"class.mat-toolbar-multiple-rows\": \"_toolbarRows.length > 0\", \"class.mat-toolbar-single-row\": \"_toolbarRows.length === 0\" }, classAttribute: \"mat-toolbar\" }, queries: [{ propertyName: \"_toolbarRows\", predicate: MatToolbarRow, descendants: true }], exportAs: [\"matToolbar\"], usesInheritance: true, ngImport: i0, template: \"<ng-content></ng-content>\\n<ng-content select=\\\"mat-toolbar-row\\\"></ng-content>\\n\", styles: [\".mat-toolbar{background:var(--mat-toolbar-container-background-color);color:var(--mat-toolbar-container-text-color)}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font);font-size:var(--mat-toolbar-title-text-size);line-height:var(--mat-toolbar-title-text-line-height);font-weight:var(--mat-toolbar-title-text-weight);letter-spacing:var(--mat-toolbar-title-text-tracking);margin:0}.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color: inherit;--mdc-outlined-button-label-text-color: inherit}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height)}}\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbar, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-toolbar', exportAs: 'matToolbar', inputs: ['color'], host: {\n                        'class': 'mat-toolbar',\n                        '[class.mat-toolbar-multiple-rows]': '_toolbarRows.length > 0',\n                        '[class.mat-toolbar-single-row]': '_toolbarRows.length === 0',\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, template: \"<ng-content></ng-content>\\n<ng-content select=\\\"mat-toolbar-row\\\"></ng-content>\\n\", styles: [\".mat-toolbar{background:var(--mat-toolbar-container-background-color);color:var(--mat-toolbar-container-text-color)}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font);font-size:var(--mat-toolbar-title-text-size);line-height:var(--mat-toolbar-title-text-line-height);font-weight:var(--mat-toolbar-title-text-weight);letter-spacing:var(--mat-toolbar-title-text-tracking);margin:0}.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color: inherit;--mdc-outlined-button-label-text-color: inherit}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height)}}\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.Platform }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }], propDecorators: { _toolbarRows: [{\n                type: ContentChildren,\n                args: [MatToolbarRow, { descendants: true }]\n            }] } });\n/**\n * Throws an exception when attempting to combine the different toolbar row modes.\n * @docs-private\n */\nfunction throwToolbarMixedModesError() {\n    throw Error('MatToolbar: Attempting to combine different toolbar modes. ' +\n        'Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content ' +\n        'inside of a `<mat-toolbar>` for a single row.');\n}\n\nclass MatToolbarModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbarModule, declarations: [MatToolbar, MatToolbarRow], imports: [MatCommonModule], exports: [MatToolbar, MatToolbarRow, MatCommonModule] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbarModule, imports: [MatCommonModule, MatCommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: MatToolbarModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule],\n                    exports: [MatToolbar, MatToolbarRow, MatCommonModule],\n                    declarations: [MatToolbar, MatToolbarRow],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatToolbar, MatToolbarModule, MatToolbarRow, throwToolbarMixedModesError };\n"],"x_google_ignoreList":[0,1]}