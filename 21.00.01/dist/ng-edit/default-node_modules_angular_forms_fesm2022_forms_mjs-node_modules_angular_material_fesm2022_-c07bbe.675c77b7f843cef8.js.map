{"version":3,"file":"default-node_modules_angular_forms_fesm2022_forms_mjs-node_modules_angular_material_fesm2022_-c07bbe.675c77b7f843cef8.js","mappings":"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","names":["BaseControlValueAccessor","_renderer","_elementRef","onChange","_","onTouched","constructor","this","setProperty","key","value","nativeElement","registerOnTouched","fn","registerOnChange","setDisabledState","isDisabled","static","__ngFactoryType__","i0","type","BuiltInControlValueAccessor","BuiltInControlValueAccessor_BaseFactory","features","NG_VALUE_ACCESSOR","InjectionToken","DEFAULT_VALUE_ACCESSOR","provide","useExisting","forwardRef","DefaultValueAccessor","multi","COMPOSITION_BUFFER_MODE","_compositionMode","_composing","renderer","elementRef","super","_isAndroid","userAgent","_getDOM","getUserAgent","test","toLowerCase","writeValue","_handleInput","_compositionStart","_compositionEnd","selectors","hostBindings","rf","ctx","$event","target","standalone","isEmptyInputValue","lengthOrSize","Array","isArray","length","Set","size","NG_VALIDATORS","NG_ASYNC_VALIDATORS","EMAIL_REGEXP","Validators","min","minValidator","max","maxValidator","required","control","requiredValidator","requiredTrue","requiredTrueValidator","email","emailValidator","minLength","minLengthValidator","minlength","requiredLength","actualLength","maxLength","maxLengthValidator","maxlength","pattern","patternValidator","nullValidator","compose","validators","composeAsync","parseFloat","isNaN","actual","regex","regexStr","charAt","RegExp","toString","requiredPattern","actualValue","isPresent","o","toObservable","_isPromise","from","mergeErrors","arrayOfErrors","res","forEach","errors","Object","keys","executeValidators","map","validator","normalizeValidators","isValidatorFn","validate","c","presentValidators","filter","composeValidators","observables","forkJoin","pipe","composeAsyncValidators","mergeValidators","controlValidators","dirValidator","getControlValidators","_rawValidators","getControlAsyncValidators","_rawAsyncValidators","makeValidatorsArray","hasValidator","includes","addValidators","currentValidators","current","validatorsToAdd","v","push","removeValidators","AbstractControlDirective","valid","invalid","pending","disabled","enabled","pristine","dirty","touched","status","untouched","statusChanges","valueChanges","path","_composedValidatorFn","_composedAsyncValidatorFn","_setValidators","_setAsyncValidators","asyncValidator","_onDestroyCallbacks","_registerOnDestroy","_invokeOnDestroyCallbacks","reset","undefined","hasError","errorCode","getError","ControlContainer","name","formDirective","NgControl","_parent","valueAccessor","AbstractControlStatus","_cd","cd","isTouched","_touched","isUntouched","isPristine","_pristine","isDirty","isValid","_status","isInvalid","isPending","isSubmitted","_submitted","submitted","NgControlStatus","hostVars","NgControlStatusGroup","VALID","INVALID","PENDING","DISABLED","ControlEvent","ValueChangeEvent","source","PristineChangeEvent","TouchedChangeEvent","StatusChangeEvent","FormSubmittedEvent","FormResetEvent","pickValidators","validatorOrOpts","isOptionsObj","pickAsyncValidators","asyncValidators","assertControlPresent","parent","isGroup","controls","_RuntimeError","assertAllValuesPresent","_forEachChild","AbstractControl","_pendingDirty","_hasOwnPendingAsyncValidator","_pendingTouched","_onCollectionChange","_updateOn","_asyncValidationSubscription","_assignValidators","_assignAsyncValidators","validatorFn","asyncValidatorFn","untracked","statusReactive","set","computed","signal","pristineReactive","touchedReactive","_events","Subject","events","asObservable","updateOn","setValidators","setAsyncValidators","addAsyncValidators","removeAsyncValidators","hasAsyncValidator","clearValidators","clearAsyncValidators","markAsTouched","opts","changed","sourceControl","onlySelf","emitEvent","next","markAllAsDirty","markAsDirty","markAllAsTouched","markAsUntouched","_updateTouched","markAsPristine","_updatePristine","markAsPending","emit","disable","skipPristineCheck","_parentMarkedDirty","_updateValue","_updateAncestors","_onDisabledChange","changeFn","enable","updateValueAndValidity","setParent","getRawValue","_setInitialStatus","shouldHaveEmitted","_cancelExistingSubscription","_runValidator","_calculateStatus","_runAsyncValidator","_updateTreeValidity","ctrl","_allControlsDisabled","obs","subscribe","setErrors","unsubscribe","_updateControlsErrors","get","currPath","split","reduce","_find","root","x","changedControl","_initObservables","EventEmitter","_anyControlsHaveStatus","_anyControls","_anyControlsDirty","_anyControlsTouched","newPristine","_registerOnCollectionChange","_setUpdateStrategy","slice","coerceToValidator","coerceToAsyncValidator","FormGroup","_setUpControls","registerControl","addControl","options","removeControl","setControl","contains","controlName","hasOwnProperty","setValue","patchValue","_reduceChildren","acc","_syncPendingControls","subtreeUpdated","updated","child","cb","_reduceValue","condition","entries","initValue","UntypedFormGroup","FormRecord","CALL_SET_DISABLED_STATE","factory","setDisabledStateDefault","controlPath","setUpControl","dir","callSetDisabledState","setUpValidators","setUpViewChangePipeline","newValue","_pendingValue","_pendingChange","updateControl","setUpModelChangePipeline","emitModelEvent","viewToModelUpdate","_unregisterOnChange","setUpBlurPipeline","setUpDisabledChangeHandler","onDisabledChange","registerOnDisabledChange","_unregisterOnDisabledChange","cleanUpControl","validateControlPresenceOnChange","noop","cleanUpValidators","registerOnValidatorChange","onValidatorChange","isControlUpdated","updatedValidators","updatedAsyncValidators","emitModelToViewChange","setUpFormContainer","isPropertyUpdated","changes","viewModel","change","model","isFirstChange","is","currentValue","syncPendingControls","form","directives","selectValueAccessor","valueAccessors","defaultAccessor","builtinAccessor","customAccessor","isBuiltInAccessor","getPrototypeOf","formDirectiveProvider$2","NgForm","resolvedPromise$1","Promise","resolve","submittedReactive","_directives","ngSubmit","ngAfterViewInit","then","container","_findContainer","add","getControl","delete","addFormGroup","group","removeFormGroup","getFormGroup","updateModel","onSubmit","method","onReset","resetForm","pop","inputs","outputs","exportAs","removeListItem","list","el","index","indexOf","splice","isFormControlState","formState","FormControl","defaultValue","_onChange","_applyFormState","nonNullable","initialValueIsDefault","emitViewToModelChange","overwriteDefaultValue","UntypedFormControl","formControlBinding$1","NgModel","resolvedPromise","_changeDetectorRef","_registered","update","ngOnChanges","_checkForErrors","_checkName","oldName","previousValue","_getPath","_setUpControl","_updateDisabled","ngOnDestroy","_isStandalone","_setUpStandalone","markForCheck","disabledValue","booleanAttribute","ChangeDetectorRef","NgNoValidate","hostAttrs","NUMBER_VALUE_ACCESSOR","NumberValueAccessor","NumberValueAccessor_BaseFactory","FormArray","at","_adjustIndex","_registerControl","insert","removeAt","adjustedIndex","clear","some","AbstractFormDirective","_submittedReactive","_oldForm","_updateDomValue","onChanges","onDestroy","_checkFormPresent","_updateValidators","_updateRegistrations","removeListItem$1","_setUpFormContainer","_cleanUpFormContainer","getFormArray","addFormArray","removeFormArray","oldCtrl","newCtrl","isFormControl","cleanUpFormContainer","NG_MODEL_WITH_FORM_CONTROL_WARNING","controlNameBinding","FormControlName","_ngModelWarningConfig","_added","_ngModelWarningSent","formDirectiveProvider","FormGroupDirective","FormGroupDirective_BaseFactory","toFloat","AbstractValidatorDirective","_validator","_enabled","inputName","input","normalizeInput","createValidator","MAX_VALIDATOR","MaxValidator","MaxValidator_BaseFactory","MIN_VALIDATOR","MinValidator","MinValidator_BaseFactory","REQUIRED_VALIDATOR","RequiredValidator","RequiredValidator_BaseFactory","PATTERN_VALIDATOR","PatternValidator","PatternValidator_BaseFactory","InternalFormsSharedModule","isAbstractControlOptions","FormBuilder","useNonNullable","nnfb","reducedControls","_reduceControls","newOptions","record","array","createdControls","_createControl","token","fac","providedIn","UntypedFormBuilder","controlsConfig","UntypedFormBuilder_BaseFactory","FormsModule","withConfig","ngModule","providers","useValue","imports","ReactiveFormsModule","warnOnNgModelWithFormControl","_c0","MAT_ICON_DEFAULT_OPTIONS","MAT_ICON_LOCATION","_document","inject","DOCUMENT","_location","location","getPathname","pathname","search","funcIriAttributes","funcIriAttributeSelector","attr","join","funcIriPattern","MatIcon","ElementRef","_iconRegistry","MatIconRegistry","_errorHandler","ErrorHandler","_defaultColor","color","_color","inline","svgIcon","_svgIcon","_updateSvgIcon","_clearSvgElement","fontSet","_fontSet","_cleanupFontValue","_updateFontIconClasses","fontIcon","_fontIcon","_previousFontSetClass","_previousFontIconClass","_svgName","_svgNamespace","_previousPath","_elementsWithExternalReferences","_currentIconFetch","Subscription","EMPTY","ariaHidden","HostAttributeToken","optional","defaults","setAttribute","_splitIconName","iconName","parts","Error","ngOnInit","ngAfterViewChecked","cachedElements","newPath","_prependPathToReferences","_usingFontIcon","_setSvgElement","svg","_cacheChildrenWithExternalReferences","appendChild","layoutElement","childCount","childNodes","nodeType","nodeName","remove","elem","fontSetClasses","classNameForFontAlias","getDefaultFontSetClass","className","classList","trim","elements","attrs","element","elementsWithFuncIri","querySelectorAll","Map","i","elementWithReference","getAttribute","match","attributes","rawName","namespace","getNamedSvgIcon","take","err","handleError","message","ngContentSelectors","decls","vars","template","styles","encapsulation","changeDetection","MatIconModule","BidiModule"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/forms/fesm2022/forms.mjs","./node_modules/@angular/material/fesm2022/icon.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { Directive, InjectionToken, forwardRef, Optional, Inject, isPromise as _isPromise, isSubscribable as _isSubscribable, RuntimeError as _RuntimeError, Self, untracked, computed, signal, EventEmitter, Input, Host, SkipSelf, booleanAttribute, ChangeDetectorRef, Output, Injectable, inject, ApplicationRef, DestroyRef, afterNextRender, NgModule, Version } from '@angular/core';\nimport { getDOM as _getDOM } from '@angular/common';\nimport { forkJoin, from, Subject } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nclass BaseControlValueAccessor {\n  _renderer;\n  _elementRef;\n  onChange = _ => {};\n  onTouched = () => {};\n  constructor(_renderer, _elementRef) {\n    this._renderer = _renderer;\n    this._elementRef = _elementRef;\n  }\n  setProperty(key, value) {\n    this._renderer.setProperty(this._elementRef.nativeElement, key, value);\n  }\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  setDisabledState(isDisabled) {\n    this.setProperty('disabled', isDisabled);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: BaseControlValueAccessor,\n    deps: [{\n      token: i0.Renderer2\n    }, {\n      token: i0.ElementRef\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: BaseControlValueAccessor,\n    isStandalone: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: BaseControlValueAccessor,\n  decorators: [{\n    type: Directive\n  }],\n  ctorParameters: () => [{\n    type: i0.Renderer2\n  }, {\n    type: i0.ElementRef\n  }]\n});\nclass BuiltInControlValueAccessor extends BaseControlValueAccessor {\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: BuiltInControlValueAccessor,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: BuiltInControlValueAccessor,\n    isStandalone: true,\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: BuiltInControlValueAccessor,\n  decorators: [{\n    type: Directive\n  }]\n});\nconst NG_VALUE_ACCESSOR = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgValueAccessor' : '');\n\nconst CHECKBOX_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CheckboxControlValueAccessor),\n  multi: true\n};\nclass CheckboxControlValueAccessor extends BuiltInControlValueAccessor {\n  writeValue(value) {\n    this.setProperty('checked', value);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: CheckboxControlValueAccessor,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: CheckboxControlValueAccessor,\n    isStandalone: false,\n    selector: \"input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]\",\n    host: {\n      listeners: {\n        \"change\": \"onChange($any($event.target).checked)\",\n        \"blur\": \"onTouched()\"\n      }\n    },\n    providers: [CHECKBOX_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: CheckboxControlValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',\n      host: {\n        '(change)': 'onChange($any($event.target).checked)',\n        '(blur)': 'onTouched()'\n      },\n      providers: [CHECKBOX_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }]\n});\n\nconst DEFAULT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DefaultValueAccessor),\n  multi: true\n};\nfunction _isAndroid() {\n  const userAgent = _getDOM() ? _getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\nconst COMPOSITION_BUFFER_MODE = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'CompositionEventMode' : '');\nclass DefaultValueAccessor extends BaseControlValueAccessor {\n  _compositionMode;\n  _composing = false;\n  constructor(renderer, elementRef, _compositionMode) {\n    super(renderer, elementRef);\n    this._compositionMode = _compositionMode;\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n  writeValue(value) {\n    const normalizedValue = value == null ? '' : value;\n    this.setProperty('value', normalizedValue);\n  }\n  _handleInput(value) {\n    if (!this._compositionMode || this._compositionMode && !this._composing) {\n      this.onChange(value);\n    }\n  }\n  _compositionStart() {\n    this._composing = true;\n  }\n  _compositionEnd(value) {\n    this._composing = false;\n    this._compositionMode && this.onChange(value);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: DefaultValueAccessor,\n    deps: [{\n      token: i0.Renderer2\n    }, {\n      token: i0.ElementRef\n    }, {\n      token: COMPOSITION_BUFFER_MODE,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: DefaultValueAccessor,\n    isStandalone: false,\n    selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\",\n    host: {\n      listeners: {\n        \"input\": \"_handleInput($any($event.target).value)\",\n        \"blur\": \"onTouched()\",\n        \"compositionstart\": \"_compositionStart()\",\n        \"compositionend\": \"_compositionEnd($any($event.target).value)\"\n      }\n    },\n    providers: [DEFAULT_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: DefaultValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\n      host: {\n        '(input)': '_handleInput($any($event.target).value)',\n        '(blur)': 'onTouched()',\n        '(compositionstart)': '_compositionStart()',\n        '(compositionend)': '_compositionEnd($any($event.target).value)'\n      },\n      providers: [DEFAULT_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.Renderer2\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [COMPOSITION_BUFFER_MODE]\n    }]\n  }]\n});\n\nfunction isEmptyInputValue(value) {\n  return value == null || lengthOrSize(value) === 0;\n}\nfunction lengthOrSize(value) {\n  if (value == null) {\n    return null;\n  } else if (Array.isArray(value) || typeof value === 'string') {\n    return value.length;\n  } else if (value instanceof Set) {\n    return value.size;\n  }\n  return null;\n}\nconst NG_VALIDATORS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgValidators' : '');\nconst NG_ASYNC_VALIDATORS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgAsyncValidators' : '');\nconst EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nclass Validators {\n  static min(min) {\n    return minValidator(min);\n  }\n  static max(max) {\n    return maxValidator(max);\n  }\n  static required(control) {\n    return requiredValidator(control);\n  }\n  static requiredTrue(control) {\n    return requiredTrueValidator(control);\n  }\n  static email(control) {\n    return emailValidator(control);\n  }\n  static minLength(minLength) {\n    return minLengthValidator(minLength);\n  }\n  static maxLength(maxLength) {\n    return maxLengthValidator(maxLength);\n  }\n  static pattern(pattern) {\n    return patternValidator(pattern);\n  }\n  static nullValidator(control) {\n    return nullValidator();\n  }\n  static compose(validators) {\n    return compose(validators);\n  }\n  static composeAsync(validators) {\n    return composeAsync(validators);\n  }\n}\nfunction minValidator(min) {\n  return control => {\n    if (control.value == null || min == null) {\n      return null;\n    }\n    const value = parseFloat(control.value);\n    return !isNaN(value) && value < min ? {\n      'min': {\n        'min': min,\n        'actual': control.value\n      }\n    } : null;\n  };\n}\nfunction maxValidator(max) {\n  return control => {\n    if (control.value == null || max == null) {\n      return null;\n    }\n    const value = parseFloat(control.value);\n    return !isNaN(value) && value > max ? {\n      'max': {\n        'max': max,\n        'actual': control.value\n      }\n    } : null;\n  };\n}\nfunction requiredValidator(control) {\n  return isEmptyInputValue(control.value) ? {\n    'required': true\n  } : null;\n}\nfunction requiredTrueValidator(control) {\n  return control.value === true ? null : {\n    'required': true\n  };\n}\nfunction emailValidator(control) {\n  if (isEmptyInputValue(control.value)) {\n    return null;\n  }\n  return EMAIL_REGEXP.test(control.value) ? null : {\n    'email': true\n  };\n}\nfunction minLengthValidator(minLength) {\n  return control => {\n    const length = control.value?.length ?? lengthOrSize(control.value);\n    if (length === null || length === 0) {\n      return null;\n    }\n    return length < minLength ? {\n      'minlength': {\n        'requiredLength': minLength,\n        'actualLength': length\n      }\n    } : null;\n  };\n}\nfunction maxLengthValidator(maxLength) {\n  return control => {\n    const length = control.value?.length ?? lengthOrSize(control.value);\n    if (length !== null && length > maxLength) {\n      return {\n        'maxlength': {\n          'requiredLength': maxLength,\n          'actualLength': length\n        }\n      };\n    }\n    return null;\n  };\n}\nfunction patternValidator(pattern) {\n  if (!pattern) return nullValidator;\n  let regex;\n  let regexStr;\n  if (typeof pattern === 'string') {\n    regexStr = '';\n    if (pattern.charAt(0) !== '^') regexStr += '^';\n    regexStr += pattern;\n    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n    regex = new RegExp(regexStr);\n  } else {\n    regexStr = pattern.toString();\n    regex = pattern;\n  }\n  return control => {\n    if (isEmptyInputValue(control.value)) {\n      return null;\n    }\n    const value = control.value;\n    return regex.test(value) ? null : {\n      'pattern': {\n        'requiredPattern': regexStr,\n        'actualValue': value\n      }\n    };\n  };\n}\nfunction nullValidator(control) {\n  return null;\n}\nfunction isPresent(o) {\n  return o != null;\n}\nfunction toObservable(value) {\n  const obs = _isPromise(value) ? from(value) : value;\n  if ((typeof ngDevMode === 'undefined' || ngDevMode) && !_isSubscribable(obs)) {\n    let errorMessage = `Expected async validator to return Promise or Observable.`;\n    if (typeof value === 'object') {\n      errorMessage += ' Are you using a synchronous validator where an async validator is expected?';\n    }\n    throw new _RuntimeError(-1101, errorMessage);\n  }\n  return obs;\n}\nfunction mergeErrors(arrayOfErrors) {\n  let res = {};\n  arrayOfErrors.forEach(errors => {\n    res = errors != null ? {\n      ...res,\n      ...errors\n    } : res;\n  });\n  return Object.keys(res).length === 0 ? null : res;\n}\nfunction executeValidators(control, validators) {\n  return validators.map(validator => validator(control));\n}\nfunction isValidatorFn(validator) {\n  return !validator.validate;\n}\nfunction normalizeValidators(validators) {\n  return validators.map(validator => {\n    return isValidatorFn(validator) ? validator : c => validator.validate(c);\n  });\n}\nfunction compose(validators) {\n  if (!validators) return null;\n  const presentValidators = validators.filter(isPresent);\n  if (presentValidators.length == 0) return null;\n  return function (control) {\n    return mergeErrors(executeValidators(control, presentValidators));\n  };\n}\nfunction composeValidators(validators) {\n  return validators != null ? compose(normalizeValidators(validators)) : null;\n}\nfunction composeAsync(validators) {\n  if (!validators) return null;\n  const presentValidators = validators.filter(isPresent);\n  if (presentValidators.length == 0) return null;\n  return function (control) {\n    const observables = executeValidators(control, presentValidators).map(toObservable);\n    return forkJoin(observables).pipe(map(mergeErrors));\n  };\n}\nfunction composeAsyncValidators(validators) {\n  return validators != null ? composeAsync(normalizeValidators(validators)) : null;\n}\nfunction mergeValidators(controlValidators, dirValidator) {\n  if (controlValidators === null) return [dirValidator];\n  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];\n}\nfunction getControlValidators(control) {\n  return control._rawValidators;\n}\nfunction getControlAsyncValidators(control) {\n  return control._rawAsyncValidators;\n}\nfunction makeValidatorsArray(validators) {\n  if (!validators) return [];\n  return Array.isArray(validators) ? validators : [validators];\n}\nfunction hasValidator(validators, validator) {\n  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;\n}\nfunction addValidators(validators, currentValidators) {\n  const current = makeValidatorsArray(currentValidators);\n  const validatorsToAdd = makeValidatorsArray(validators);\n  validatorsToAdd.forEach(v => {\n    if (!hasValidator(current, v)) {\n      current.push(v);\n    }\n  });\n  return current;\n}\nfunction removeValidators(validators, currentValidators) {\n  return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));\n}\n\nclass AbstractControlDirective {\n  get value() {\n    return this.control ? this.control.value : null;\n  }\n  get valid() {\n    return this.control ? this.control.valid : null;\n  }\n  get invalid() {\n    return this.control ? this.control.invalid : null;\n  }\n  get pending() {\n    return this.control ? this.control.pending : null;\n  }\n  get disabled() {\n    return this.control ? this.control.disabled : null;\n  }\n  get enabled() {\n    return this.control ? this.control.enabled : null;\n  }\n  get errors() {\n    return this.control ? this.control.errors : null;\n  }\n  get pristine() {\n    return this.control ? this.control.pristine : null;\n  }\n  get dirty() {\n    return this.control ? this.control.dirty : null;\n  }\n  get touched() {\n    return this.control ? this.control.touched : null;\n  }\n  get status() {\n    return this.control ? this.control.status : null;\n  }\n  get untouched() {\n    return this.control ? this.control.untouched : null;\n  }\n  get statusChanges() {\n    return this.control ? this.control.statusChanges : null;\n  }\n  get valueChanges() {\n    return this.control ? this.control.valueChanges : null;\n  }\n  get path() {\n    return null;\n  }\n  _composedValidatorFn;\n  _composedAsyncValidatorFn;\n  _rawValidators = [];\n  _rawAsyncValidators = [];\n  _setValidators(validators) {\n    this._rawValidators = validators || [];\n    this._composedValidatorFn = composeValidators(this._rawValidators);\n  }\n  _setAsyncValidators(validators) {\n    this._rawAsyncValidators = validators || [];\n    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);\n  }\n  get validator() {\n    return this._composedValidatorFn || null;\n  }\n  get asyncValidator() {\n    return this._composedAsyncValidatorFn || null;\n  }\n  _onDestroyCallbacks = [];\n  _registerOnDestroy(fn) {\n    this._onDestroyCallbacks.push(fn);\n  }\n  _invokeOnDestroyCallbacks() {\n    this._onDestroyCallbacks.forEach(fn => fn());\n    this._onDestroyCallbacks = [];\n  }\n  reset(value = undefined) {\n    if (this.control) this.control.reset(value);\n  }\n  hasError(errorCode, path) {\n    return this.control ? this.control.hasError(errorCode, path) : false;\n  }\n  getError(errorCode, path) {\n    return this.control ? this.control.getError(errorCode, path) : null;\n  }\n}\n\nclass ControlContainer extends AbstractControlDirective {\n  name;\n  get formDirective() {\n    return null;\n  }\n  get path() {\n    return null;\n  }\n}\n\nclass NgControl extends AbstractControlDirective {\n  _parent = null;\n  name = null;\n  valueAccessor = null;\n}\n\nclass AbstractControlStatus {\n  _cd;\n  constructor(cd) {\n    this._cd = cd;\n  }\n  get isTouched() {\n    this._cd?.control?._touched?.();\n    return !!this._cd?.control?.touched;\n  }\n  get isUntouched() {\n    return !!this._cd?.control?.untouched;\n  }\n  get isPristine() {\n    this._cd?.control?._pristine?.();\n    return !!this._cd?.control?.pristine;\n  }\n  get isDirty() {\n    return !!this._cd?.control?.dirty;\n  }\n  get isValid() {\n    this._cd?.control?._status?.();\n    return !!this._cd?.control?.valid;\n  }\n  get isInvalid() {\n    return !!this._cd?.control?.invalid;\n  }\n  get isPending() {\n    return !!this._cd?.control?.pending;\n  }\n  get isSubmitted() {\n    this._cd?._submitted?.();\n    return !!this._cd?.submitted;\n  }\n}\nconst ngControlStatusHost = {\n  '[class.ng-untouched]': 'isUntouched',\n  '[class.ng-touched]': 'isTouched',\n  '[class.ng-pristine]': 'isPristine',\n  '[class.ng-dirty]': 'isDirty',\n  '[class.ng-valid]': 'isValid',\n  '[class.ng-invalid]': 'isInvalid',\n  '[class.ng-pending]': 'isPending'\n};\nclass NgControlStatus extends AbstractControlStatus {\n  constructor(cd) {\n    super(cd);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgControlStatus,\n    deps: [{\n      token: NgControl,\n      self: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgControlStatus,\n    isStandalone: false,\n    selector: \"[formControlName],[ngModel],[formControl]\",\n    host: {\n      properties: {\n        \"class.ng-untouched\": \"isUntouched\",\n        \"class.ng-touched\": \"isTouched\",\n        \"class.ng-pristine\": \"isPristine\",\n        \"class.ng-dirty\": \"isDirty\",\n        \"class.ng-valid\": \"isValid\",\n        \"class.ng-invalid\": \"isInvalid\",\n        \"class.ng-pending\": \"isPending\"\n      }\n    },\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgControlStatus,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formControlName],[ngModel],[formControl]',\n      host: ngControlStatusHost,\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: NgControl,\n    decorators: [{\n      type: Self\n    }]\n  }]\n});\nclass NgControlStatusGroup extends AbstractControlStatus {\n  constructor(cd) {\n    super(cd);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgControlStatusGroup,\n    deps: [{\n      token: ControlContainer,\n      optional: true,\n      self: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgControlStatusGroup,\n    isStandalone: false,\n    selector: \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],[formArray],form:not([ngNoForm]),[ngForm]\",\n    host: {\n      properties: {\n        \"class.ng-untouched\": \"isUntouched\",\n        \"class.ng-touched\": \"isTouched\",\n        \"class.ng-pristine\": \"isPristine\",\n        \"class.ng-dirty\": \"isDirty\",\n        \"class.ng-valid\": \"isValid\",\n        \"class.ng-invalid\": \"isInvalid\",\n        \"class.ng-pending\": \"isPending\",\n        \"class.ng-submitted\": \"isSubmitted\"\n      }\n    },\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgControlStatusGroup,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],[formArray],form:not([ngNoForm]),[ngForm]',\n      host: {\n        ...ngControlStatusHost,\n        '[class.ng-submitted]': 'isSubmitted'\n      },\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }]\n  }]\n});\n\nconst formControlNameExample = `\n  <div [formGroup]=\"myGroup\">\n    <input formControlName=\"firstName\">\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      firstName: new FormControl()\n  });`;\nconst formGroupNameExample = `\n  <div [formGroup]=\"myGroup\">\n      <div formGroupName=\"person\">\n        <input formControlName=\"firstName\">\n      </div>\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      person: new FormGroup({ firstName: new FormControl() })\n  });`;\nconst formArrayNameExample = `\n  <div [formGroup]=\"myGroup\">\n    <div formArrayName=\"cities\">\n      <div *ngFor=\"let city of cityArray.controls; index as i\">\n        <input [formControlName]=\"i\">\n      </div>\n    </div>\n  </div>\n\n  In your class:\n\n  this.cityArray = new FormArray([new FormControl('SF')]);\n  this.myGroup = new FormGroup({\n    cities: this.cityArray\n  });`;\nconst ngModelGroupExample = `\n  <form>\n      <div ngModelGroup=\"person\">\n        <input [(ngModel)]=\"person.name\" name=\"firstName\">\n      </div>\n  </form>`;\nconst ngModelWithFormGroupExample = `\n  <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n      <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n  </div>\n`;\n\nfunction controlParentException(nameOrIndex) {\n  return new _RuntimeError(1050, `formControlName must be used with a parent formGroup or formArray directive. You'll want to add a formGroup/formArray\n      directive and pass it an existing FormGroup/FormArray instance (you can create one in your class).\n\n      ${describeFormControl(nameOrIndex)}\n\n    Example:\n\n    ${formControlNameExample}`);\n}\nfunction describeFormControl(nameOrIndex) {\n  if (nameOrIndex == null || nameOrIndex === '') {\n    return '';\n  }\n  const valueType = typeof nameOrIndex === 'string' ? 'name' : 'index';\n  return `Affected Form Control ${valueType}: \"${nameOrIndex}\"`;\n}\nfunction ngModelGroupException() {\n  return new _RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n      that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n      Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n      ${formGroupNameExample}\n\n      Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n      ${ngModelGroupExample}`);\n}\nfunction missingFormException() {\n  return new _RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.\n\n      Example:\n\n      ${formControlNameExample}`);\n}\nfunction groupParentException() {\n  return new _RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n    directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formGroupNameExample}`);\n}\nfunction arrayParentException() {\n  return new _RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${formArrayNameExample}`);\n}\nconst disabledAttrWarning = `\n  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n  you. We recommend using this approach to avoid 'changed after checked' errors.\n\n  Example:\n  // Specify the \\`disabled\\` property at control creation time:\n  form = new FormGroup({\n    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n    last: new FormControl('Drew', Validators.required)\n  });\n\n  // Controls can also be enabled/disabled after creation:\n  form.get('first')?.enable();\n  form.get('last')?.disable();\n`;\nconst asyncValidatorsDroppedWithOptsWarning = `\n  It looks like you're constructing using a FormControl with both an options argument and an\n  async validators argument. Mixing these arguments will cause your async validators to be dropped.\n  You should either put all your validators in the options object, or in separate validators\n  arguments. For example:\n\n  // Using validators arguments\n  fc = new FormControl(42, Validators.required, myAsyncValidator);\n\n  // Using AbstractControlOptions\n  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});\n\n  // Do NOT mix them: async validators will be dropped!\n  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);\n`;\nfunction ngModelWarning(directiveName) {\n  return `\n  It looks like you're using ngModel on the same form field as ${directiveName}.\n  Support for using the ngModel input property and ngModelChange event with\n  reactive form directives has been deprecated in Angular v6 and will be removed\n  in a future version of Angular.\n\n  For more information on this, see our API docs here:\n  https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel\n  `;\n}\nfunction describeKey(isFormGroup, key) {\n  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;\n}\nfunction noControlsError(isFormGroup) {\n  return `\n    There are no form controls registered with this ${isFormGroup ? 'group' : 'array'} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `;\n}\nfunction missingControlError(isFormGroup, key) {\n  return `Cannot find form control ${describeKey(isFormGroup, key)}`;\n}\nfunction missingControlValueError(isFormGroup, key) {\n  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;\n}\n\nconst VALID = 'VALID';\nconst INVALID = 'INVALID';\nconst PENDING = 'PENDING';\nconst DISABLED = 'DISABLED';\nclass ControlEvent {}\nclass ValueChangeEvent extends ControlEvent {\n  value;\n  source;\n  constructor(value, source) {\n    super();\n    this.value = value;\n    this.source = source;\n  }\n}\nclass PristineChangeEvent extends ControlEvent {\n  pristine;\n  source;\n  constructor(pristine, source) {\n    super();\n    this.pristine = pristine;\n    this.source = source;\n  }\n}\nclass TouchedChangeEvent extends ControlEvent {\n  touched;\n  source;\n  constructor(touched, source) {\n    super();\n    this.touched = touched;\n    this.source = source;\n  }\n}\nclass StatusChangeEvent extends ControlEvent {\n  status;\n  source;\n  constructor(status, source) {\n    super();\n    this.status = status;\n    this.source = source;\n  }\n}\nclass FormSubmittedEvent extends ControlEvent {\n  source;\n  constructor(source) {\n    super();\n    this.source = source;\n  }\n}\nclass FormResetEvent extends ControlEvent {\n  source;\n  constructor(source) {\n    super();\n    this.source = source;\n  }\n}\nfunction pickValidators(validatorOrOpts) {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\nfunction coerceToValidator(validator) {\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\nfunction pickAsyncValidators(asyncValidator, validatorOrOpts) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (isOptionsObj(validatorOrOpts) && asyncValidator) {\n      console.warn(asyncValidatorsDroppedWithOptsWarning);\n    }\n  }\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\nfunction coerceToAsyncValidator(asyncValidator) {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;\n}\nfunction isOptionsObj(validatorOrOpts) {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === 'object';\n}\nfunction assertControlPresent(parent, isGroup, key) {\n  const controls = parent.controls;\n  const collection = isGroup ? Object.keys(controls) : controls;\n  if (!collection.length) {\n    throw new _RuntimeError(1000, typeof ngDevMode === 'undefined' || ngDevMode ? noControlsError(isGroup) : '');\n  }\n  if (!controls[key]) {\n    throw new _RuntimeError(1001, typeof ngDevMode === 'undefined' || ngDevMode ? missingControlError(isGroup, key) : '');\n  }\n}\nfunction assertAllValuesPresent(control, isGroup, value) {\n  control._forEachChild((_, key) => {\n    if (value[key] === undefined) {\n      throw new _RuntimeError(1002, typeof ngDevMode === 'undefined' || ngDevMode ? missingControlValueError(isGroup, key) : '');\n    }\n  });\n}\nclass AbstractControl {\n  _pendingDirty = false;\n  _hasOwnPendingAsyncValidator = null;\n  _pendingTouched = false;\n  _onCollectionChange = () => {};\n  _updateOn;\n  _parent = null;\n  _asyncValidationSubscription;\n  _composedValidatorFn;\n  _composedAsyncValidatorFn;\n  _rawValidators;\n  _rawAsyncValidators;\n  value;\n  constructor(validators, asyncValidators) {\n    this._assignValidators(validators);\n    this._assignAsyncValidators(asyncValidators);\n  }\n  get validator() {\n    return this._composedValidatorFn;\n  }\n  set validator(validatorFn) {\n    this._rawValidators = this._composedValidatorFn = validatorFn;\n  }\n  get asyncValidator() {\n    return this._composedAsyncValidatorFn;\n  }\n  set asyncValidator(asyncValidatorFn) {\n    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get status() {\n    return untracked(this.statusReactive);\n  }\n  set status(v) {\n    untracked(() => this.statusReactive.set(v));\n  }\n  _status = computed(() => this.statusReactive(), ...(ngDevMode ? [{\n    debugName: \"_status\"\n  }] : []));\n  statusReactive = signal(undefined, ...(ngDevMode ? [{\n    debugName: \"statusReactive\"\n  }] : []));\n  get valid() {\n    return this.status === VALID;\n  }\n  get invalid() {\n    return this.status === INVALID;\n  }\n  get pending() {\n    return this.status == PENDING;\n  }\n  get disabled() {\n    return this.status === DISABLED;\n  }\n  get enabled() {\n    return this.status !== DISABLED;\n  }\n  errors;\n  get pristine() {\n    return untracked(this.pristineReactive);\n  }\n  set pristine(v) {\n    untracked(() => this.pristineReactive.set(v));\n  }\n  _pristine = computed(() => this.pristineReactive(), ...(ngDevMode ? [{\n    debugName: \"_pristine\"\n  }] : []));\n  pristineReactive = signal(true, ...(ngDevMode ? [{\n    debugName: \"pristineReactive\"\n  }] : []));\n  get dirty() {\n    return !this.pristine;\n  }\n  get touched() {\n    return untracked(this.touchedReactive);\n  }\n  set touched(v) {\n    untracked(() => this.touchedReactive.set(v));\n  }\n  _touched = computed(() => this.touchedReactive(), ...(ngDevMode ? [{\n    debugName: \"_touched\"\n  }] : []));\n  touchedReactive = signal(false, ...(ngDevMode ? [{\n    debugName: \"touchedReactive\"\n  }] : []));\n  get untouched() {\n    return !this.touched;\n  }\n  _events = new Subject();\n  events = this._events.asObservable();\n  valueChanges;\n  statusChanges;\n  get updateOn() {\n    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : 'change';\n  }\n  setValidators(validators) {\n    this._assignValidators(validators);\n  }\n  setAsyncValidators(validators) {\n    this._assignAsyncValidators(validators);\n  }\n  addValidators(validators) {\n    this.setValidators(addValidators(validators, this._rawValidators));\n  }\n  addAsyncValidators(validators) {\n    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));\n  }\n  removeValidators(validators) {\n    this.setValidators(removeValidators(validators, this._rawValidators));\n  }\n  removeAsyncValidators(validators) {\n    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));\n  }\n  hasValidator(validator) {\n    return hasValidator(this._rawValidators, validator);\n  }\n  hasAsyncValidator(validator) {\n    return hasValidator(this._rawAsyncValidators, validator);\n  }\n  clearValidators() {\n    this.validator = null;\n  }\n  clearAsyncValidators() {\n    this.asyncValidator = null;\n  }\n  markAsTouched(opts = {}) {\n    const changed = this.touched === false;\n    this.touched = true;\n    const sourceControl = opts.sourceControl ?? this;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched({\n        ...opts,\n        sourceControl\n      });\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new TouchedChangeEvent(true, sourceControl));\n    }\n  }\n  markAllAsDirty(opts = {}) {\n    this.markAsDirty({\n      onlySelf: true,\n      emitEvent: opts.emitEvent,\n      sourceControl: this\n    });\n    this._forEachChild(control => control.markAllAsDirty(opts));\n  }\n  markAllAsTouched(opts = {}) {\n    this.markAsTouched({\n      onlySelf: true,\n      emitEvent: opts.emitEvent,\n      sourceControl: this\n    });\n    this._forEachChild(control => control.markAllAsTouched(opts));\n  }\n  markAsUntouched(opts = {}) {\n    const changed = this.touched === true;\n    this.touched = false;\n    this._pendingTouched = false;\n    const sourceControl = opts.sourceControl ?? this;\n    this._forEachChild(control => {\n      control.markAsUntouched({\n        onlySelf: true,\n        emitEvent: opts.emitEvent,\n        sourceControl\n      });\n    });\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts, sourceControl);\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new TouchedChangeEvent(false, sourceControl));\n    }\n  }\n  markAsDirty(opts = {}) {\n    const changed = this.pristine === true;\n    this.pristine = false;\n    const sourceControl = opts.sourceControl ?? this;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty({\n        ...opts,\n        sourceControl\n      });\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new PristineChangeEvent(false, sourceControl));\n    }\n  }\n  markAsPristine(opts = {}) {\n    const changed = this.pristine === false;\n    this.pristine = true;\n    this._pendingDirty = false;\n    const sourceControl = opts.sourceControl ?? this;\n    this._forEachChild(control => {\n      control.markAsPristine({\n        onlySelf: true,\n        emitEvent: opts.emitEvent\n      });\n    });\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts, sourceControl);\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new PristineChangeEvent(true, sourceControl));\n    }\n  }\n  markAsPending(opts = {}) {\n    this.status = PENDING;\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      this.statusChanges.emit(this.status);\n    }\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending({\n        ...opts,\n        sourceControl\n      });\n    }\n  }\n  disable(opts = {}) {\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n    this.status = DISABLED;\n    this.errors = null;\n    this._forEachChild(control => {\n      control.disable({\n        ...opts,\n        onlySelf: true\n      });\n    });\n    this._updateValue();\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new ValueChangeEvent(this.value, sourceControl));\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      this.valueChanges.emit(this.value);\n      this.statusChanges.emit(this.status);\n    }\n    this._updateAncestors({\n      ...opts,\n      skipPristineCheck\n    }, this);\n    this._onDisabledChange.forEach(changeFn => changeFn(true));\n  }\n  enable(opts = {}) {\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n    this.status = VALID;\n    this._forEachChild(control => {\n      control.enable({\n        ...opts,\n        onlySelf: true\n      });\n    });\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n    this._updateAncestors({\n      ...opts,\n      skipPristineCheck\n    }, this);\n    this._onDisabledChange.forEach(changeFn => changeFn(false));\n  }\n  _updateAncestors(opts, sourceControl) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      if (!opts.skipPristineCheck) {\n        this._parent._updatePristine({}, sourceControl);\n      }\n      this._parent._updateTouched({}, sourceControl);\n    }\n  }\n  setParent(parent) {\n    this._parent = parent;\n  }\n  getRawValue() {\n    return this.value;\n  }\n  updateValueAndValidity(opts = {}) {\n    this._setInitialStatus();\n    this._updateValue();\n    if (this.enabled) {\n      const shouldHaveEmitted = this._cancelExistingSubscription();\n      this.errors = this._runValidator();\n      this.status = this._calculateStatus();\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);\n      }\n    }\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new ValueChangeEvent(this.value, sourceControl));\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      this.valueChanges.emit(this.value);\n      this.statusChanges.emit(this.status);\n    }\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity({\n        ...opts,\n        sourceControl\n      });\n    }\n  }\n  _updateTreeValidity(opts = {\n    emitEvent: true\n  }) {\n    this._forEachChild(ctrl => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n  }\n  _setInitialStatus() {\n    this.status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n  _runValidator() {\n    return this.validator ? this.validator(this) : null;\n  }\n  _runAsyncValidator(shouldHaveEmitted, emitEvent) {\n    if (this.asyncValidator) {\n      this.status = PENDING;\n      this._hasOwnPendingAsyncValidator = {\n        emitEvent: emitEvent !== false,\n        shouldHaveEmitted: shouldHaveEmitted !== false\n      };\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe(errors => {\n        this._hasOwnPendingAsyncValidator = null;\n        this.setErrors(errors, {\n          emitEvent,\n          shouldHaveEmitted\n        });\n      });\n    }\n  }\n  _cancelExistingSubscription() {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n      const shouldHaveEmitted = (this._hasOwnPendingAsyncValidator?.emitEvent || this._hasOwnPendingAsyncValidator?.shouldHaveEmitted) ?? false;\n      this._hasOwnPendingAsyncValidator = null;\n      return shouldHaveEmitted;\n    }\n    return false;\n  }\n  setErrors(errors, opts = {}) {\n    this.errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);\n  }\n  get(path) {\n    let currPath = path;\n    if (currPath == null) return null;\n    if (!Array.isArray(currPath)) currPath = currPath.split('.');\n    if (currPath.length === 0) return null;\n    return currPath.reduce((control, name) => control && control._find(name), this);\n  }\n  getError(errorCode, path) {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n  hasError(errorCode, path) {\n    return !!this.getError(errorCode, path);\n  }\n  get root() {\n    let x = this;\n    while (x._parent) {\n      x = x._parent;\n    }\n    return x;\n  }\n  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {\n    this.status = this._calculateStatus();\n    if (emitEvent) {\n      this.statusChanges.emit(this.status);\n    }\n    if (emitEvent || shouldHaveEmitted) {\n      this._events.next(new StatusChangeEvent(this.status, changedControl));\n    }\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);\n    }\n  }\n  _initObservables() {\n    this.valueChanges = new EventEmitter();\n    this.statusChanges = new EventEmitter();\n  }\n  _calculateStatus() {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n  _anyControlsHaveStatus(status) {\n    return this._anyControls(control => control.status === status);\n  }\n  _anyControlsDirty() {\n    return this._anyControls(control => control.dirty);\n  }\n  _anyControlsTouched() {\n    return this._anyControls(control => control.touched);\n  }\n  _updatePristine(opts, changedControl) {\n    const newPristine = !this._anyControlsDirty();\n    const changed = this.pristine !== newPristine;\n    this.pristine = newPristine;\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts, changedControl);\n    }\n    if (changed) {\n      this._events.next(new PristineChangeEvent(this.pristine, changedControl));\n    }\n  }\n  _updateTouched(opts = {}, changedControl) {\n    this.touched = this._anyControlsTouched();\n    this._events.next(new TouchedChangeEvent(this.touched, changedControl));\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts, changedControl);\n    }\n  }\n  _onDisabledChange = [];\n  _registerOnCollectionChange(fn) {\n    this._onCollectionChange = fn;\n  }\n  _setUpdateStrategy(opts) {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn;\n    }\n  }\n  _parentMarkedDirty(onlySelf) {\n    const parentDirty = this._parent && this._parent.dirty;\n    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();\n  }\n  _find(name) {\n    return null;\n  }\n  _assignValidators(validators) {\n    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedValidatorFn = coerceToValidator(this._rawValidators);\n  }\n  _assignAsyncValidators(validators) {\n    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n  }\n}\n\nclass FormGroup extends AbstractControl {\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateFormGroupControls(controls);\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: !!this.asyncValidator\n    });\n  }\n  controls;\n  registerControl(name, control) {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n  addControl(name, control, options = {}) {\n    this.registerControl(name, control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  removeControl(name, options = {}) {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  setControl(name, control, options = {}) {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  contains(controlName) {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n  setValue(value, options = {}) {\n    assertAllValuesPresent(this, true, value);\n    Object.keys(value).forEach(name => {\n      assertControlPresent(this, true, name);\n      this.controls[name].setValue(value[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  patchValue(value, options = {}) {\n    if (value == null) return;\n    Object.keys(value).forEach(name => {\n      const control = this.controls[name];\n      if (control) {\n        control.patchValue(value[name], {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  reset(value = {}, options = {}) {\n    this._forEachChild((control, name) => {\n      control.reset(value ? value[name] : null, {\n        ...options,\n        onlySelf: true\n      });\n    });\n    this._updatePristine(options, this);\n    this._updateTouched(options, this);\n    this.updateValueAndValidity(options);\n    if (options?.emitEvent !== false) {\n      this._events.next(new FormResetEvent(this));\n    }\n  }\n  getRawValue() {\n    return this._reduceChildren({}, (acc, control, name) => {\n      acc[name] = control.getRawValue();\n      return acc;\n    });\n  }\n  _syncPendingControls() {\n    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({\n      onlySelf: true\n    });\n    return subtreeUpdated;\n  }\n  _forEachChild(cb) {\n    Object.keys(this.controls).forEach(key => {\n      const control = this.controls[key];\n      control && cb(control, key);\n    });\n  }\n  _setUpControls() {\n    this._forEachChild(control => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n  _updateValue() {\n    this.value = this._reduceValue();\n  }\n  _anyControls(condition) {\n    for (const [controlName, control] of Object.entries(this.controls)) {\n      if (this.contains(controlName) && condition(control)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _reduceValue() {\n    let acc = {};\n    return this._reduceChildren(acc, (acc, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc[name] = control.value;\n      }\n      return acc;\n    });\n  }\n  _reduceChildren(initValue, fn) {\n    let res = initValue;\n    this._forEachChild((control, name) => {\n      res = fn(res, control, name);\n    });\n    return res;\n  }\n  _allControlsDisabled() {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n  _find(name) {\n    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;\n  }\n}\nfunction validateFormGroupControls(controls) {\n  const invalidKeys = Object.keys(controls).filter(key => key.includes('.'));\n  if (invalidKeys.length > 0) {\n    console.warn(`FormGroup keys cannot include \\`.\\`, please replace the keys for: ${invalidKeys.join(',')}.`);\n  }\n}\nconst UntypedFormGroup = FormGroup;\nconst isFormGroup = control => control instanceof FormGroup;\nclass FormRecord extends FormGroup {}\nconst isFormRecord = control => control instanceof FormRecord;\n\nconst CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'CallSetDisabledState' : '', {\n  factory: () => setDisabledStateDefault\n});\nconst setDisabledStateDefault = 'always';\nfunction controlPath(name, parent) {\n  return [...parent.path, name];\n}\nfunction setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!control) _throwError(dir, 'Cannot find control with');\n    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);\n  }\n  setUpValidators(control, dir);\n  dir.valueAccessor.writeValue(control.value);\n  if (control.disabled || callSetDisabledState === 'always') {\n    dir.valueAccessor.setDisabledState?.(control.disabled);\n  }\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n  setUpBlurPipeline(control, dir);\n  setUpDisabledChangeHandler(control, dir);\n}\nfunction cleanUpControl(control, dir, validateControlPresenceOnChange = true) {\n  const noop = () => {\n    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      _noControlError(dir);\n    }\n  };\n  if (dir.valueAccessor) {\n    dir.valueAccessor.registerOnChange(noop);\n    dir.valueAccessor.registerOnTouched(noop);\n  }\n  cleanUpValidators(control, dir);\n  if (control) {\n    dir._invokeOnDestroyCallbacks();\n    control._registerOnCollectionChange(() => {});\n  }\n}\nfunction registerOnValidatorChange(validators, onChange) {\n  validators.forEach(validator => {\n    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);\n  });\n}\nfunction setUpDisabledChangeHandler(control, dir) {\n  if (dir.valueAccessor.setDisabledState) {\n    const onDisabledChange = isDisabled => {\n      dir.valueAccessor.setDisabledState(isDisabled);\n    };\n    control.registerOnDisabledChange(onDisabledChange);\n    dir._registerOnDestroy(() => {\n      control._unregisterOnDisabledChange(onDisabledChange);\n    });\n  }\n}\nfunction setUpValidators(control, dir) {\n  const validators = getControlValidators(control);\n  if (dir.validator !== null) {\n    control.setValidators(mergeValidators(validators, dir.validator));\n  } else if (typeof validators === 'function') {\n    control.setValidators([validators]);\n  }\n  const asyncValidators = getControlAsyncValidators(control);\n  if (dir.asyncValidator !== null) {\n    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));\n  } else if (typeof asyncValidators === 'function') {\n    control.setAsyncValidators([asyncValidators]);\n  }\n  const onValidatorChange = () => control.updateValueAndValidity();\n  registerOnValidatorChange(dir._rawValidators, onValidatorChange);\n  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);\n}\nfunction cleanUpValidators(control, dir) {\n  let isControlUpdated = false;\n  if (control !== null) {\n    if (dir.validator !== null) {\n      const validators = getControlValidators(control);\n      if (Array.isArray(validators) && validators.length > 0) {\n        const updatedValidators = validators.filter(validator => validator !== dir.validator);\n        if (updatedValidators.length !== validators.length) {\n          isControlUpdated = true;\n          control.setValidators(updatedValidators);\n        }\n      }\n    }\n    if (dir.asyncValidator !== null) {\n      const asyncValidators = getControlAsyncValidators(control);\n      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n        const updatedAsyncValidators = asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);\n        if (updatedAsyncValidators.length !== asyncValidators.length) {\n          isControlUpdated = true;\n          control.setAsyncValidators(updatedAsyncValidators);\n        }\n      }\n    }\n  }\n  const noop = () => {};\n  registerOnValidatorChange(dir._rawValidators, noop);\n  registerOnValidatorChange(dir._rawAsyncValidators, noop);\n  return isControlUpdated;\n}\nfunction setUpViewChangePipeline(control, dir) {\n  dir.valueAccessor.registerOnChange(newValue => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n    if (control.updateOn === 'change') updateControl(control, dir);\n  });\n}\nfunction setUpBlurPipeline(control, dir) {\n  dir.valueAccessor.registerOnTouched(() => {\n    control._pendingTouched = true;\n    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== 'submit') control.markAsTouched();\n  });\n}\nfunction updateControl(control, dir) {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {\n    emitModelToViewChange: false\n  });\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\nfunction setUpModelChangePipeline(control, dir) {\n  const onChange = (newValue, emitModelEvent) => {\n    dir.valueAccessor.writeValue(newValue);\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  };\n  control.registerOnChange(onChange);\n  dir._registerOnDestroy(() => {\n    control._unregisterOnChange(onChange);\n  });\n}\nfunction setUpFormContainer(control, dir) {\n  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Cannot find control with');\n  setUpValidators(control, dir);\n}\nfunction cleanUpFormContainer(control, dir) {\n  return cleanUpValidators(control, dir);\n}\nfunction _noControlError(dir) {\n  return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\nfunction _throwError(dir, message) {\n  const messageEnd = _describeControlLocation(dir);\n  throw new Error(`${message} ${messageEnd}`);\n}\nfunction _describeControlLocation(dir) {\n  const path = dir.path;\n  if (path && path.length > 1) return `path: '${path.join(' -> ')}'`;\n  if (path?.[0]) return `name: '${path}'`;\n  return 'unspecified name attribute';\n}\nfunction _throwMissingValueAccessorError(dir) {\n  const loc = _describeControlLocation(dir);\n  throw new _RuntimeError(-1203, `No value accessor for form control ${loc}.`);\n}\nfunction _throwInvalidValueAccessorError(dir) {\n  const loc = _describeControlLocation(dir);\n  throw new _RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. ` + `Check that the \\`NG_VALUE_ACCESSOR\\` token is configured as a \\`multi: true\\` provider.`);\n}\nfunction isPropertyUpdated(changes, viewModel) {\n  if (!changes.hasOwnProperty('model')) return false;\n  const change = changes['model'];\n  if (change.isFirstChange()) return true;\n  return !Object.is(viewModel, change.currentValue);\n}\nfunction isBuiltInAccessor(valueAccessor) {\n  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;\n}\nfunction syncPendingControls(form, directives) {\n  form._syncPendingControls();\n  directives.forEach(dir => {\n    const control = dir.control;\n    if (control.updateOn === 'submit' && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n}\nfunction selectValueAccessor(dir, valueAccessors) {\n  if (!valueAccessors) return null;\n  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwInvalidValueAccessorError(dir);\n  let defaultAccessor = undefined;\n  let builtinAccessor = undefined;\n  let customAccessor = undefined;\n  valueAccessors.forEach(v => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one built-in value accessor matches form control with');\n      builtinAccessor = v;\n    } else {\n      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one custom value accessor matches form control with');\n      customAccessor = v;\n    }\n  });\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    _throwError(dir, 'No valid value accessor for form control with');\n  }\n  return null;\n}\nfunction removeListItem$1(list, el) {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\nfunction _ngModelWarning(name, type, instance, warningConfig) {\n  if (warningConfig === 'never') return;\n  if ((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce || warningConfig === 'always' && !instance._ngModelWarningSent) {\n    console.warn(ngModelWarning(name));\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}\n\nconst formDirectiveProvider$2 = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => NgForm)\n};\nconst resolvedPromise$1 = (() => Promise.resolve())();\nclass NgForm extends ControlContainer {\n  callSetDisabledState;\n  get submitted() {\n    return untracked(this.submittedReactive);\n  }\n  _submitted = computed(() => this.submittedReactive(), ...(ngDevMode ? [{\n    debugName: \"_submitted\"\n  }] : []));\n  submittedReactive = signal(false, ...(ngDevMode ? [{\n    debugName: \"submittedReactive\"\n  }] : []));\n  _directives = new Set();\n  form;\n  ngSubmit = new EventEmitter();\n  options;\n  constructor(validators, asyncValidators, callSetDisabledState) {\n    super();\n    this.callSetDisabledState = callSetDisabledState;\n    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));\n  }\n  ngAfterViewInit() {\n    this._setUpdateStrategy();\n  }\n  get formDirective() {\n    return this;\n  }\n  get control() {\n    return this.form;\n  }\n  get path() {\n    return [];\n  }\n  get controls() {\n    return this.form.controls;\n  }\n  addControl(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      dir.control = container.registerControl(dir.name, dir.control);\n      setUpControl(dir.control, dir, this.callSetDisabledState);\n      dir.control.updateValueAndValidity({\n        emitEvent: false\n      });\n      this._directives.add(dir);\n    });\n  }\n  getControl(dir) {\n    return this.form.get(dir.path);\n  }\n  removeControl(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      if (container) {\n        container.removeControl(dir.name);\n      }\n      this._directives.delete(dir);\n    });\n  }\n  addFormGroup(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      const group = new FormGroup({});\n      setUpFormContainer(group, dir);\n      container.registerControl(dir.name, group);\n      group.updateValueAndValidity({\n        emitEvent: false\n      });\n    });\n  }\n  removeFormGroup(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      if (container) {\n        container.removeControl(dir.name);\n      }\n    });\n  }\n  getFormGroup(dir) {\n    return this.form.get(dir.path);\n  }\n  updateModel(dir, value) {\n    resolvedPromise$1.then(() => {\n      const ctrl = this.form.get(dir.path);\n      ctrl.setValue(value);\n    });\n  }\n  setValue(value) {\n    this.control.setValue(value);\n  }\n  onSubmit($event) {\n    this.submittedReactive.set(true);\n    syncPendingControls(this.form, this._directives);\n    this.ngSubmit.emit($event);\n    this.form._events.next(new FormSubmittedEvent(this.control));\n    return $event?.target?.method === 'dialog';\n  }\n  onReset() {\n    this.resetForm();\n  }\n  resetForm(value = undefined) {\n    this.form.reset(value);\n    this.submittedReactive.set(false);\n  }\n  _setUpdateStrategy() {\n    if (this.options && this.options.updateOn != null) {\n      this.form._updateOn = this.options.updateOn;\n    }\n  }\n  _findContainer(path) {\n    path.pop();\n    return path.length ? this.form.get(path) : this.form;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgForm,\n    deps: [{\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: CALL_SET_DISABLED_STATE,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgForm,\n    isStandalone: false,\n    selector: \"form:not([ngNoForm]):not([formGroup]):not([formArray]),ng-form,[ngForm]\",\n    inputs: {\n      options: [\"ngFormOptions\", \"options\"]\n    },\n    outputs: {\n      ngSubmit: \"ngSubmit\"\n    },\n    host: {\n      listeners: {\n        \"submit\": \"onSubmit($event)\",\n        \"reset\": \"onReset()\"\n      }\n    },\n    providers: [formDirectiveProvider$2],\n    exportAs: [\"ngForm\"],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgForm,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'form:not([ngNoForm]):not([formGroup]):not([formArray]),ng-form,[ngForm]',\n      providers: [formDirectiveProvider$2],\n      host: {\n        '(submit)': 'onSubmit($event)',\n        '(reset)': 'onReset()'\n      },\n      outputs: ['ngSubmit'],\n      exportAs: 'ngForm',\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }],\n  propDecorators: {\n    options: [{\n      type: Input,\n      args: ['ngFormOptions']\n    }]\n  }\n});\n\nfunction removeListItem(list, el) {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\n\nfunction isFormControlState(formState) {\n  return typeof formState === 'object' && formState !== null && Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n}\nconst FormControl = class FormControl extends AbstractControl {\n  defaultValue = null;\n  _onChange = [];\n  _pendingValue;\n  _pendingChange = false;\n  constructor(formState = null, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this._initObservables();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: !!this.asyncValidator\n    });\n    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {\n      if (isFormControlState(formState)) {\n        this.defaultValue = formState.value;\n      } else {\n        this.defaultValue = formState;\n      }\n    }\n  }\n  setValue(value, options = {}) {\n    this.value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach(changeFn => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity(options);\n  }\n  patchValue(value, options = {}) {\n    this.setValue(value, options);\n  }\n  reset(formState = this.defaultValue, options = {}) {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    if (options.overwriteDefaultValue) {\n      this.defaultValue = this.value;\n    }\n    this._pendingChange = false;\n    if (options?.emitEvent !== false) {\n      this._events.next(new FormResetEvent(this));\n    }\n  }\n  _updateValue() {}\n  _anyControls(condition) {\n    return false;\n  }\n  _allControlsDisabled() {\n    return this.disabled;\n  }\n  registerOnChange(fn) {\n    this._onChange.push(fn);\n  }\n  _unregisterOnChange(fn) {\n    removeListItem(this._onChange, fn);\n  }\n  registerOnDisabledChange(fn) {\n    this._onDisabledChange.push(fn);\n  }\n  _unregisterOnDisabledChange(fn) {\n    removeListItem(this._onDisabledChange, fn);\n  }\n  _forEachChild(cb) {}\n  _syncPendingControls() {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {\n          onlySelf: true,\n          emitModelToViewChange: false\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n  _applyFormState(formState) {\n    if (isFormControlState(formState)) {\n      this.value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({\n        onlySelf: true,\n        emitEvent: false\n      }) : this.enable({\n        onlySelf: true,\n        emitEvent: false\n      });\n    } else {\n      this.value = this._pendingValue = formState;\n    }\n  }\n};\nconst UntypedFormControl = FormControl;\nconst isFormControl = control => control instanceof FormControl;\n\nclass AbstractFormGroupDirective extends ControlContainer {\n  _parent;\n  ngOnInit() {\n    this._checkParentType();\n    this.formDirective.addFormGroup(this);\n  }\n  ngOnDestroy() {\n    if (this.formDirective) {\n      this.formDirective.removeFormGroup(this);\n    }\n  }\n  get control() {\n    return this.formDirective.getFormGroup(this);\n  }\n  get path() {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  _checkParentType() {}\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: AbstractFormGroupDirective,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: AbstractFormGroupDirective,\n    isStandalone: false,\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: AbstractFormGroupDirective,\n  decorators: [{\n    type: Directive,\n    args: [{\n      standalone: false\n    }]\n  }]\n});\n\nfunction modelParentException() {\n  return new _RuntimeError(1350, `\n    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n    formGroup's partner directive \"formControlName\" instead.  Example:\n\n    ${formControlNameExample}\n\n    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n    Example:\n\n    ${ngModelWithFormGroupExample}`);\n}\nfunction formGroupNameException() {\n  return new _RuntimeError(1351, `\n    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n    Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n    ${ngModelGroupExample}`);\n}\nfunction missingNameException() {\n  return new _RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form\n    control must be defined as 'standalone' in ngModelOptions.\n\n    Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n    Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">`);\n}\nfunction modelGroupParentException() {\n  return new _RuntimeError(1353, `\n    ngModelGroup cannot be used with a parent formGroup directive.\n\n    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n    ${ngModelGroupExample}`);\n}\n\nconst modelGroupProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => NgModelGroup)\n};\nclass NgModelGroup extends AbstractFormGroupDirective {\n  name = '';\n  constructor(parent, validators, asyncValidators) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  _checkParentType() {\n    if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw modelGroupParentException();\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgModelGroup,\n    deps: [{\n      token: ControlContainer,\n      host: true,\n      skipSelf: true\n    }, {\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgModelGroup,\n    isStandalone: false,\n    selector: \"[ngModelGroup]\",\n    inputs: {\n      name: [\"ngModelGroup\", \"name\"]\n    },\n    providers: [modelGroupProvider],\n    exportAs: [\"ngModelGroup\"],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgModelGroup,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[ngModelGroup]',\n      providers: [modelGroupProvider],\n      exportAs: 'ngModelGroup',\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }],\n  propDecorators: {\n    name: [{\n      type: Input,\n      args: ['ngModelGroup']\n    }]\n  }\n});\n\nconst formControlBinding$1 = {\n  provide: NgControl,\n  useExisting: forwardRef(() => NgModel)\n};\nconst resolvedPromise = (() => Promise.resolve())();\nclass NgModel extends NgControl {\n  _changeDetectorRef;\n  callSetDisabledState;\n  control = new FormControl();\n  static ngAcceptInputType_isDisabled;\n  _registered = false;\n  viewModel;\n  name = '';\n  isDisabled;\n  model;\n  options;\n  update = new EventEmitter();\n  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {\n    super();\n    this._changeDetectorRef = _changeDetectorRef;\n    this.callSetDisabledState = callSetDisabledState;\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n  ngOnChanges(changes) {\n    this._checkForErrors();\n    if (!this._registered || 'name' in changes) {\n      if (this._registered) {\n        this._checkName();\n        if (this.formDirective) {\n          const oldName = changes['name'].previousValue;\n          this.formDirective.removeControl({\n            name: oldName,\n            path: this._getPath(oldName)\n          });\n        }\n      }\n      this._setUpControl();\n    }\n    if ('isDisabled' in changes) {\n      this._updateDisabled(changes);\n    }\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      this._updateValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n  ngOnDestroy() {\n    this.formDirective && this.formDirective.removeControl(this);\n  }\n  get path() {\n    return this._getPath(this.name);\n  }\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  viewToModelUpdate(newValue) {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n  _setUpControl() {\n    this._setUpdateStrategy();\n    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);\n    this._registered = true;\n  }\n  _setUpdateStrategy() {\n    if (this.options && this.options.updateOn != null) {\n      this.control._updateOn = this.options.updateOn;\n    }\n  }\n  _isStandalone() {\n    return !this._parent || !!(this.options && this.options.standalone);\n  }\n  _setUpStandalone() {\n    setUpControl(this.control, this, this.callSetDisabledState);\n    this.control.updateValueAndValidity({\n      emitEvent: false\n    });\n  }\n  _checkForErrors() {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._isStandalone()) {\n      checkParentType$1(this._parent);\n    }\n    this._checkName();\n  }\n  _checkName() {\n    if (this.options && this.options.name) this.name = this.options.name;\n    if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw missingNameException();\n    }\n  }\n  _updateValue(value) {\n    resolvedPromise.then(() => {\n      this.control.setValue(value, {\n        emitViewToModelChange: false\n      });\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n  _updateDisabled(changes) {\n    const disabledValue = changes['isDisabled'].currentValue;\n    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);\n    resolvedPromise.then(() => {\n      if (isDisabled && !this.control.disabled) {\n        this.control.disable();\n      } else if (!isDisabled && this.control.disabled) {\n        this.control.enable();\n      }\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n  _getPath(controlName) {\n    return this._parent ? controlPath(controlName, this._parent) : [controlName];\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgModel,\n    deps: [{\n      token: ControlContainer,\n      host: true,\n      optional: true\n    }, {\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_VALUE_ACCESSOR,\n      optional: true,\n      self: true\n    }, {\n      token: ChangeDetectorRef,\n      optional: true\n    }, {\n      token: CALL_SET_DISABLED_STATE,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgModel,\n    isStandalone: false,\n    selector: \"[ngModel]:not([formControlName]):not([formControl])\",\n    inputs: {\n      name: \"name\",\n      isDisabled: [\"disabled\", \"isDisabled\"],\n      model: [\"ngModel\", \"model\"],\n      options: [\"ngModelOptions\", \"options\"]\n    },\n    outputs: {\n      update: \"ngModelChange\"\n    },\n    providers: [formControlBinding$1],\n    exportAs: [\"ngModel\"],\n    usesInheritance: true,\n    usesOnChanges: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgModel,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[ngModel]:not([formControlName]):not([formControl])',\n      providers: [formControlBinding$1],\n      exportAs: 'ngModel',\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: i0.ChangeDetectorRef,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ChangeDetectorRef]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }],\n  propDecorators: {\n    name: [{\n      type: Input\n    }],\n    isDisabled: [{\n      type: Input,\n      args: ['disabled']\n    }],\n    model: [{\n      type: Input,\n      args: ['ngModel']\n    }],\n    options: [{\n      type: Input,\n      args: ['ngModelOptions']\n    }],\n    update: [{\n      type: Output,\n      args: ['ngModelChange']\n    }]\n  }\n});\nfunction checkParentType$1(parent) {\n  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {\n    throw formGroupNameException();\n  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {\n    throw modelParentException();\n  }\n}\n\nclass NgNoValidate {\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgNoValidate,\n    deps: [],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgNoValidate,\n    isStandalone: false,\n    selector: \"form:not([ngNoForm]):not([ngNativeValidate])\",\n    host: {\n      attributes: {\n        \"novalidate\": \"\"\n      }\n    },\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgNoValidate,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'form:not([ngNoForm]):not([ngNativeValidate])',\n      host: {\n        'novalidate': ''\n      },\n      standalone: false\n    }]\n  }]\n});\n\nconst NUMBER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NumberValueAccessor),\n  multi: true\n};\nclass NumberValueAccessor extends BuiltInControlValueAccessor {\n  writeValue(value) {\n    const normalizedValue = value == null ? '' : value;\n    this.setProperty('value', normalizedValue);\n  }\n  registerOnChange(fn) {\n    this.onChange = value => {\n      fn(value == '' ? null : parseFloat(value));\n    };\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NumberValueAccessor,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NumberValueAccessor,\n    isStandalone: false,\n    selector: \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\",\n    host: {\n      listeners: {\n        \"input\": \"onChange($any($event.target).value)\",\n        \"blur\": \"onTouched()\"\n      }\n    },\n    providers: [NUMBER_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NumberValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',\n      host: {\n        '(input)': 'onChange($any($event.target).value)',\n        '(blur)': 'onTouched()'\n      },\n      providers: [NUMBER_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }]\n});\n\nconst RADIO_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RadioControlValueAccessor),\n  multi: true\n};\nfunction throwNameError() {\n  throw new _RuntimeError(1202, `\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    `);\n}\nclass RadioControlRegistry {\n  _accessors = [];\n  add(control, accessor) {\n    this._accessors.push([control, accessor]);\n  }\n  remove(accessor) {\n    for (let i = this._accessors.length - 1; i >= 0; --i) {\n      if (this._accessors[i][1] === accessor) {\n        this._accessors.splice(i, 1);\n        return;\n      }\n    }\n  }\n  select(accessor) {\n    this._accessors.forEach(c => {\n      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {\n        c[1].fireUncheck(accessor.value);\n      }\n    });\n  }\n  _isSameGroup(controlPair, accessor) {\n    if (!controlPair[0].control) return false;\n    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: RadioControlRegistry,\n    deps: [],\n    target: i0.FactoryTarget.Injectable\n  });\n  static prov = i0.ngDeclareInjectable({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: RadioControlRegistry,\n    providedIn: 'root'\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: RadioControlRegistry,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }]\n});\nclass RadioControlValueAccessor extends BuiltInControlValueAccessor {\n  _registry;\n  _injector;\n  _state;\n  _control;\n  _fn;\n  setDisabledStateFired = false;\n  onChange = () => {};\n  name;\n  formControlName;\n  value;\n  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {\n    optional: true\n  }) ?? setDisabledStateDefault;\n  constructor(renderer, elementRef, _registry, _injector) {\n    super(renderer, elementRef);\n    this._registry = _registry;\n    this._injector = _injector;\n  }\n  ngOnInit() {\n    this._control = this._injector.get(NgControl);\n    this._checkName();\n    this._registry.add(this._control, this);\n  }\n  ngOnDestroy() {\n    this._registry.remove(this);\n  }\n  writeValue(value) {\n    this._state = value === this.value;\n    this.setProperty('checked', this._state);\n  }\n  registerOnChange(fn) {\n    this._fn = fn;\n    this.onChange = () => {\n      fn(this.value);\n      this._registry.select(this);\n    };\n  }\n  setDisabledState(isDisabled) {\n    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === 'whenDisabledForLegacyCode') {\n      this.setProperty('disabled', isDisabled);\n    }\n    this.setDisabledStateFired = true;\n  }\n  fireUncheck(value) {\n    this.writeValue(value);\n  }\n  _checkName() {\n    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwNameError();\n    }\n    if (!this.name && this.formControlName) this.name = this.formControlName;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: RadioControlValueAccessor,\n    deps: [{\n      token: i0.Renderer2\n    }, {\n      token: i0.ElementRef\n    }, {\n      token: RadioControlRegistry\n    }, {\n      token: i0.Injector\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: RadioControlValueAccessor,\n    isStandalone: false,\n    selector: \"input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]\",\n    inputs: {\n      name: \"name\",\n      formControlName: \"formControlName\",\n      value: \"value\"\n    },\n    host: {\n      listeners: {\n        \"change\": \"onChange()\",\n        \"blur\": \"onTouched()\"\n      }\n    },\n    providers: [RADIO_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: RadioControlValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',\n      host: {\n        '(change)': 'onChange()',\n        '(blur)': 'onTouched()'\n      },\n      providers: [RADIO_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.Renderer2\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: RadioControlRegistry\n  }, {\n    type: i0.Injector\n  }],\n  propDecorators: {\n    name: [{\n      type: Input\n    }],\n    formControlName: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }]\n  }\n});\n\nconst RANGE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RangeValueAccessor),\n  multi: true\n};\nclass RangeValueAccessor extends BuiltInControlValueAccessor {\n  writeValue(value) {\n    this.setProperty('value', parseFloat(value));\n  }\n  registerOnChange(fn) {\n    this.onChange = value => {\n      fn(value == '' ? null : parseFloat(value));\n    };\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: RangeValueAccessor,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: RangeValueAccessor,\n    isStandalone: false,\n    selector: \"input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]\",\n    host: {\n      listeners: {\n        \"change\": \"onChange($any($event.target).value)\",\n        \"input\": \"onChange($any($event.target).value)\",\n        \"blur\": \"onTouched()\"\n      }\n    },\n    providers: [RANGE_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: RangeValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',\n      host: {\n        '(change)': 'onChange($any($event.target).value)',\n        '(input)': 'onChange($any($event.target).value)',\n        '(blur)': 'onTouched()'\n      },\n      providers: [RANGE_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }]\n});\n\nclass FormArray extends AbstractControl {\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: !!this.asyncValidator\n    });\n  }\n  controls;\n  at(index) {\n    return this.controls[this._adjustIndex(index)];\n  }\n  push(control, options = {}) {\n    if (Array.isArray(control)) {\n      control.forEach(ctrl => {\n        this.controls.push(ctrl);\n        this._registerControl(ctrl);\n      });\n    } else {\n      this.controls.push(control);\n      this._registerControl(control);\n    }\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  insert(index, control, options = {}) {\n    this.controls.splice(index, 0, control);\n    this._registerControl(control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  removeAt(index, options = {}) {\n    let adjustedIndex = this._adjustIndex(index);\n    if (adjustedIndex < 0) adjustedIndex = 0;\n    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {});\n    this.controls.splice(adjustedIndex, 1);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  setControl(index, control, options = {}) {\n    let adjustedIndex = this._adjustIndex(index);\n    if (adjustedIndex < 0) adjustedIndex = 0;\n    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {});\n    this.controls.splice(adjustedIndex, 1);\n    if (control) {\n      this.controls.splice(adjustedIndex, 0, control);\n      this._registerControl(control);\n    }\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  get length() {\n    return this.controls.length;\n  }\n  setValue(value, options = {}) {\n    assertAllValuesPresent(this, false, value);\n    value.forEach((newValue, index) => {\n      assertControlPresent(this, false, index);\n      this.at(index).setValue(newValue, {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  patchValue(value, options = {}) {\n    if (value == null) return;\n    value.forEach((newValue, index) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  reset(value = [], options = {}) {\n    this._forEachChild((control, index) => {\n      control.reset(value[index], {\n        ...options,\n        onlySelf: true\n      });\n    });\n    this._updatePristine(options, this);\n    this._updateTouched(options, this);\n    this.updateValueAndValidity(options);\n    if (options?.emitEvent !== false) {\n      this._events.next(new FormResetEvent(this));\n    }\n  }\n  getRawValue() {\n    return this.controls.map(control => control.getRawValue());\n  }\n  clear(options = {}) {\n    if (this.controls.length < 1) return;\n    this._forEachChild(control => control._registerOnCollectionChange(() => {}));\n    this.controls.splice(0);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  _adjustIndex(index) {\n    return index < 0 ? index + this.length : index;\n  }\n  _syncPendingControls() {\n    let subtreeUpdated = this.controls.reduce((updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({\n      onlySelf: true\n    });\n    return subtreeUpdated;\n  }\n  _forEachChild(cb) {\n    this.controls.forEach((control, index) => {\n      cb(control, index);\n    });\n  }\n  _updateValue() {\n    this.value = this.controls.filter(control => control.enabled || this.disabled).map(control => control.value);\n  }\n  _anyControls(condition) {\n    return this.controls.some(control => control.enabled && condition(control));\n  }\n  _setUpControls() {\n    this._forEachChild(control => this._registerControl(control));\n  }\n  _allControlsDisabled() {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n  _registerControl(control) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n  _find(name) {\n    return this.at(name) ?? null;\n  }\n}\nconst UntypedFormArray = FormArray;\nconst isFormArray = control => control instanceof FormArray;\n\nclass AbstractFormDirective extends ControlContainer {\n  callSetDisabledState;\n  get submitted() {\n    return untracked(this._submittedReactive);\n  }\n  set submitted(value) {\n    this._submittedReactive.set(value);\n  }\n  _submitted = computed(() => this._submittedReactive(), ...(ngDevMode ? [{\n    debugName: \"_submitted\"\n  }] : []));\n  _submittedReactive = signal(false, ...(ngDevMode ? [{\n    debugName: \"_submittedReactive\"\n  }] : []));\n  _oldForm;\n  _onCollectionChange = () => this._updateDomValue();\n  directives = [];\n  constructor(validators, asyncValidators, callSetDisabledState) {\n    super();\n    this.callSetDisabledState = callSetDisabledState;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  ngOnChanges(changes) {\n    this.onChanges(changes);\n  }\n  ngOnDestroy() {\n    this.onDestroy();\n  }\n  onChanges(changes) {\n    this._checkFormPresent();\n    if (changes.hasOwnProperty('form')) {\n      this._updateValidators();\n      this._updateDomValue();\n      this._updateRegistrations();\n      this._oldForm = this.form;\n    }\n  }\n  onDestroy() {\n    if (this.form) {\n      cleanUpValidators(this.form, this);\n      if (this.form._onCollectionChange === this._onCollectionChange) {\n        this.form._registerOnCollectionChange(() => {});\n      }\n    }\n  }\n  get formDirective() {\n    return this;\n  }\n  get path() {\n    return [];\n  }\n  addControl(dir) {\n    const ctrl = this.form.get(dir.path);\n    setUpControl(ctrl, dir, this.callSetDisabledState);\n    ctrl.updateValueAndValidity({\n      emitEvent: false\n    });\n    this.directives.push(dir);\n    return ctrl;\n  }\n  getControl(dir) {\n    return this.form.get(dir.path);\n  }\n  removeControl(dir) {\n    cleanUpControl(dir.control || null, dir, false);\n    removeListItem$1(this.directives, dir);\n  }\n  addFormGroup(dir) {\n    this._setUpFormContainer(dir);\n  }\n  removeFormGroup(dir) {\n    this._cleanUpFormContainer(dir);\n  }\n  getFormGroup(dir) {\n    return this.form.get(dir.path);\n  }\n  getFormArray(dir) {\n    return this.form.get(dir.path);\n  }\n  addFormArray(dir) {\n    this._setUpFormContainer(dir);\n  }\n  removeFormArray(dir) {\n    this._cleanUpFormContainer(dir);\n  }\n  updateModel(dir, value) {\n    const ctrl = this.form.get(dir.path);\n    ctrl.setValue(value);\n  }\n  onReset() {\n    this.resetForm();\n  }\n  resetForm(value = undefined, options = {}) {\n    this.form.reset(value, options);\n    this._submittedReactive.set(false);\n  }\n  onSubmit($event) {\n    this.submitted = true;\n    syncPendingControls(this.form, this.directives);\n    this.ngSubmit.emit($event);\n    this.form._events.next(new FormSubmittedEvent(this.control));\n    return $event?.target?.method === 'dialog';\n  }\n  _updateDomValue() {\n    this.directives.forEach(dir => {\n      const oldCtrl = dir.control;\n      const newCtrl = this.form.get(dir.path);\n      if (oldCtrl !== newCtrl) {\n        cleanUpControl(oldCtrl || null, dir);\n        if (isFormControl(newCtrl)) {\n          setUpControl(newCtrl, dir, this.callSetDisabledState);\n          dir.control = newCtrl;\n        }\n      }\n    });\n    this.form._updateTreeValidity({\n      emitEvent: false\n    });\n  }\n  _setUpFormContainer(dir) {\n    const ctrl = this.form.get(dir.path);\n    setUpFormContainer(ctrl, dir);\n    ctrl.updateValueAndValidity({\n      emitEvent: false\n    });\n  }\n  _cleanUpFormContainer(dir) {\n    if (this.form) {\n      const ctrl = this.form.get(dir.path);\n      if (ctrl) {\n        const isControlUpdated = cleanUpFormContainer(ctrl, dir);\n        if (isControlUpdated) {\n          ctrl.updateValueAndValidity({\n            emitEvent: false\n          });\n        }\n      }\n    }\n  }\n  _updateRegistrations() {\n    this.form._registerOnCollectionChange(this._onCollectionChange);\n    if (this._oldForm) {\n      this._oldForm._registerOnCollectionChange(() => {});\n    }\n  }\n  _updateValidators() {\n    setUpValidators(this.form, this);\n    if (this._oldForm) {\n      cleanUpValidators(this._oldForm, this);\n    }\n  }\n  _checkFormPresent() {\n    if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw missingFormException();\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: AbstractFormDirective,\n    deps: [{\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: CALL_SET_DISABLED_STATE,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: AbstractFormDirective,\n    isStandalone: true,\n    usesInheritance: true,\n    usesOnChanges: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: AbstractFormDirective,\n  decorators: [{\n    type: Directive\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }]\n});\n\nconst formDirectiveProvider$1 = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormArrayDirective)\n};\nclass FormArrayDirective extends AbstractFormDirective {\n  form = null;\n  ngSubmit = new EventEmitter();\n  get control() {\n    return this.form;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormArrayDirective,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: FormArrayDirective,\n    isStandalone: false,\n    selector: \"[formArray]\",\n    inputs: {\n      form: [\"formArray\", \"form\"]\n    },\n    outputs: {\n      ngSubmit: \"ngSubmit\"\n    },\n    host: {\n      listeners: {\n        \"submit\": \"onSubmit($event)\",\n        \"reset\": \"onReset()\"\n      }\n    },\n    providers: [formDirectiveProvider$1],\n    exportAs: [\"ngForm\"],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormArrayDirective,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formArray]',\n      providers: [formDirectiveProvider$1],\n      host: {\n        '(submit)': 'onSubmit($event)',\n        '(reset)': 'onReset()'\n      },\n      exportAs: 'ngForm',\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    form: [{\n      type: Input,\n      args: ['formArray']\n    }],\n    ngSubmit: [{\n      type: Output\n    }]\n  }\n});\n\nconst NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'NgModelWithFormControlWarning' : '');\nconst formControlBinding = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlDirective)\n};\nclass FormControlDirective extends NgControl {\n  _ngModelWarningConfig;\n  callSetDisabledState;\n  viewModel;\n  form;\n  set isDisabled(isDisabled) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.warn(disabledAttrWarning);\n    }\n  }\n  model;\n  update = new EventEmitter();\n  static _ngModelWarningSentOnce = false;\n  _ngModelWarningSent = false;\n  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {\n    super();\n    this._ngModelWarningConfig = _ngModelWarningConfig;\n    this.callSetDisabledState = callSetDisabledState;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n  ngOnChanges(changes) {\n    if (this._isControlChanged(changes)) {\n      const previousForm = changes['form'].previousValue;\n      if (previousForm) {\n        cleanUpControl(previousForm, this, false);\n      }\n      setUpControl(this.form, this, this.callSetDisabledState);\n      this.form.updateValueAndValidity({\n        emitEvent: false\n      });\n    }\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);\n      }\n      this.form.setValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpControl(this.form, this, false);\n    }\n  }\n  get path() {\n    return [];\n  }\n  get control() {\n    return this.form;\n  }\n  viewToModelUpdate(newValue) {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n  _isControlChanged(changes) {\n    return changes.hasOwnProperty('form');\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormControlDirective,\n    deps: [{\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_VALUE_ACCESSOR,\n      optional: true,\n      self: true\n    }, {\n      token: NG_MODEL_WITH_FORM_CONTROL_WARNING,\n      optional: true\n    }, {\n      token: CALL_SET_DISABLED_STATE,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: FormControlDirective,\n    isStandalone: false,\n    selector: \"[formControl]\",\n    inputs: {\n      form: [\"formControl\", \"form\"],\n      isDisabled: [\"disabled\", \"isDisabled\"],\n      model: [\"ngModel\", \"model\"]\n    },\n    outputs: {\n      update: \"ngModelChange\"\n    },\n    providers: [formControlBinding],\n    exportAs: [\"ngForm\"],\n    usesInheritance: true,\n    usesOnChanges: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormControlDirective,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formControl]',\n      providers: [formControlBinding],\n      exportAs: 'ngForm',\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }],\n  propDecorators: {\n    form: [{\n      type: Input,\n      args: ['formControl']\n    }],\n    isDisabled: [{\n      type: Input,\n      args: ['disabled']\n    }],\n    model: [{\n      type: Input,\n      args: ['ngModel']\n    }],\n    update: [{\n      type: Output,\n      args: ['ngModelChange']\n    }]\n  }\n});\n\nconst formGroupNameProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupName)\n};\nclass FormGroupName extends AbstractFormGroupDirective {\n  name = null;\n  constructor(parent, validators, asyncValidators) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  _checkParentType() {\n    if (hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw groupParentException();\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormGroupName,\n    deps: [{\n      token: ControlContainer,\n      host: true,\n      optional: true,\n      skipSelf: true\n    }, {\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: FormGroupName,\n    isStandalone: false,\n    selector: \"[formGroupName]\",\n    inputs: {\n      name: [\"formGroupName\", \"name\"]\n    },\n    providers: [formGroupNameProvider],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormGroupName,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formGroupName]',\n      providers: [formGroupNameProvider],\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }],\n  propDecorators: {\n    name: [{\n      type: Input,\n      args: ['formGroupName']\n    }]\n  }\n});\nconst formArrayNameProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormArrayName)\n};\nclass FormArrayName extends ControlContainer {\n  _parent;\n  name = null;\n  constructor(parent, validators, asyncValidators) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  ngOnInit() {\n    if (hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw arrayParentException();\n    }\n    this.formDirective.addFormArray(this);\n  }\n  ngOnDestroy() {\n    this.formDirective?.removeFormArray(this);\n  }\n  get control() {\n    return this.formDirective.getFormArray(this);\n  }\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  get path() {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormArrayName,\n    deps: [{\n      token: ControlContainer,\n      host: true,\n      optional: true,\n      skipSelf: true\n    }, {\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: FormArrayName,\n    isStandalone: false,\n    selector: \"[formArrayName]\",\n    inputs: {\n      name: [\"formArrayName\", \"name\"]\n    },\n    providers: [formArrayNameProvider],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormArrayName,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formArrayName]',\n      providers: [formArrayNameProvider],\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }],\n  propDecorators: {\n    name: [{\n      type: Input,\n      args: ['formArrayName']\n    }]\n  }\n});\nfunction hasInvalidParent(parent) {\n  return !(parent instanceof FormGroupName) && !(parent instanceof AbstractFormDirective) && !(parent instanceof FormArrayName);\n}\n\nconst controlNameBinding = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlName)\n};\nclass FormControlName extends NgControl {\n  _ngModelWarningConfig;\n  _added = false;\n  viewModel;\n  control;\n  name = null;\n  set isDisabled(isDisabled) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.warn(disabledAttrWarning);\n    }\n  }\n  model;\n  update = new EventEmitter();\n  static _ngModelWarningSentOnce = false;\n  _ngModelWarningSent = false;\n  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {\n    super();\n    this._ngModelWarningConfig = _ngModelWarningConfig;\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n  ngOnChanges(changes) {\n    if (!this._added) this._setUpControl();\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);\n      }\n      this.viewModel = this.model;\n      this.formDirective.updateModel(this, this.model);\n    }\n  }\n  ngOnDestroy() {\n    if (this.formDirective) {\n      this.formDirective.removeControl(this);\n    }\n  }\n  viewToModelUpdate(newValue) {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n  get path() {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  _setUpControl() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      checkParentType(this._parent, this.name);\n    }\n    this.control = this.formDirective.addControl(this);\n    this._added = true;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormControlName,\n    deps: [{\n      token: ControlContainer,\n      host: true,\n      optional: true,\n      skipSelf: true\n    }, {\n      token: NG_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_ASYNC_VALIDATORS,\n      optional: true,\n      self: true\n    }, {\n      token: NG_VALUE_ACCESSOR,\n      optional: true,\n      self: true\n    }, {\n      token: NG_MODEL_WITH_FORM_CONTROL_WARNING,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: FormControlName,\n    isStandalone: false,\n    selector: \"[formControlName]\",\n    inputs: {\n      name: [\"formControlName\", \"name\"],\n      isDisabled: [\"disabled\", \"isDisabled\"],\n      model: [\"ngModel\", \"model\"]\n    },\n    outputs: {\n      update: \"ngModelChange\"\n    },\n    providers: [controlNameBinding],\n    usesInheritance: true,\n    usesOnChanges: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormControlName,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formControlName]',\n      providers: [controlNameBinding],\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]\n    }]\n  }],\n  propDecorators: {\n    name: [{\n      type: Input,\n      args: ['formControlName']\n    }],\n    isDisabled: [{\n      type: Input,\n      args: ['disabled']\n    }],\n    model: [{\n      type: Input,\n      args: ['ngModel']\n    }],\n    update: [{\n      type: Output,\n      args: ['ngModelChange']\n    }]\n  }\n});\nfunction checkParentType(parent, name) {\n  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {\n    throw ngModelGroupException();\n  } else if (!(parent instanceof FormGroupName) && !(parent instanceof AbstractFormDirective) && !(parent instanceof FormArrayName)) {\n    throw controlParentException(name);\n  }\n}\n\nconst formDirectiveProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupDirective)\n};\nclass FormGroupDirective extends AbstractFormDirective {\n  form = null;\n  ngSubmit = new EventEmitter();\n  get control() {\n    return this.form;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormGroupDirective,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: FormGroupDirective,\n    isStandalone: false,\n    selector: \"[formGroup]\",\n    inputs: {\n      form: [\"formGroup\", \"form\"]\n    },\n    outputs: {\n      ngSubmit: \"ngSubmit\"\n    },\n    host: {\n      listeners: {\n        \"submit\": \"onSubmit($event)\",\n        \"reset\": \"onReset()\"\n      }\n    },\n    providers: [formDirectiveProvider],\n    exportAs: [\"ngForm\"],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormGroupDirective,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[formGroup]',\n      providers: [formDirectiveProvider],\n      host: {\n        '(submit)': 'onSubmit($event)',\n        '(reset)': 'onReset()'\n      },\n      exportAs: 'ngForm',\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    form: [{\n      type: Input,\n      args: ['formGroup']\n    }],\n    ngSubmit: [{\n      type: Output\n    }]\n  }\n});\n\nconst SELECT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectControlValueAccessor),\n  multi: true\n};\nfunction _buildValueString$1(id, value) {\n  if (id == null) return `${value}`;\n  if (value && typeof value === 'object') value = 'Object';\n  return `${id}: ${value}`.slice(0, 50);\n}\nfunction _extractId$1(valueString) {\n  return valueString.split(':')[0];\n}\nclass SelectControlValueAccessor extends BuiltInControlValueAccessor {\n  value;\n  _optionMap = new Map();\n  _idCounter = 0;\n  set compareWith(fn) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw new _RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n  _compareWith = Object.is;\n  appRefInjector = inject(ApplicationRef).injector;\n  destroyRef = inject(DestroyRef);\n  cdr = inject(ChangeDetectorRef);\n  _queuedWrite = false;\n  _writeValueAfterRender() {\n    if (this._queuedWrite || this.appRefInjector.destroyed) {\n      return;\n    }\n    this._queuedWrite = true;\n    afterNextRender({\n      write: () => {\n        if (this.destroyRef.destroyed) {\n          return;\n        }\n        this._queuedWrite = false;\n        this.writeValue(this.value);\n      }\n    }, {\n      injector: this.appRefInjector\n    });\n  }\n  writeValue(value) {\n    this.cdr.markForCheck();\n    this.value = value;\n    const id = this._getOptionId(value);\n    const valueString = _buildValueString$1(id, value);\n    this.setProperty('value', valueString);\n  }\n  registerOnChange(fn) {\n    this.onChange = valueString => {\n      this.value = this._getOptionValue(valueString);\n      fn(this.value);\n    };\n  }\n  _registerOption() {\n    return (this._idCounter++).toString();\n  }\n  _getOptionId(value) {\n    for (const id of this._optionMap.keys()) {\n      if (this._compareWith(this._optionMap.get(id), value)) return id;\n    }\n    return null;\n  }\n  _getOptionValue(valueString) {\n    const id = _extractId$1(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: SelectControlValueAccessor,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: SelectControlValueAccessor,\n    isStandalone: false,\n    selector: \"select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]\",\n    inputs: {\n      compareWith: \"compareWith\"\n    },\n    host: {\n      listeners: {\n        \"change\": \"onChange($any($event.target).value)\",\n        \"blur\": \"onTouched()\"\n      }\n    },\n    providers: [SELECT_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: SelectControlValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',\n      host: {\n        '(change)': 'onChange($any($event.target).value)',\n        '(blur)': 'onTouched()'\n      },\n      providers: [SELECT_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    compareWith: [{\n      type: Input\n    }]\n  }\n});\nclass NgSelectOption {\n  _element;\n  _renderer;\n  _select;\n  id;\n  constructor(_element, _renderer, _select) {\n    this._element = _element;\n    this._renderer = _renderer;\n    this._select = _select;\n    if (this._select) this.id = this._select._registerOption();\n  }\n  set ngValue(value) {\n    if (this._select == null) return;\n    this._select._optionMap.set(this.id, value);\n    this._setElementValue(_buildValueString$1(this.id, value));\n    this._select._writeValueAfterRender();\n  }\n  set value(value) {\n    this._setElementValue(value);\n    if (this._select) this._select._writeValueAfterRender();\n  }\n  _setElementValue(value) {\n    this._renderer.setProperty(this._element.nativeElement, 'value', value);\n  }\n  ngOnDestroy() {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select._writeValueAfterRender();\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgSelectOption,\n    deps: [{\n      token: i0.ElementRef\n    }, {\n      token: i0.Renderer2\n    }, {\n      token: SelectControlValueAccessor,\n      host: true,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgSelectOption,\n    isStandalone: false,\n    selector: \"option\",\n    inputs: {\n      ngValue: \"ngValue\",\n      value: \"value\"\n    },\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgSelectOption,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'option',\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.Renderer2\n  }, {\n    type: SelectControlValueAccessor,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }],\n  propDecorators: {\n    ngValue: [{\n      type: Input,\n      args: ['ngValue']\n    }],\n    value: [{\n      type: Input,\n      args: ['value']\n    }]\n  }\n});\n\nconst SELECT_MULTIPLE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),\n  multi: true\n};\nfunction _buildValueString(id, value) {\n  if (id == null) return `${value}`;\n  if (typeof value === 'string') value = `'${value}'`;\n  if (value && typeof value === 'object') value = 'Object';\n  return `${id}: ${value}`.slice(0, 50);\n}\nfunction _extractId(valueString) {\n  return valueString.split(':')[0];\n}\nclass SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {\n  value;\n  _optionMap = new Map();\n  _idCounter = 0;\n  set compareWith(fn) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw new _RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n  _compareWith = Object.is;\n  writeValue(value) {\n    this.value = value;\n    let optionSelectedStateSetter;\n    if (Array.isArray(value)) {\n      const ids = value.map(v => this._getOptionId(v));\n      optionSelectedStateSetter = (opt, o) => {\n        opt._setSelected(ids.indexOf(o.toString()) > -1);\n      };\n    } else {\n      optionSelectedStateSetter = (opt, o) => {\n        opt._setSelected(false);\n      };\n    }\n    this._optionMap.forEach(optionSelectedStateSetter);\n  }\n  registerOnChange(fn) {\n    this.onChange = element => {\n      const selected = [];\n      const selectedOptions = element.selectedOptions;\n      if (selectedOptions !== undefined) {\n        const options = selectedOptions;\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i];\n          const val = this._getOptionValue(opt.value);\n          selected.push(val);\n        }\n      } else {\n        const options = element.options;\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i];\n          if (opt.selected) {\n            const val = this._getOptionValue(opt.value);\n            selected.push(val);\n          }\n        }\n      }\n      this.value = selected;\n      fn(selected);\n    };\n  }\n  _registerOption(value) {\n    const id = (this._idCounter++).toString();\n    this._optionMap.set(id, value);\n    return id;\n  }\n  _getOptionId(value) {\n    for (const id of this._optionMap.keys()) {\n      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;\n    }\n    return null;\n  }\n  _getOptionValue(valueString) {\n    const id = _extractId(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: SelectMultipleControlValueAccessor,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: SelectMultipleControlValueAccessor,\n    isStandalone: false,\n    selector: \"select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]\",\n    inputs: {\n      compareWith: \"compareWith\"\n    },\n    host: {\n      listeners: {\n        \"change\": \"onChange($event.target)\",\n        \"blur\": \"onTouched()\"\n      }\n    },\n    providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: SelectMultipleControlValueAccessor,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',\n      host: {\n        '(change)': 'onChange($event.target)',\n        '(blur)': 'onTouched()'\n      },\n      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    compareWith: [{\n      type: Input\n    }]\n  }\n});\nclass NgSelectMultipleOption {\n  _element;\n  _renderer;\n  _select;\n  id;\n  _value;\n  constructor(_element, _renderer, _select) {\n    this._element = _element;\n    this._renderer = _renderer;\n    this._select = _select;\n    if (this._select) {\n      this.id = this._select._registerOption(this);\n    }\n  }\n  set ngValue(value) {\n    if (this._select == null) return;\n    this._value = value;\n    this._setElementValue(_buildValueString(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n  set value(value) {\n    if (this._select) {\n      this._value = value;\n      this._setElementValue(_buildValueString(this.id, value));\n      this._select.writeValue(this._select.value);\n    } else {\n      this._setElementValue(value);\n    }\n  }\n  _setElementValue(value) {\n    this._renderer.setProperty(this._element.nativeElement, 'value', value);\n  }\n  _setSelected(selected) {\n    this._renderer.setProperty(this._element.nativeElement, 'selected', selected);\n  }\n  ngOnDestroy() {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NgSelectMultipleOption,\n    deps: [{\n      token: i0.ElementRef\n    }, {\n      token: i0.Renderer2\n    }, {\n      token: SelectMultipleControlValueAccessor,\n      host: true,\n      optional: true\n    }],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: NgSelectMultipleOption,\n    isStandalone: false,\n    selector: \"option\",\n    inputs: {\n      ngValue: \"ngValue\",\n      value: \"value\"\n    },\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NgSelectMultipleOption,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'option',\n      standalone: false\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.Renderer2\n  }, {\n    type: SelectMultipleControlValueAccessor,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }],\n  propDecorators: {\n    ngValue: [{\n      type: Input,\n      args: ['ngValue']\n    }],\n    value: [{\n      type: Input,\n      args: ['value']\n    }]\n  }\n});\n\nfunction toInteger(value) {\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nfunction toFloat(value) {\n  return typeof value === 'number' ? value : parseFloat(value);\n}\nclass AbstractValidatorDirective {\n  _validator = nullValidator;\n  _onChange;\n  _enabled;\n  ngOnChanges(changes) {\n    if (this.inputName in changes) {\n      const input = this.normalizeInput(changes[this.inputName].currentValue);\n      this._enabled = this.enabled(input);\n      this._validator = this._enabled ? this.createValidator(input) : nullValidator;\n      if (this._onChange) {\n        this._onChange();\n      }\n    }\n  }\n  validate(control) {\n    return this._validator(control);\n  }\n  registerOnValidatorChange(fn) {\n    this._onChange = fn;\n  }\n  enabled(input) {\n    return input != null;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: AbstractValidatorDirective,\n    deps: [],\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: AbstractValidatorDirective,\n    isStandalone: true,\n    usesOnChanges: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: AbstractValidatorDirective,\n  decorators: [{\n    type: Directive\n  }]\n});\nconst MAX_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MaxValidator),\n  multi: true\n};\nclass MaxValidator extends AbstractValidatorDirective {\n  max;\n  inputName = 'max';\n  normalizeInput = input => toFloat(input);\n  createValidator = max => maxValidator(max);\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: MaxValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: MaxValidator,\n    isStandalone: false,\n    selector: \"input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]\",\n    inputs: {\n      max: \"max\"\n    },\n    host: {\n      properties: {\n        \"attr.max\": \"_enabled ? max : null\"\n      }\n    },\n    providers: [MAX_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: MaxValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]',\n      providers: [MAX_VALIDATOR],\n      host: {\n        '[attr.max]': '_enabled ? max : null'\n      },\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    max: [{\n      type: Input\n    }]\n  }\n});\nconst MIN_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MinValidator),\n  multi: true\n};\nclass MinValidator extends AbstractValidatorDirective {\n  min;\n  inputName = 'min';\n  normalizeInput = input => toFloat(input);\n  createValidator = min => minValidator(min);\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: MinValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: MinValidator,\n    isStandalone: false,\n    selector: \"input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]\",\n    inputs: {\n      min: \"min\"\n    },\n    host: {\n      properties: {\n        \"attr.min\": \"_enabled ? min : null\"\n      }\n    },\n    providers: [MIN_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: MinValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]',\n      providers: [MIN_VALIDATOR],\n      host: {\n        '[attr.min]': '_enabled ? min : null'\n      },\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    min: [{\n      type: Input\n    }]\n  }\n});\nconst REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => RequiredValidator),\n  multi: true\n};\nconst CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => CheckboxRequiredValidator),\n  multi: true\n};\nclass RequiredValidator extends AbstractValidatorDirective {\n  required;\n  inputName = 'required';\n  normalizeInput = booleanAttribute;\n  createValidator = input => requiredValidator;\n  enabled(input) {\n    return input;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: RequiredValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: RequiredValidator,\n    isStandalone: false,\n    selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\",\n    inputs: {\n      required: \"required\"\n    },\n    host: {\n      properties: {\n        \"attr.required\": \"_enabled ? \\\"\\\" : null\"\n      }\n    },\n    providers: [REQUIRED_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: RequiredValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',\n      providers: [REQUIRED_VALIDATOR],\n      host: {\n        '[attr.required]': '_enabled ? \"\" : null'\n      },\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    required: [{\n      type: Input\n    }]\n  }\n});\nclass CheckboxRequiredValidator extends RequiredValidator {\n  createValidator = input => requiredTrueValidator;\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: CheckboxRequiredValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: CheckboxRequiredValidator,\n    isStandalone: false,\n    selector: \"input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]\",\n    host: {\n      properties: {\n        \"attr.required\": \"_enabled ? \\\"\\\" : null\"\n      }\n    },\n    providers: [CHECKBOX_REQUIRED_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: CheckboxRequiredValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',\n      providers: [CHECKBOX_REQUIRED_VALIDATOR],\n      host: {\n        '[attr.required]': '_enabled ? \"\" : null'\n      },\n      standalone: false\n    }]\n  }]\n});\nconst EMAIL_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => EmailValidator),\n  multi: true\n};\nclass EmailValidator extends AbstractValidatorDirective {\n  email;\n  inputName = 'email';\n  normalizeInput = booleanAttribute;\n  createValidator = input => emailValidator;\n  enabled(input) {\n    return input;\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: EmailValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: EmailValidator,\n    isStandalone: false,\n    selector: \"[email][formControlName],[email][formControl],[email][ngModel]\",\n    inputs: {\n      email: \"email\"\n    },\n    providers: [EMAIL_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: EmailValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[email][formControlName],[email][formControl],[email][ngModel]',\n      providers: [EMAIL_VALIDATOR],\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    email: [{\n      type: Input\n    }]\n  }\n});\nconst MIN_LENGTH_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MinLengthValidator),\n  multi: true\n};\nclass MinLengthValidator extends AbstractValidatorDirective {\n  minlength;\n  inputName = 'minlength';\n  normalizeInput = input => toInteger(input);\n  createValidator = minlength => minLengthValidator(minlength);\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: MinLengthValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: MinLengthValidator,\n    isStandalone: false,\n    selector: \"[minlength][formControlName],[minlength][formControl],[minlength][ngModel]\",\n    inputs: {\n      minlength: \"minlength\"\n    },\n    host: {\n      properties: {\n        \"attr.minlength\": \"_enabled ? minlength : null\"\n      }\n    },\n    providers: [MIN_LENGTH_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: MinLengthValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',\n      providers: [MIN_LENGTH_VALIDATOR],\n      host: {\n        '[attr.minlength]': '_enabled ? minlength : null'\n      },\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    minlength: [{\n      type: Input\n    }]\n  }\n});\nconst MAX_LENGTH_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MaxLengthValidator),\n  multi: true\n};\nclass MaxLengthValidator extends AbstractValidatorDirective {\n  maxlength;\n  inputName = 'maxlength';\n  normalizeInput = input => toInteger(input);\n  createValidator = maxlength => maxLengthValidator(maxlength);\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: MaxLengthValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: MaxLengthValidator,\n    isStandalone: false,\n    selector: \"[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]\",\n    inputs: {\n      maxlength: \"maxlength\"\n    },\n    host: {\n      properties: {\n        \"attr.maxlength\": \"_enabled ? maxlength : null\"\n      }\n    },\n    providers: [MAX_LENGTH_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: MaxLengthValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',\n      providers: [MAX_LENGTH_VALIDATOR],\n      host: {\n        '[attr.maxlength]': '_enabled ? maxlength : null'\n      },\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    maxlength: [{\n      type: Input\n    }]\n  }\n});\nconst PATTERN_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => PatternValidator),\n  multi: true\n};\nclass PatternValidator extends AbstractValidatorDirective {\n  pattern;\n  inputName = 'pattern';\n  normalizeInput = input => input;\n  createValidator = input => patternValidator(input);\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: PatternValidator,\n    deps: null,\n    target: i0.FactoryTarget.Directive\n  });\n  static dir = i0.ngDeclareDirective({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    type: PatternValidator,\n    isStandalone: false,\n    selector: \"[pattern][formControlName],[pattern][formControl],[pattern][ngModel]\",\n    inputs: {\n      pattern: \"pattern\"\n    },\n    host: {\n      properties: {\n        \"attr.pattern\": \"_enabled ? pattern : null\"\n      }\n    },\n    providers: [PATTERN_VALIDATOR],\n    usesInheritance: true,\n    ngImport: i0\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: PatternValidator,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',\n      providers: [PATTERN_VALIDATOR],\n      host: {\n        '[attr.pattern]': '_enabled ? pattern : null'\n      },\n      standalone: false\n    }]\n  }],\n  propDecorators: {\n    pattern: [{\n      type: Input\n    }]\n  }\n});\n\nconst SHARED_FORM_DIRECTIVES = [NgNoValidate, NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];\nconst TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];\nconst REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName];\nclass InternalFormsSharedModule {\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: InternalFormsSharedModule,\n    deps: [],\n    target: i0.FactoryTarget.NgModule\n  });\n  static mod = i0.ngDeclareNgModule({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: InternalFormsSharedModule,\n    declarations: [NgNoValidate, NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],\n    exports: [NgNoValidate, NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]\n  });\n  static inj = i0.ngDeclareInjector({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: InternalFormsSharedModule\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: InternalFormsSharedModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      declarations: SHARED_FORM_DIRECTIVES,\n      exports: SHARED_FORM_DIRECTIVES\n    }]\n  }]\n});\n\nfunction isAbstractControlOptions(options) {\n  return !!options && (options.asyncValidators !== undefined || options.validators !== undefined || options.updateOn !== undefined);\n}\nclass FormBuilder {\n  useNonNullable = false;\n  get nonNullable() {\n    const nnfb = new FormBuilder();\n    nnfb.useNonNullable = true;\n    return nnfb;\n  }\n  group(controls, options = null) {\n    const reducedControls = this._reduceControls(controls);\n    let newOptions = {};\n    if (isAbstractControlOptions(options)) {\n      newOptions = options;\n    } else if (options !== null) {\n      newOptions.validators = options.validator;\n      newOptions.asyncValidators = options.asyncValidator;\n    }\n    return new FormGroup(reducedControls, newOptions);\n  }\n  record(controls, options = null) {\n    const reducedControls = this._reduceControls(controls);\n    return new FormRecord(reducedControls, options);\n  }\n  control(formState, validatorOrOpts, asyncValidator) {\n    let newOptions = {};\n    if (!this.useNonNullable) {\n      return new FormControl(formState, validatorOrOpts, asyncValidator);\n    }\n    if (isAbstractControlOptions(validatorOrOpts)) {\n      newOptions = validatorOrOpts;\n    } else {\n      newOptions.validators = validatorOrOpts;\n      newOptions.asyncValidators = asyncValidator;\n    }\n    return new FormControl(formState, {\n      ...newOptions,\n      nonNullable: true\n    });\n  }\n  array(controls, validatorOrOpts, asyncValidator) {\n    const createdControls = controls.map(c => this._createControl(c));\n    return new FormArray(createdControls, validatorOrOpts, asyncValidator);\n  }\n  _reduceControls(controls) {\n    const createdControls = {};\n    Object.keys(controls).forEach(controlName => {\n      createdControls[controlName] = this._createControl(controls[controlName]);\n    });\n    return createdControls;\n  }\n  _createControl(controls) {\n    if (controls instanceof FormControl) {\n      return controls;\n    } else if (controls instanceof AbstractControl) {\n      return controls;\n    } else if (Array.isArray(controls)) {\n      const value = controls[0];\n      const validator = controls.length > 1 ? controls[1] : null;\n      const asyncValidator = controls.length > 2 ? controls[2] : null;\n      return this.control(value, validator, asyncValidator);\n    } else {\n      return this.control(controls);\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormBuilder,\n    deps: [],\n    target: i0.FactoryTarget.Injectable\n  });\n  static prov = i0.ngDeclareInjectable({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormBuilder,\n    providedIn: 'root'\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormBuilder,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }]\n});\nclass NonNullableFormBuilder {\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NonNullableFormBuilder,\n    deps: [],\n    target: i0.FactoryTarget.Injectable\n  });\n  static prov = i0.ngDeclareInjectable({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: NonNullableFormBuilder,\n    providedIn: 'root',\n    useFactory: () => inject(FormBuilder).nonNullable\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: NonNullableFormBuilder,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => inject(FormBuilder).nonNullable\n    }]\n  }]\n});\nclass UntypedFormBuilder extends FormBuilder {\n  group(controlsConfig, options = null) {\n    return super.group(controlsConfig, options);\n  }\n  control(formState, validatorOrOpts, asyncValidator) {\n    return super.control(formState, validatorOrOpts, asyncValidator);\n  }\n  array(controlsConfig, validatorOrOpts, asyncValidator) {\n    return super.array(controlsConfig, validatorOrOpts, asyncValidator);\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: UntypedFormBuilder,\n    deps: null,\n    target: i0.FactoryTarget.Injectable\n  });\n  static prov = i0.ngDeclareInjectable({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: UntypedFormBuilder,\n    providedIn: 'root'\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: UntypedFormBuilder,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }]\n});\n\nconst VERSION = /* @__PURE__ */new Version('21.0.6');\n\nclass FormsModule {\n  static withConfig(opts) {\n    return {\n      ngModule: FormsModule,\n      providers: [{\n        provide: CALL_SET_DISABLED_STATE,\n        useValue: opts.callSetDisabledState ?? setDisabledStateDefault\n      }]\n    };\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormsModule,\n    deps: [],\n    target: i0.FactoryTarget.NgModule\n  });\n  static mod = i0.ngDeclareNgModule({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormsModule,\n    declarations: [NgModel, NgModelGroup, NgForm],\n    exports: [InternalFormsSharedModule, NgModel, NgModelGroup, NgForm]\n  });\n  static inj = i0.ngDeclareInjector({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: FormsModule,\n    imports: [InternalFormsSharedModule]\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: FormsModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      declarations: TEMPLATE_DRIVEN_DIRECTIVES,\n      exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]\n    }]\n  }]\n});\nclass ReactiveFormsModule {\n  static withConfig(opts) {\n    return {\n      ngModule: ReactiveFormsModule,\n      providers: [{\n        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,\n        useValue: opts.warnOnNgModelWithFormControl ?? 'always'\n      }, {\n        provide: CALL_SET_DISABLED_STATE,\n        useValue: opts.callSetDisabledState ?? setDisabledStateDefault\n      }]\n    };\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: ReactiveFormsModule,\n    deps: [],\n    target: i0.FactoryTarget.NgModule\n  });\n  static mod = i0.ngDeclareNgModule({\n    minVersion: \"14.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: ReactiveFormsModule,\n    declarations: [FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName],\n    exports: [InternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName]\n  });\n  static inj = i0.ngDeclareInjector({\n    minVersion: \"12.0.0\",\n    version: \"21.0.6\",\n    ngImport: i0,\n    type: ReactiveFormsModule,\n    imports: [InternalFormsSharedModule]\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.6\",\n  ngImport: i0,\n  type: ReactiveFormsModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      declarations: [REACTIVE_DRIVEN_DIRECTIVES],\n      exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]\n    }]\n  }]\n});\n\nexport { AbstractControl, AbstractControlDirective, AbstractFormDirective, AbstractFormGroupDirective, COMPOSITION_BUFFER_MODE, CheckboxControlValueAccessor, CheckboxRequiredValidator, ControlContainer, ControlEvent, DefaultValueAccessor, EmailValidator, FormArray, FormArrayDirective, FormArrayName, FormBuilder, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormGroupName, FormRecord, FormResetEvent, FormSubmittedEvent, FormsModule, MaxLengthValidator, MaxValidator, MinLengthValidator, MinValidator, NG_ASYNC_VALIDATORS, NG_VALIDATORS, NG_VALUE_ACCESSOR, NgControl, NgControlStatus, NgControlStatusGroup, NgForm, NgModel, NgModelGroup, NgSelectOption, NonNullableFormBuilder, NumberValueAccessor, PatternValidator, PristineChangeEvent, RadioControlValueAccessor, RangeValueAccessor, ReactiveFormsModule, RequiredValidator, SelectControlValueAccessor, SelectMultipleControlValueAccessor, StatusChangeEvent, TouchedChangeEvent, UntypedFormArray, UntypedFormBuilder, UntypedFormControl, UntypedFormGroup, VERSION, Validators, ValueChangeEvent, isFormArray, isFormControl, isFormGroup, isFormRecord, InternalFormsSharedModule, NgNoValidate, NgSelectMultipleOption };\n","import { BidiModule } from '@angular/cdk/bidi';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, DOCUMENT, ElementRef, ErrorHandler, HostAttributeToken, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, NgModule } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { MatIconRegistry } from './_icon-registry-chunk.mjs';\nexport { getMatIconFailedToSanitizeLiteralError, getMatIconFailedToSanitizeUrlError, getMatIconNameNotFoundError, getMatIconNoHttpProviderError } from './_icon-registry-chunk.mjs';\nimport '@angular/cdk/private';\nimport '@angular/common/http';\nimport '@angular/platform-browser';\n\nconst MAT_ICON_DEFAULT_OPTIONS = new InjectionToken('MAT_ICON_DEFAULT_OPTIONS');\nconst MAT_ICON_LOCATION = new InjectionToken('mat-icon-location', {\n  providedIn: 'root',\n  factory: () => {\n    const _document = inject(DOCUMENT);\n    const _location = _document ? _document.location : null;\n    return {\n      getPathname: () => _location ? _location.pathname + _location.search : ''\n    };\n  }\n});\nconst funcIriAttributes = ['clip-path', 'color-profile', 'src', 'cursor', 'fill', 'filter', 'marker', 'marker-start', 'marker-mid', 'marker-end', 'mask', 'stroke'];\nconst funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(', ');\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\nclass MatIcon {\n  _elementRef = inject(ElementRef);\n  _iconRegistry = inject(MatIconRegistry);\n  _location = inject(MAT_ICON_LOCATION);\n  _errorHandler = inject(ErrorHandler);\n  _defaultColor;\n  get color() {\n    return this._color || this._defaultColor;\n  }\n  set color(value) {\n    this._color = value;\n  }\n  _color;\n  inline = false;\n  get svgIcon() {\n    return this._svgIcon;\n  }\n  set svgIcon(value) {\n    if (value !== this._svgIcon) {\n      if (value) {\n        this._updateSvgIcon(value);\n      } else if (this._svgIcon) {\n        this._clearSvgElement();\n      }\n      this._svgIcon = value;\n    }\n  }\n  _svgIcon;\n  get fontSet() {\n    return this._fontSet;\n  }\n  set fontSet(value) {\n    const newValue = this._cleanupFontValue(value);\n    if (newValue !== this._fontSet) {\n      this._fontSet = newValue;\n      this._updateFontIconClasses();\n    }\n  }\n  _fontSet;\n  get fontIcon() {\n    return this._fontIcon;\n  }\n  set fontIcon(value) {\n    const newValue = this._cleanupFontValue(value);\n    if (newValue !== this._fontIcon) {\n      this._fontIcon = newValue;\n      this._updateFontIconClasses();\n    }\n  }\n  _fontIcon;\n  _previousFontSetClass = [];\n  _previousFontIconClass;\n  _svgName;\n  _svgNamespace;\n  _previousPath;\n  _elementsWithExternalReferences;\n  _currentIconFetch = Subscription.EMPTY;\n  constructor() {\n    const ariaHidden = inject(new HostAttributeToken('aria-hidden'), {\n      optional: true\n    });\n    const defaults = inject(MAT_ICON_DEFAULT_OPTIONS, {\n      optional: true\n    });\n    if (defaults) {\n      if (defaults.color) {\n        this.color = this._defaultColor = defaults.color;\n      }\n      if (defaults.fontSet) {\n        this.fontSet = defaults.fontSet;\n      }\n    }\n    if (!ariaHidden) {\n      this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n    }\n  }\n  _splitIconName(iconName) {\n    if (!iconName) {\n      return ['', ''];\n    }\n    const parts = iconName.split(':');\n    switch (parts.length) {\n      case 1:\n        return ['', parts[0]];\n      case 2:\n        return parts;\n      default:\n        throw Error(`Invalid icon name: \"${iconName}\"`);\n    }\n  }\n  ngOnInit() {\n    this._updateFontIconClasses();\n  }\n  ngAfterViewChecked() {\n    const cachedElements = this._elementsWithExternalReferences;\n    if (cachedElements && cachedElements.size) {\n      const newPath = this._location.getPathname();\n      if (newPath !== this._previousPath) {\n        this._previousPath = newPath;\n        this._prependPathToReferences(newPath);\n      }\n    }\n  }\n  ngOnDestroy() {\n    this._currentIconFetch.unsubscribe();\n    if (this._elementsWithExternalReferences) {\n      this._elementsWithExternalReferences.clear();\n    }\n  }\n  _usingFontIcon() {\n    return !this.svgIcon;\n  }\n  _setSvgElement(svg) {\n    this._clearSvgElement();\n    const path = this._location.getPathname();\n    this._previousPath = path;\n    this._cacheChildrenWithExternalReferences(svg);\n    this._prependPathToReferences(path);\n    this._elementRef.nativeElement.appendChild(svg);\n  }\n  _clearSvgElement() {\n    const layoutElement = this._elementRef.nativeElement;\n    let childCount = layoutElement.childNodes.length;\n    if (this._elementsWithExternalReferences) {\n      this._elementsWithExternalReferences.clear();\n    }\n    while (childCount--) {\n      const child = layoutElement.childNodes[childCount];\n      if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n        child.remove();\n      }\n    }\n  }\n  _updateFontIconClasses() {\n    if (!this._usingFontIcon()) {\n      return;\n    }\n    const elem = this._elementRef.nativeElement;\n    const fontSetClasses = (this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/) : this._iconRegistry.getDefaultFontSetClass()).filter(className => className.length > 0);\n    this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n    fontSetClasses.forEach(className => elem.classList.add(className));\n    this._previousFontSetClass = fontSetClasses;\n    if (this.fontIcon !== this._previousFontIconClass && !fontSetClasses.includes('mat-ligature-font')) {\n      if (this._previousFontIconClass) {\n        elem.classList.remove(this._previousFontIconClass);\n      }\n      if (this.fontIcon) {\n        elem.classList.add(this.fontIcon);\n      }\n      this._previousFontIconClass = this.fontIcon;\n    }\n  }\n  _cleanupFontValue(value) {\n    return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n  }\n  _prependPathToReferences(path) {\n    const elements = this._elementsWithExternalReferences;\n    if (elements) {\n      elements.forEach((attrs, element) => {\n        attrs.forEach(attr => {\n          element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n        });\n      });\n    }\n  }\n  _cacheChildrenWithExternalReferences(element) {\n    const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n    const elements = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map();\n    for (let i = 0; i < elementsWithFuncIri.length; i++) {\n      funcIriAttributes.forEach(attr => {\n        const elementWithReference = elementsWithFuncIri[i];\n        const value = elementWithReference.getAttribute(attr);\n        const match = value ? value.match(funcIriPattern) : null;\n        if (match) {\n          let attributes = elements.get(elementWithReference);\n          if (!attributes) {\n            attributes = [];\n            elements.set(elementWithReference, attributes);\n          }\n          attributes.push({\n            name: attr,\n            value: match[1]\n          });\n        }\n      });\n    }\n  }\n  _updateSvgIcon(rawName) {\n    this._svgNamespace = null;\n    this._svgName = null;\n    this._currentIconFetch.unsubscribe();\n    if (rawName) {\n      const [namespace, iconName] = this._splitIconName(rawName);\n      if (namespace) {\n        this._svgNamespace = namespace;\n      }\n      if (iconName) {\n        this._svgName = iconName;\n      }\n      this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(iconName, namespace).pipe(take(1)).subscribe(svg => this._setSvgElement(svg), err => {\n        const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n        this._errorHandler.handleError(new Error(errorMessage));\n      });\n    }\n  }\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.3\",\n    ngImport: i0,\n    type: MatIcon,\n    deps: [],\n    target: i0.FactoryTarget.Component\n  });\n  static cmp = i0.ngDeclareComponent({\n    minVersion: \"16.1.0\",\n    version: \"21.0.3\",\n    type: MatIcon,\n    isStandalone: true,\n    selector: \"mat-icon\",\n    inputs: {\n      color: \"color\",\n      inline: [\"inline\", \"inline\", booleanAttribute],\n      svgIcon: \"svgIcon\",\n      fontSet: \"fontSet\",\n      fontIcon: \"fontIcon\"\n    },\n    host: {\n      attributes: {\n        \"role\": \"img\"\n      },\n      properties: {\n        \"class\": \"color ? \\\"mat-\\\" + color : \\\"\\\"\",\n        \"attr.data-mat-icon-type\": \"_usingFontIcon() ? \\\"font\\\" : \\\"svg\\\"\",\n        \"attr.data-mat-icon-name\": \"_svgName || fontIcon\",\n        \"attr.data-mat-icon-namespace\": \"_svgNamespace || fontSet\",\n        \"attr.fontIcon\": \"_usingFontIcon() ? fontIcon : null\",\n        \"class.mat-icon-inline\": \"inline\",\n        \"class.mat-icon-no-color\": \"color !== \\\"primary\\\" && color !== \\\"accent\\\" && color !== \\\"warn\\\"\"\n      },\n      classAttribute: \"mat-icon notranslate\"\n    },\n    exportAs: [\"matIcon\"],\n    ngImport: i0,\n    template: '<ng-content></ng-content>',\n    isInline: true,\n    styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"],\n    changeDetection: i0.ChangeDetectionStrategy.OnPush,\n    encapsulation: i0.ViewEncapsulation.None\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.3\",\n  ngImport: i0,\n  type: MatIcon,\n  decorators: [{\n    type: Component,\n    args: [{\n      template: '<ng-content></ng-content>',\n      selector: 'mat-icon',\n      exportAs: 'matIcon',\n      host: {\n        'role': 'img',\n        'class': 'mat-icon notranslate',\n        '[class]': 'color ? \"mat-\" + color : \"\"',\n        '[attr.data-mat-icon-type]': '_usingFontIcon() ? \"font\" : \"svg\"',\n        '[attr.data-mat-icon-name]': '_svgName || fontIcon',\n        '[attr.data-mat-icon-namespace]': '_svgNamespace || fontSet',\n        '[attr.fontIcon]': '_usingFontIcon() ? fontIcon : null',\n        '[class.mat-icon-inline]': 'inline',\n        '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"'\n      },\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"]\n    }]\n  }],\n  ctorParameters: () => [],\n  propDecorators: {\n    color: [{\n      type: Input\n    }],\n    inline: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    svgIcon: [{\n      type: Input\n    }],\n    fontSet: [{\n      type: Input\n    }],\n    fontIcon: [{\n      type: Input\n    }]\n  }\n});\n\nclass MatIconModule {\n  static fac = i0.ngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.0.3\",\n    ngImport: i0,\n    type: MatIconModule,\n    deps: [],\n    target: i0.FactoryTarget.NgModule\n  });\n  static mod = i0.ngDeclareNgModule({\n    minVersion: \"14.0.0\",\n    version: \"21.0.3\",\n    ngImport: i0,\n    type: MatIconModule,\n    imports: [MatIcon],\n    exports: [MatIcon, BidiModule]\n  });\n  static inj = i0.ngDeclareInjector({\n    minVersion: \"12.0.0\",\n    version: \"21.0.3\",\n    ngImport: i0,\n    type: MatIconModule,\n    imports: [BidiModule]\n  });\n}\ni0.ngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.0.3\",\n  ngImport: i0,\n  type: MatIconModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      imports: [MatIcon],\n      exports: [MatIcon, BidiModule]\n    }]\n  }]\n});\n\nexport { MAT_ICON_DEFAULT_OPTIONS, MAT_ICON_LOCATION, MatIcon, MatIconModule, MatIconRegistry };\n"],"x_google_ignoreList":[0,1]}