{"version":3,"file":"default-projects_eav-ui_src_app_features_shared_base-feature_component_ts.f44b79ceaff1d48f.js","mappings":"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","names":["AppDialogConfigService","constructor","contextSvcShared","context","this","log","EavLogger","getCurrent$","appId","a","getShared$","static","t","i0","i1","i2","_angular_core__WEBPACK_IMPORTED_MODULE_3__","jDH","factory","Éµfac","GlobalDialogConfigService","http","globalConfigService","dialogSettings$","svcId","getDialogSettings","pipe","shareReplay","refCount","reqBy","get","params","toString","map","dlgSettings","Context","Language","List","filter","language","IsEnabled","tap","allowDebug","Enable","DebugMode","i3","_angular_core__WEBPACK_IMPORTED_MODULE_6__","providedIn","FeaturesService","ServiceBase","super","dialogContextSignal","signal","dialogContext$","toObservable","dialogConfigSvc","transient","subscribe","ds","load","dialogContext","set","getAll","computed","Features","equal","RxHelpers","arraysEqual","get$","featureNameId","dc","find","f","nameId","getSignal","objectsEqual","isEnabled$","isEnabled","SignalHelpers","boolEquals","_angular_core__WEBPACK_IMPORTED_MODULE_4__","FeatureDetailService","dnnContext","getFeatureDetails","$2sxc","apiUrl","webApiRoot","core","id_r3","_r2","ctx_r3","copyToClipboard","FeatureInfoDialogComponent_Conditional_0_Conditional_15_Template","feature_r5","_r1","findOutMore","link","closeDialog","name","description","tmp_6_0","FeatureInfoDialogComponent","dialogData","dialogRef","snackBar","featureDetailService","ngOnInit","viewModel$","text","open","duration","window","close","MAT_DIALOG_DATA","VBU","selectors","standalone","features","decls","vars","consts","template","rf","ctx","FeatureInfoDialogComponent_Conditional_0_Template","tmp_0_0","MatCardModule","MatButtonModule","i4","MatIconModule","i5","AsyncPipe","TranslateModule","i6","TippyDirective","SafeHtmlPipe","FeatureComponentBase","value","featureNameId$","next","showIf","showIf$","BehaviorSubject","dialog","inject","MatDialog","viewContainerRef","ViewContainerRef","changeDetectorRef","ChangeDetectorRef","featuresService","feature$","switchMap","featName","show$","combineLatest","feat","openDialog","openFeatureDialog","FsC","inputs","featureId","autoFocus","data","width","markForCheck","valueEquals","numberEquals","stringEquals","objectEquals","isEqual","refEquals","x","y","manyEquals","typeOfX","Array","isArray","obj1","obj2","keys1","Object","keys","keys2","length","every","key1","hasOwnProperty","item","index","distinct","array","indexOf","GlobalConfigService","debugState","isDebug","allowDebugMode","debugEnabled","debugEnabled$","initial","id","sessionStorage","getItem","keyDebug","allow","oldConfig","newConfig","toggleDebugEnabled","_angular_core__WEBPACK_IMPORTED_MODULE_1__","source","options","injector","assertInInjectionContext","Injector","subject","ReplaySubject","watcher","effect","err","untracked","error","manualCleanup","DestroyRef","onDestroy","destroy","complete","asObservable","toSignal","requiresCleanup","cleanupRef","state","requireSync","kind","initialValue","sub","rejectErrors","unsubscribe","bind","current","ÉµRuntimeError"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./projects/eav-ui/src/app/app-administration/services/app-dialog-config.service.ts","./projects/eav-ui/src/app/app-administration/services/global-dialog-config.service.ts","./projects/eav-ui/src/app/features/features.service.ts","./projects/eav-ui/src/app/features/services/feature-detail.service.ts","./projects/eav-ui/src/app/features/feature-info-dialog/feature-info-dialog.component.html","./projects/eav-ui/src/app/features/feature-info-dialog/feature-info-dialog.component.ts","./projects/eav-ui/src/app/features/shared/base-feature.component.ts","./projects/eav-ui/src/app/shared/helpers/signal.helpers.ts","./projects/eav-ui/src/app/shared/rxJs/rx.helpers.ts","./projects/eav-ui/src/app/shared/services/global-config.service.ts","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { DialogSettings } from '../../shared/models/dialog-settings.model';\r\nimport { Context } from '../../shared/services/context';\r\nimport { EavLogger } from '../../shared/logging/eav-logger';\r\nimport { GlobalDialogConfigService } from './global-dialog-config.service';\r\n\r\nconst logThis = false;\r\nconst nameOfThis = 'DialogConfigService';\r\n\r\n/**\r\n * Context aware dialog configuration service.\r\n * \r\n * It uses the shared service so the settings are cached when re-requested by anything else.\r\n */\r\n@Injectable()\r\nexport class AppDialogConfigService {\r\n\r\n  log = new EavLogger(nameOfThis, logThis);\r\n\r\n  constructor(private contextSvcShared: GlobalDialogConfigService, private context: Context) {\r\n  }\r\n\r\n  getCurrent$(): Observable<DialogSettings> {\r\n    const appId = this.context.appId;\r\n    this.log.a(`getCurrent\\$ - appId:${appId}`);\r\n    return this.contextSvcShared.getShared$(appId);\r\n  }\r\n}\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { map, Observable, shareReplay, tap } from 'rxjs';\r\nimport { DialogSettings } from '../../shared/models/dialog-settings.model';\r\nimport { Context } from '../../shared/services/context';\r\nimport { EavLogger } from '../../shared/logging/eav-logger';\r\nimport { GlobalConfigService } from '../../shared/services/global-config.service';\r\n\r\nconst logThis = false;\r\nconst nameOfThis = 'GlobalDialogConfigService';\r\n\r\nconst webApiSettings = 'admin/dialog/settings';\r\n\r\n/**\r\n * Service for getting dialog settings for the current app.\r\n * \r\n * Note that it should normally be shared, to save resources / network calls.\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class GlobalDialogConfigService {\r\n\r\n  log = new EavLogger(nameOfThis, logThis);\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    private context: Context,\r\n    private globalConfigService: GlobalConfigService,\r\n  ) {\r\n    this.log.a(`using context #${this.context.log.svcId}`);\r\n  }\r\n\r\n  private dialogSettings$: Record<number, Observable<DialogSettings>> = {};\r\n\r\n  getShared$(appId: number): Observable<DialogSettings> {\r\n    this.log.a('getShared$ appId: ' + appId);\r\n    this.dialogSettings$[appId] ??= this.getDialogSettings(appId, 'getShared$')\r\n      .pipe(shareReplay({ refCount: false }));\r\n    return this.dialogSettings$[appId];\r\n  }\r\n\r\n  private getDialogSettings(appId?: number, reqBy?: string): Observable<DialogSettings> {\r\n    this.log.a('getDialogSettings', {appId, reqBy});\r\n    return this.http.get<DialogSettings>(webApiSettings, {\r\n      params: { appId: appId ?? this.context.appId.toString() },\r\n    }).pipe(\r\n      map(dlgSettings => {\r\n        dlgSettings.Context.Language.List = dlgSettings.Context.Language.List.filter(language => language.IsEnabled);\r\n        return dlgSettings;\r\n      }),\r\n      tap(dlgSettings => {\r\n        this.globalConfigService.allowDebug(dlgSettings.Context.Enable.DebugMode);\r\n      }),\r\n    );\r\n  }\r\n}\r\n","import { Injectable, Signal, computed, signal } from '@angular/core';\r\nimport { map, Observable, ReplaySubject } from 'rxjs';\r\nimport { GlobalDialogConfigService } from '../app-administration/services';\r\nimport { DialogContext } from '../shared/models/dialog-settings.model';\r\nimport { ServiceBase } from '../shared/services/service-base';\r\nimport { EavLogger } from '../shared/logging/eav-logger';\r\nimport { FeatureSummary } from './models/feature-summary.model';\r\nimport { SignalHelpers } from '../shared/helpers/signal.helpers';\r\nimport { RxHelpers } from '../shared/rxJs/rx.helpers';\r\nimport { toObservable } from '@angular/core/rxjs-interop';\r\nimport { AppDialogConfigService } from '../app-administration/services/app-dialog-config.service';\r\nimport { transient } from '../core';\r\n\r\nconst logThis = false;\r\n\r\n// TODO: @2dg - try to refactor the observables away so it only provides signals\r\n\r\n/**\r\n * Singleton Service to provide information about enabled/disabled features.\r\n *\r\n * It currently has a strange architecture, since it's singleton,\r\n * but needs context data.\r\n * So the GlobalDialogConfigService seems to call the loadFromService.\r\n * TODO: 2dm: I don't like this, should rethink the architecture, feels a bit flaky.\r\n * 2024-08-28 2dm modified this, but still not perfect. \r\n * ATM it would still load the dialog-settings by itself, even if the form service would provide it. on .load(...)\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class FeaturesService extends ServiceBase {\r\n  // new 2dm WIP\r\n  // Provide context information and ensure that previously added data is always available\r\n  private dialogContextSignal = signal<DialogContext>(null);\r\n  private dialogContext$ = toObservable(this.dialogContextSignal);\r\n\r\n  private dialogConfigSvc = transient(AppDialogConfigService);\r\n\r\n  constructor() {\r\n    super(new EavLogger('FeaturesService', logThis));\r\n\r\n    this.dialogConfigSvc.getCurrent$().subscribe(ds => this.load(ds.Context));\r\n  }\r\n\r\n  // loadFromService(configService: GlobalDialogConfigService) {\r\n  //   configService.getCurrent$().subscribe(ds => this.load(ds.Context));\r\n  // }\r\n\r\n  load(dialogContext: DialogContext) {\r\n    this.dialogContextSignal.set(dialogContext);\r\n  }\r\n\r\n  getAll(): Signal<FeatureSummary[]> {\r\n    return computed(\r\n      () => this.dialogContextSignal()?.Features ?? [],\r\n      { equal: RxHelpers.arraysEqual }\r\n    );\r\n  }\r\n\r\n  // TODO: @2dm - only used once, should be able to remove in ca. 20 mins\r\n  get$(featureNameId: string): Observable<FeatureSummary> {\r\n    return this.dialogContext$.pipe(\r\n      map(dc => dc?.Features.find(f => f.nameId === featureNameId))\r\n    );\r\n  }\r\n\r\n  getSignal(featureNameId: string): Signal<FeatureSummary> {\r\n    return computed(\r\n      () => this.dialogContextSignal()?.Features.find(f => f.nameId === featureNameId),\r\n      { equal: RxHelpers.objectsEqual }\r\n    );\r\n  }\r\n\r\n  isEnabled$(nameId: string): Observable<boolean> {\r\n    return this.get$(nameId).pipe(map(f => f?.isEnabled ?? false));\r\n  }\r\n\r\n  isEnabled(nameId: string): Signal<boolean> {\r\n    return computed(\r\n      () => this.dialogContextSignal()?.Features.find(f => f.nameId === nameId)?.isEnabled ?? false,\r\n      SignalHelpers.boolEquals\r\n    );\r\n  }\r\n}\r\n","import { Context as DnnContext } from '@2sic.com/sxc-angular';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { Feature } from '../models';\r\n\r\nexport const webApiRoot = \"admin/feature/\";\r\n\r\n@Injectable()\r\nexport class FeatureDetailService {\r\n  constructor(\r\n    private http: HttpClient,\r\n    private dnnContext: DnnContext\r\n  ) { }\r\n\r\n  getFeatureDetails(featureNameId: string): Observable<Feature> {\r\n    return this.http.get<Feature>(this.dnnContext.$2sxc.http.apiUrl(webApiRoot + 'details'), {\r\n      params: { nameId: featureNameId }\r\n    });\r\n  }\r\n}\r\n","@if (viewModel$ | async; as feature) {\r\n  <mat-card>\r\n    <mat-card-header>\r\n      <mat-card-title>{{ feature.name }}</mat-card-title>\r\n    </mat-card-header>\r\n    <mat-card-content>\r\n      <p [innerHtml]=\"feature.description | safeHtml\"></p>\r\n      <div class=\"eav-info-row\">\r\n        <div class=\"eav-info-row__label\">{{ \"Features.Status\" | translate }}:</div>\r\n        <div class=\"eav-info-row__value\">\r\n          <span>{{ (feature.isEnabled ? \"Features.Active\" : \"Features.NotActive\") | translate }}</span>\r\n        </div>\r\n      </div>\r\n      @if (feature.nameId; as id) {\r\n        <div class=\"eav-info-row\">\r\n          <div class=\"eav-info-row__label\">ID:</div>\r\n          <div class=\"eav-info-row__value eav_click\">\r\n            <span [tippy]=\"id\" (click)=\"copyToClipboard(id)\">{{ id }}</span>\r\n          </div>\r\n        </div>\r\n      }\r\n    </mat-card-content>\r\n    <mat-card-actions align=\"end\">\r\n      <button mat-raised-button color=\"accent\"\r\n        class=\"eav-card-action-button\" (click)=\"findOutMore(feature.link)\">\r\n        <mat-icon>open_in_new</mat-icon>\r\n        {{ \"Features.FindOutMore\" | translate }}\r\n      </button>\r\n      <button mat-raised-button class=\"eav-card-action-button\" (click)=\"closeDialog()\">\r\n        {{ \"Features.Close\" | translate }}\r\n      </button>\r\n    </mat-card-actions>\r\n  </mat-card>\r\n}","import { Component, Inject, OnInit } from '@angular/core';\r\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\r\nimport { MatSnackBar } from '@angular/material/snack-bar';\r\nimport { Observable } from 'rxjs';\r\nimport { copyToClipboard } from '../../shared/helpers/copy-to-clipboard.helper';\r\nimport { Feature } from '../models';\r\nimport { FeatureDetailService } from '../services/feature-detail.service';\r\nimport { TranslateModule } from '@ngx-translate/core';\r\nimport { AsyncPipe } from '@angular/common';\r\nimport { MatIconModule } from '@angular/material/icon';\r\nimport { MatButtonModule } from '@angular/material/button';\r\nimport { MatCardModule } from '@angular/material/card';\r\nimport { TippyDirective } from '../../shared/directives/tippy.directive';\r\nimport { SafeHtmlPipe } from '../../shared/pipes/safe-html.pipe';\r\nimport { transient } from '../../core';\r\n\r\n@Component({\r\n  selector: 'app-feature-info-dialog',\r\n  templateUrl: './feature-info-dialog.component.html',\r\n  styleUrls: ['./feature-info-dialog.component.scss'],\r\n  standalone: true,\r\n  imports: [\r\n    MatCardModule,\r\n    MatButtonModule,\r\n    MatIconModule,\r\n    AsyncPipe,\r\n    TranslateModule,\r\n    TippyDirective,\r\n    SafeHtmlPipe,\r\n  ]\r\n})\r\nexport class FeatureInfoDialogComponent implements OnInit {\r\n  viewModel$: Observable<Feature>;\r\n\r\n  private featureDetailService = transient(FeatureDetailService);\r\n\r\n  constructor(\r\n    @Inject(MAT_DIALOG_DATA) public dialogData: string,\r\n    private dialogRef: MatDialogRef<FeatureInfoDialogComponent>,\r\n    private snackBar: MatSnackBar,\r\n  ) { }\r\n\r\n  ngOnInit(): void {\r\n    this.viewModel$ = this.featureDetailService.getFeatureDetails(this.dialogData);\r\n  }\r\n\r\n  copyToClipboard(text: string): void {\r\n    copyToClipboard(text);\r\n    this.snackBar.open('Copied to clipboard', null, { duration: 2000 });\r\n  }\r\n\r\n  findOutMore(link: string): void {\r\n    window.open(link, '_blank');\r\n  }\r\n\r\n  closeDialog(): void {\r\n    this.dialogRef.close();\r\n  }\r\n}\r\n","import { ChangeDetectorRef, Directive, Input, ViewContainerRef, inject } from '@angular/core';\r\nimport { MatDialog } from '@angular/material/dialog';\r\nimport { FeaturesService } from '../features.service';\r\nimport { FeatureInfoDialogComponent } from '../feature-info-dialog/feature-info-dialog.component';\r\nimport { BehaviorSubject, switchMap, Observable, map, combineLatest } from 'rxjs';\r\nimport { FeatureSummary } from '../models';\r\n\r\n@Directive()\r\nexport class FeatureComponentBase {\r\n  /** Feature NameId to check */\r\n  @Input()\r\n  public set featureNameId(value: string) { this.featureNameId$.next(value); }\r\n  protected featureNameId$ = new BehaviorSubject<string>(null);\r\n\r\n  /** By default, it will show if it's false - here we can change it to show if true */\r\n  @Input()\r\n  public set showIf(value: boolean) { this.showIf$.next(value == true); }\r\n  protected showIf$ = new BehaviorSubject<boolean>(false);\r\n\r\n  // TODO: @SDV - MAKE REACTIVE - SEE text-info-component example\r\n  // featureOn: boolean = true;\r\n  feature$: Observable<FeatureSummary>;\r\n  show$: Observable<boolean>;\r\n\r\n  private dialog = inject(MatDialog);\r\n  private viewContainerRef = inject(ViewContainerRef);\r\n  private changeDetectorRef = inject(ChangeDetectorRef);\r\n  protected featuresService = inject(FeaturesService);\r\n\r\n  constructor() {\r\n    this.feature$ = this.featureNameId$.pipe(\r\n      switchMap(featName => this.featuresService.get$(featName)\r\n      ));\r\n    this.show$ = combineLatest([this.feature$, this.showIf$]).pipe(\r\n      // tap(data => console.log('2dm - show$', data)),\r\n      map(([feat, showIf]) => showIf == (feat?.isEnabled ?? false))\r\n    );\r\n  }\r\n\r\n  openDialog() {\r\n    openFeatureDialog(this.dialog, this.featureNameId$.value, this.viewContainerRef, this.changeDetectorRef);\r\n  }\r\n}\r\n\r\n\r\nexport function openFeatureDialog(dialog: MatDialog, featureId: string, viewContainerRef: ViewContainerRef, changeDetectorRef: ChangeDetectorRef) {\r\n  dialog.open(FeatureInfoDialogComponent, {\r\n    autoFocus: false,\r\n    data: featureId,\r\n    viewContainerRef: viewContainerRef,\r\n    width: '400px',\r\n  });\r\n\r\n  changeDetectorRef.markForCheck();\r\n}\r\n","import { CreateComputedOptions } from '@angular/core';\r\nimport { RxHelpers } from '../rxJs/rx.helpers';\r\nimport isEqual from 'lodash-es/isEqual';\r\n\r\nexport class SignalHelpers {\r\n  /** Options for number signal to ensure equality only on value difference */\r\n  static boolEquals: CreateComputedOptions<boolean> = {\r\n    equal: RxHelpers.valueEquals<boolean>\r\n  };\r\n\r\n  /** Options for string signal to ensure equality only on value difference */\r\n  static numberEquals: CreateComputedOptions<number> = {\r\n    equal: RxHelpers.valueEquals<number>\r\n  };\r\n\r\n  /** Options for string signal to ensure equality only on value difference */\r\n  static stringEquals: CreateComputedOptions<string> = {\r\n    equal: RxHelpers.valueEquals<string>\r\n  };\r\n\r\n  // note: this doesn't work as expected; leaving in so nobody tries to repeat this\r\n  // /** Options for string signal to ensure equality only on value difference */\r\n  // static valueEquals: CreateComputedOptions<boolean | string | number> = {\r\n  //   equal: RxHelpers.valueEquals<boolean | string | number>\r\n  // };\r\n\r\n  /** Options for object signal to ensure equality only on value difference */\r\n  static objectEquals = { equal: isEqual };\r\n\r\n  /**\r\n   * Helper to _not_ set the equal and use the standard equal.\r\n   * This is just to ensure that the code can explicitly show that RefEquals was expected,\r\n   * and not an oversight.\r\n   */\r\n  static refEquals = {  };\r\n}\r\n\r\n// export class SignalEquals<T>: CreateComputedOptions<T> {\r\n//   equal: RxHelpers.objectsEqual<T>;\r\n// }\r\n","import isEqual from 'lodash-es/isEqual';\r\n\r\nexport class RxHelpers {\r\n\r\n  static boolEquals(x: boolean, y: boolean): boolean {\r\n    return x === y;\r\n  }\r\n\r\n  static stringEquals(x: string, y: string): boolean {\r\n    return x === y;\r\n  }\r\n\r\n  static valueEquals<T>(x: T, y: T): boolean {\r\n    return x === y;\r\n  }\r\n\r\n  static manyEquals<T>(x: T, y: T): boolean {\r\n    if (x == null || y == null) return x === y;\r\n    const typeOfX = typeof x;\r\n    if (typeOfX !== typeof y) return false;\r\n    if (typeOfX === 'string' || typeOfX === 'number' || typeOfX === 'boolean')\r\n      return x === y;\r\n\r\n    if (Array.isArray(x)) return RxHelpers.arraysEqual(x, y as []);\r\n\r\n    return RxHelpers.objectsEqual(x, y);\r\n  }\r\n\r\n  static objectsEqual<T>(x: T, y: T): boolean {\r\n    if (x == null || y == null) return x === y;\r\n\r\n    const obj1 = x as Record<string, any>;\r\n    const obj2 = y as Record<string, any>;\r\n\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    if (keys1.length !== keys2.length) return false;\r\n\r\n    const equal = keys1.every(key1 => {\r\n      if (!obj2.hasOwnProperty(key1)) return false;\r\n\r\n      return obj1[key1] === obj2[key1];\r\n    });\r\n\r\n    return equal;\r\n  }\r\n\r\n  static arraysEqual<T>(x: T[], y: T[]): boolean {\r\n    if (x == null || y == null) return x === y;\r\n\r\n    if (x.length !== y.length) return false;\r\n\r\n    const equal = x.every((item, index) => {\r\n      return x[index] === y[index];\r\n    });\r\n\r\n    return equal;\r\n  }\r\n\r\n  /** used as .filter(distinct), filters array to only have distinct values */\r\n  static distinct<T>(value: T, index: number, array: T[]): boolean {\r\n    return array.indexOf(value) === index;\r\n  }\r\n\r\n}\r\n","import { Injectable, computed, signal } from '@angular/core';\r\nimport { MatSnackBar } from '@angular/material/snack-bar';\r\nimport { toObservable } from '@angular/core/rxjs-interop';\r\nimport { keyDebug } from '../constants/session.constants';\r\n\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class GlobalConfigService {\r\n\r\n  private debugState = signal<GlobalConfig>(null);\r\n\r\n  isDebug = computed(() => !!this.debugState()?.allowDebugMode && !!this.debugState()?.debugEnabled);\r\n\r\n  /** This observable is a left-over, try to remove once more is refactored */\r\n  debugEnabled$ = toObservable(this.isDebug);\r\n\r\n  constructor(private snackBar: MatSnackBar) {\r\n    const initial: GlobalConfig = {\r\n      id: 0,\r\n      debugEnabled: sessionStorage.getItem(keyDebug) === 'true',\r\n      allowDebugMode: false,\r\n    };\r\n    this.debugState.set(initial);\r\n  }\r\n\r\n  allowDebug(allow: boolean): void {\r\n    const oldConfig = this.debugState();\r\n    if (oldConfig.allowDebugMode === allow)\r\n      return;\r\n\r\n    const newConfig: GlobalConfig = {\r\n      ...oldConfig,\r\n      allowDebugMode: allow,\r\n    };\r\n    this.debugState.set(newConfig);\r\n  }\r\n\r\n  toggleDebugEnabled(): void {\r\n    const oldConfig = this.debugState();\r\n    if (!oldConfig.allowDebugMode) {\r\n      this.snackBar.open('You do not have permissions to enter developer mode', null, { duration: 3000 });\r\n      return;\r\n    }\r\n\r\n    const newConfig: GlobalConfig = {\r\n      ...oldConfig,\r\n      debugEnabled: !oldConfig.debugEnabled,\r\n    };\r\n    this.debugState.set(newConfig);\r\n    this.snackBar.open(newConfig.debugEnabled ? 'developer mode on' : 'developer mode off', null, { duration: 3000 });\r\n  }\r\n}\r\n\r\ninterface GlobalConfig {\r\n  id: 0;\r\n  debugEnabled: boolean;\r\n  allowDebugMode: boolean;\r\n}\r\n","/**\n * @license Angular v17.3.11\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ÉµRuntimeError, ÉµgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    constructor(source) {\n        this.source = source;\n        this.destroyed = false;\n        this.destroyRef = inject(DestroyRef);\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new ÉµRuntimeError(953 /* ÉµRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: value => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n    const destroyRef = ÉµgetOutputDestroyRef(ref);\n    return new Observable(observer => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe(v => observer.next(v));\n        return () => subscription.unsubscribe();\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new ÉµRuntimeError(601 /* ÉµRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new ÉµRuntimeError(601 /* ÉµRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n"],"x_google_ignoreList":[10]}