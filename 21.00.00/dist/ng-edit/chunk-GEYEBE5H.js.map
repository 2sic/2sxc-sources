{
  "version": 3,
  "sources": ["projects/eav-ui/src/app/edit/edit-dialog.config.ts", "projects/eav-ui/src/app/edit/routing/edit-route-matchers.ts", "projects/eav-ui/src/app/edit/edit.routing.ts"],
  "sourcesContent": ["import { Injector } from '@angular/core';\r\nimport { FeaturesDisableAutoLoadService } from '../features/features-disable-autoload.service';\r\nimport { DialogConfig } from '../shared/models/dialog-config.model';\r\n\r\n/**\r\n * Contains size definition and component reference for the edit dialog.\r\n */\r\nexport const editDialog: DialogConfig = {\r\n  name: 'ITEMS_EDIT_DIALOG',\r\n  initContext: true,\r\n  panelSize: 'custom',\r\n  panelClass: ['c-multi-item-dialog'],\r\n\r\n  /**\r\n   * Very special behavior - we need to be sure that the features-service does NOT auto-load the dialog-settings.\r\n   * This is because the edit dialog may be opened by a user who doesn't have the necessary permissions.\r\n   * @param injector \r\n   * @returns \r\n   */\r\n  async getComponent(injector: Injector) {\r\n    injector.get(FeaturesDisableAutoLoadService).disableAutoLoad = true\r\n\r\n    const { EditEntryComponent } = await import('./dialog/entry/edit-entry');\r\n    return EditEntryComponent;\r\n  }\r\n};\r\n", "import { UrlMatchResult, UrlSegment } from '@angular/router';\r\nimport { classLog } from '../../shared/logging';\r\nimport { EditUrlParams } from './edit-url-params.model';\r\n\r\nconst logSpecs = {\r\n  all: true,\r\n  hasGuidAndId: false,\r\n  editRouteMatcherRoot: false,\r\n  editRouteMatcherRootRefresh: false,\r\n  editRouteMatcherSubEdit: false,\r\n  editRouteMatcherSubEditRefresh: false,\r\n};\r\n\r\nconst logger = classLog('EditRouteMatchers', logSpecs);\r\n\r\n/**\r\n * Matches:\r\n * - ':zoneId/:appId/edit/:items'\r\n * - ':zoneId/:appId/edit/:items/details/:detailsEntityGuid/:detailsFieldId'\r\n * - ':zoneId/:appId/edit/:items/update/:updateEntityGuid/:updateFieldId'\r\n */\r\nexport function matchEditRoot(url: UrlSegment[]): UrlMatchResult {\r\n  return editRouteMatcherRoot(url, 2, 4, 1);\r\n  // const l = logger.fnIf('editRouteMatcherRoot', { url });\r\n  // const specs = checkRelevantAndIds(url, 2, 4);\r\n  // if (specs == null) return l.rNull();\r\n  // const match: UrlMatchResult = {\r\n  //   consumed: url.slice(0, specs.hasPurpose ? 7 : 4),\r\n  //   posParams: {\r\n  //     zoneId: url[0],\r\n  //     appId: url[1],\r\n  //     items: url[3],\r\n  //     ...specs.identities,\r\n  //   } satisfies EditUrlParams<UrlSegment>,\r\n  // };\r\n  // return l.r(match, '✅');\r\n}\r\n\r\n/**\r\n * Matches:\r\n * - ':zoneId/v2/:mid/:cbid/:appId/edit/:items'\r\n * - ':zoneId/v2/:mid/:cbid/:appId/edit/:items/details/:detailsEntityGuid/:detailsFieldId'\r\n * - ':zoneId/v2/:mid/:cbid/:appId/edit/:items/update/:updateEntityGuid/:updateFieldId'\r\n */\r\nexport function matchEditRootV2(url: UrlSegment[]): UrlMatchResult {\r\n  return editRouteMatcherRoot(url, 5, 7, 4);\r\n  // const l = logger.fnIf('editRouteMatcherRoot', { url });\r\n  // const specs = checkRelevantAndIds(url, 5, 7);\r\n  // if (specs == null) return l.rNull();\r\n  // // debugger;\r\n  // const match: UrlMatchResult = {\r\n  //   consumed: url.slice(0, specs.hasPurpose ? 10 : 7),\r\n  //   posParams: {\r\n  //     zoneId: url[0],\r\n  //     appId: url[4],\r\n  //     items: url[6],\r\n  //     ...specs.identities,\r\n  //   } satisfies EditUrlParams<UrlSegment>,\r\n  // };\r\n  // return l.r(match, '✅');\r\n}\r\n\r\nfunction editRouteMatcherRoot(url: UrlSegment[], posEdit: number, posPurpose: number, posAppId: number): UrlMatchResult {\r\n  const l = logger.fnIf('editRouteMatcherRoot', { url });\r\n  const specs = checkRelevantAndIds(url, posEdit, posPurpose);\r\n  if (specs == null) return l.rNull();\r\n  const match: UrlMatchResult = {\r\n    consumed: url.slice(0, posPurpose + (specs.hasPurpose ? 3 : 0)),\r\n    posParams: {\r\n      zoneId: url[0],\r\n      appId: url[posAppId],\r\n      items: url[posAppId + 2],\r\n      ...specs.identities,\r\n    } satisfies EditUrlParams<UrlSegment>,\r\n  };\r\n  return l.r(match, '✅');\r\n}\r\n\r\n\r\n/**\r\n * Matches:\r\n * - 'edit/:items'\r\n * - 'edit/:items/details/:detailsEntityGuid/:detailsFieldId'\r\n * - 'edit/:items/update/:updateEntityGuid/:updateFieldId'\r\n */\r\nexport function matchEditSub(url: UrlSegment[]): UrlMatchResult {\r\n  const l = logger.fnIf('editRouteMatcherSubEdit', { url });\r\n  const specs = checkRelevantAndIds(url, 0, 2);\r\n  if (specs == null) return l.rNull();\r\n  const match: UrlMatchResult = {\r\n    consumed: url.slice(0, specs.hasPurpose ? 5 : 2),\r\n    posParams: {\r\n      items: url[1],\r\n      ...specs.identities,\r\n    } satisfies EditUrlParams<UrlSegment>,\r\n  };\r\n  return l.r(match, '✅');\r\n}\r\n\r\n/**\r\n * Determine if we're in an edit route, and if we have details/update data.\r\n * If we have it, the returned spread is a bit different for each use case as the parameter names differ.\r\n */\r\nfunction checkRelevantAndIds(url: UrlSegment[], posEdit: number, posPurpose: number) {\r\n  const l = logger.fnIf('hasGuidAndId', { url, posPurpose });\r\n  if (url.length < posPurpose) return l.rNull();\r\n  if (url[posEdit].path !== 'edit') return l.rNull();\r\n  const purpose = url[posPurpose]?.path;\r\n  if (purpose == null) return l.r({ hasPurpose: false, identities: {} });\r\n  const guid = url[posPurpose + 1];\r\n  const id = url[posPurpose + 2];\r\n  const hasGuidAndId = guid != null && id != null;\r\n  const hasDetails = purpose === 'details' && hasGuidAndId;\r\n  const hasUpdate = purpose === 'update' && hasGuidAndId;\r\n  const identities = {\r\n    ...(hasDetails && { detailsEntityGuid: guid, detailsFieldId: id }),\r\n    ...(hasUpdate && { updateEntityGuid: guid, updateFieldId: id }),\r\n  }\r\n  return l.r({ hasPurpose: hasDetails || hasUpdate, identities });\r\n}\r\n\r\n\r\n/** \r\n * Matches 'edit/refresh/:items'\r\n */\r\nexport function matchEditSubRefresh(url: UrlSegment[]): UrlMatchResult {\r\n  const l = logger.fnIf('editRouteMatcherSubEditRefresh', { url });\r\n  if (url.length < 3) return l.rNull();\r\n  if (url[0].path !== 'edit' || url[1].path !== 'refresh') return l.rNull();\r\n  const match: UrlMatchResult = {\r\n    consumed: url.slice(0, 3),\r\n    posParams: {\r\n      items: url[2],\r\n    } satisfies EditUrlParams<UrlSegment>,\r\n  };\r\n  return l.r(match, '✅');\r\n}\r\n\r\n/** \r\n * Matches ':zoneId/:appId/edit/refresh/:items'\r\n */\r\nexport function matchEditRootRefresh(url: UrlSegment[]): UrlMatchResult {\r\n  return editRouteMatcherRootRefresh(url, 5, 2, 1);\r\n  // const l = logger.fnIf('editRouteMatcherRootRefresh', { url });\r\n  // if (url.length < 5) return l.rNull();\r\n  // if (url[2].path !== 'edit' || url[3].path !== 'refresh') return l.rNull();\r\n  // const match: UrlMatchResult = {\r\n  //   consumed: url.slice(0, 5),\r\n  //   posParams: {\r\n  //     zoneId: url[0],\r\n  //     appId: url[1],\r\n  //     items: url[4],\r\n  //   } satisfies EditUrlParams<UrlSegment>,\r\n  // };\r\n  // return l.r(match, '✅');\r\n}\r\n\r\n/** \r\n * Matches ':zoneId/v2/:mid/:cbid/:appId/edit/refresh/:items'\r\n */\r\nexport function matchEditRootRefreshV2(url: UrlSegment[]): UrlMatchResult {\r\n  return editRouteMatcherRootRefresh(url, 8, 5, 4);\r\n  // const l = logger.fnIf('editRouteMatcherRootRefresh', { url });\r\n  // if (url.length < 8) return l.rNull();\r\n  // if (url[5].path !== 'edit' || url[6].path !== 'refresh') return l.rNull();\r\n  // const match: UrlMatchResult = {\r\n  //   consumed: url.slice(0, 8),\r\n  //   posParams: {\r\n  //     zoneId: url[0],\r\n  //     appId: url[4],\r\n  //     items: url[7],\r\n  //   } satisfies EditUrlParams<UrlSegment>,\r\n  // };\r\n  // return l.r(match, '✅');\r\n}\r\n\r\nfunction editRouteMatcherRootRefresh(url: UrlSegment[], segments: number, posEdit: number, posAppId: number): UrlMatchResult {\r\n  const l = logger.fnIf('editRouteMatcherRootRefresh', { url });\r\n  if (url.length < segments) return l.rNull();\r\n  if (url[posEdit].path !== 'edit' || url[posEdit + 1].path !== 'refresh') return l.rNull();\r\n  const match: UrlMatchResult = {\r\n    consumed: url.slice(0, segments),\r\n    posParams: {\r\n      zoneId: url[0],\r\n      appId: url[posAppId],\r\n      items: url[posAppId + 3],\r\n    } satisfies EditUrlParams<UrlSegment>,\r\n  };\r\n  return l.r(match, '✅');\r\n}", "import { Routes } from '@angular/router';\r\nimport { classLog } from '../shared/logging';\r\nimport { editDialog } from './edit-dialog.config';\r\nimport { matchEditRoot, matchEditRootRefresh, matchEditRootRefreshV2, matchEditRootV2, matchEditSub, matchEditSubRefresh } from './routing/edit-route-matchers';\r\n\r\nconst log = classLog('Routes');\r\n\r\n/**\r\n * Routes which open an empty component which then reloads the entity to ensure a full refresh.\r\n * This is used on the history dialog, to ensure the restored data is fully reloaded.\r\n */\r\nconst reloadRoutes: Routes = [\r\n  {\r\n    path: '',\r\n    loadComponent: () => import('./routing/edit-reload').then(m => m.EditReloadComponent),\r\n    data: { title: 'Reloading Edit Dialog' }\r\n  },\r\n];\r\n\r\n\r\n/**\r\n * The main routes for the Edit Dialog.\r\n * It must always be attached to a /edit/:items route.\r\n * It will\r\n * 1. load the EntryComponent\r\n * 2. watch routes for sub-items.\r\n * 3. enable the history mechanism.\r\n */\r\nconst editRoutesDialogAndChildren: Routes = [\r\n  {\r\n    path: '',\r\n    loadComponent: () => import('../shared/components/dialog-entry/dialog-entry').then(m => m.DialogEntryComponent),\r\n    data: { dialog: editDialog },\r\n    loadChildren: () => [\r\n      ...EditRoutes,\r\n      {\r\n        path: 'versions/:itemId',\r\n        loadChildren: () => import('../item-history/item-history.routing').then(m => m.historyRoutes),\r\n      }\r\n    ],\r\n  },\r\n];\r\n\r\n/**\r\n * Routes for the Edit Dialog.\r\n * It will handle /edit/:items routes and also /edit/refresh/ routes.\r\n */\r\nexport const EditRoutes: Routes = [\r\n  {\r\n    matcher: matchEditSub,\r\n    loadChildren: () => {\r\n      // Recursively use these routes again.\r\n      log.a('loadChildren - matcher: sub-edit');\r\n      return editRoutesDialogAndChildren;\r\n    },\r\n  },\r\n  {\r\n    matcher: matchEditSubRefresh,\r\n    children: reloadRoutes,\r\n  },\r\n];\r\n\r\n/**\r\n * In some cases the history could cause trouble, eg. in VisualQuery, where there are many hidden fields which\r\n * build the query, and if someone goes back in time thinking they are just changing the labels, the query would break.\r\n * \r\n * So this is a route without the history-restore/refresh mechanism.\r\n */\r\nexport const EditRoutesNoHistory: Routes = [\r\n  {\r\n    matcher: matchEditSub,\r\n    loadChildren: () => editRoutesDialogAndChildren,\r\n    data: { history: false }, // disable history in the edit dialog\r\n  },\r\n];\r\n\r\n\r\n/**\r\n * Root routes only meant for the entry points of the application, \"App\" and \"Apps\"\r\n */\r\nexport const EditRoutesRoot: Routes = [\r\n  // { // Old\r\n  //   matcher: matchEditRoot,\r\n  //   loadChildren: () => editRoutesDialogAndChildren,\r\n  // },\r\n  { // New\r\n    matcher: matchEditRootV2,\r\n    loadChildren: () => editRoutesDialogAndChildren,\r\n  },\r\n  // { // Old\r\n  //   matcher: matchEditRootRefresh,\r\n  //   children: reloadRoutes,\r\n  // },\r\n  { // New\r\n    matcher: matchEditRootRefreshV2,\r\n    children: reloadRoutes,\r\n  },\r\n];\r\n\r\n\r\n/**\r\n * Root routes only meant for the entry points of the application, \"App\" and \"Apps\"\r\n */\r\nexport const EditRoutesUnderAppsList: Routes = [\r\n  { // Old\r\n    matcher: matchEditRoot,\r\n    loadChildren: () => editRoutesDialogAndChildren,\r\n  },\r\n  // { // New\r\n  //   matcher: matchEditRootV2,\r\n  //   loadChildren: () => editRoutesDialogAndChildren,\r\n  // },\r\n  { // Old\r\n    matcher: matchEditRootRefresh,\r\n    children: reloadRoutes,\r\n  },\r\n  // { // New\r\n  //   matcher: matchEditRootRefreshV2,\r\n  //   children: reloadRoutes,\r\n  // },\r\n];"],
  "mappings": "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",
  "names": ["editDialog", "name", "initContext", "panelSize", "panelClass", "getComponent", "injector", "__async", "get", "FeaturesDisableAutoLoadService", "disableAutoLoad", "EditEntryComponent", "logSpecs", "all", "hasGuidAndId", "editRouteMatcherRoot", "editRouteMatcherRootRefresh", "editRouteMatcherSubEdit", "editRouteMatcherSubEditRefresh", "logger", "classLog", "matchEditRoot", "url", "matchEditRootV2", "posEdit", "posPurpose", "posAppId", "l", "fnIf", "specs", "checkRelevantAndIds", "rNull", "match", "consumed", "slice", "hasPurpose", "posParams", "__spreadValues", "zoneId", "appId", "items", "identities", "r", "matchEditSub", "length", "path", "purpose", "guid", "id", "hasDetails", "hasUpdate", "detailsEntityGuid", "detailsFieldId", "updateEntityGuid", "updateFieldId", "matchEditSubRefresh", "matchEditRootRefresh", "matchEditRootRefreshV2", "segments", "log", "classLog", "reloadRoutes", "path", "loadComponent", "then", "m", "EditReloadComponent", "data", "title", "editRoutesDialogAndChildren", "DialogEntryComponent", "dialog", "editDialog", "loadChildren", "EditRoutes", "historyRoutes", "matcher", "matchEditSub", "a", "matchEditSubRefresh", "children", "EditRoutesNoHistory", "history", "EditRoutesRoot", "matchEditRootV2", "matchEditRootRefreshV2", "EditRoutesUnderAppsList", "matchEditRoot", "matchEditRootRefresh"]
}
