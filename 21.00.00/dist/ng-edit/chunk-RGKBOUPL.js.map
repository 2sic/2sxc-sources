{
  "version": 3,
  "sources": ["projects/eav-ui/src/app/shared/signals/signal.utilities.ts"],
  "sourcesContent": ["import { computed, signal, Signal, WritableSignal } from '@angular/core';\r\nimport { ReactiveNode, SIGNAL } from '@angular/core/primitives/signals';\r\nimport isEqual from 'lodash-es/isEqual';\r\nimport { Observable, take } from 'rxjs';\r\n\r\n\r\n/**\r\n * Named signal with object equality check\r\n * @param name name for debugging\r\n * @param initialValue initial value to start the signal\r\n * @returns\r\n */\r\nexport function signalObj<T>(name: string, initialValue: T): WritableSignal<T> {\r\n  const sig = signal(initialValue, { equal: isEqual, debugName: name }) as WritableSignal<T>;\r\n  return named(name, sig);\r\n}\r\n\r\nexport function computedObj<T>(name: string, computation: () => T): Signal<T> {\r\n  const comp =  computed(computation, { equal: isEqual, debugName: name }) as Signal<T>; // needs recast, because isEqual changes it to Signal<any>\r\n  return named(name, comp);\r\n}\r\n\r\n// Either in the place where it is called, or if the service is only used in one place, in the service itself to return a signal instead\r\n/**\r\n * Convert a single http get into a simple signal.\r\n * It will initialize with the optional initialValue and then update with the httpGet result.\r\n * As such, it has a first value, and will only update once.\r\n * @param name name of the signal for debugging\r\n * @param httpRequest the http request\r\n * @param initialValue optional initial value\r\n * @returns\r\n */\r\nexport function httpToSignal<T>(name: string, httpRequest: Observable<T>, initialValue: T = null): Signal<T> {\r\n  const sig = signal(initialValue, { equal: isEqual, debugName: name }) as WritableSignal<T>;\r\n  // take(1) to only get the first value, and close the subscription right afterwards - which is what happens to all normal http requests\r\n  httpRequest.pipe(take(1)).subscribe(value => sig.set(value));\r\n  return named(name, sig.asReadonly());\r\n}\r\n\r\n\r\nexport function named<TSig, TVal extends Signal<TVal> | WritableSignal<TVal>>(name: string, signal: TSig): TSig {\r\n  if (!signal) return signal;\r\n  const sigAny = signal as any;\r\n  sigAny.debugName = name;\r\n  if (!sigAny[SIGNAL]) return signal;\r\n  (sigAny[SIGNAL]).debugName = name;\r\n  return signal;\r\n}\r\n\r\n\r\n\r\n// wip atm unused\r\n/** Slightly unclean signal with previous value */\r\n// https://github.com/angular/angular/issues/54339\r\nexport function computedWithPrev<T>(computation: (prev: T | undefined) => T, initial?: T): Signal<T> {\r\n\tlet previous = initial;\r\n\treturn computed(() => {\r\n\t\tconst newValue = computation(previous);\r\n\t\tprevious = newValue;\r\n\t\treturn newValue;\r\n\t}, { equal: isEqual });\r\n}\r\n\r\nexport function getVersion(signal: Signal<unknown>): number | null {\r\n  if (!signal) return null;\r\n  return (signal[SIGNAL] as ReactiveNode)?.version ?? null;\r\n}\r\n"],
  "mappings": "gGAYM,SAAUA,EAAaC,EAAcC,EAAe,CACxD,IAAMC,EAAMC,EAAOF,EAAc,CAAEG,MAAOC,EAASC,UAAWN,CAAI,CAAE,EACpE,OAAOO,EAAMP,EAAME,CAAG,CACxB,CAEM,SAAUM,EAAeR,EAAcS,EAAoB,CAC/D,IAAMC,EAAQC,EAASF,EAAa,CAAEL,MAAOC,EAASC,UAAWN,CAAI,CAAE,EACvE,OAAOO,EAAMP,EAAMU,CAAI,CACzB,CAoBM,SAAUE,EAA8DC,EAAcC,EAAY,CACtG,GAAI,CAACA,EAAQ,OAAOA,EACpB,IAAMC,EAASD,EAEf,OADAC,EAAOC,UAAYH,EACdE,EAAOE,CAAM,IACjBF,EAAOE,CAAM,EAAGD,UAAYH,GACtBC,CACT,CAOM,SAAUI,EAAoBC,EAAyCC,EAAW,CACvF,IAAIC,EAAWD,EACf,OAAOE,EAAS,IAAK,CACpB,IAAMC,EAAWJ,EAAYE,CAAQ,EACrCA,OAAAA,EAAWE,EACJA,CACR,EAAG,CAAEC,MAAOC,CAAO,CAAE,CACtB,CAEM,SAAUC,EAAWZ,EAAuB,CAChD,OAAKA,EACGA,EAAOG,CAAM,GAAoBU,SAAW,KADhC,IAEtB",
  "names": ["signalObj", "name", "initialValue", "sig", "signal", "equal", "isEqual", "debugName", "named", "computedObj", "computation", "comp", "computed", "named", "name", "signal", "sigAny", "debugName", "SIGNAL", "computedWithPrev", "computation", "initial", "previous", "computed", "newValue", "equal", "isEqual", "getVersion", "version"]
}
