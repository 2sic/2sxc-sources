{"version":3,"sources":["node_modules/@2sic.com/sxc-angular/fesm2022/2sic.com-sxc-angular.mjs","projects/eav-ui/src/app/shared/services/http-service-base-signal.ts"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, NgModule, Optional, SkipSelf, Directive, Input, EventEmitter, Output } from '@angular/core';\nimport * as i1 from '@angular/common/http';\nimport { HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { map } from 'rxjs/operators';\n\n/**\n *\n */\nconst appTag = {\n  edition: 'edition',\n  apiEdition: 'api-edition',\n  antiForgeryToken: 'anti-forgery-token',\n  moduleId: 'module-id',\n  tabId: 'tab-id',\n  contentBlockId: 'content-block-id',\n  // new in 11.01\n  angularPath: 'angular-path'\n};\n\n/**\n * Special service to inject in the root of the app.\n * Allows you to pass configuration on the app-tag in HTML to configure the application.\n *\n */\nclass AppTagService {\n  appElement;\n  constructor(\n  /**\n   * The app-tag on the HTML page.\n   */\n  appElement) {\n    this.appElement = appElement;\n  }\n  /**\n   * Get the value of an attribute on the main app-tag\n   * @param attributeName\n   * @returns\n   */\n  getAttribute(attributeName) {\n    // todo: after upgrading to NG8, probably use el.GetAttribute\n    return this.appElement.nativeElement.getAttribute(attributeName);\n  }\n}\nconst runtimeDefaults = {\n  addHttpHeaders: true\n};\nlet constructorCount = 0;\n/**\n * The Context gives you things from DNN and 2sxc which matches the current runtime context.\n * So it auto-detects what's going on in the page and initializes / provides everything.\n *\n * Note: some properties like moduleId are probably not actually in use any more and will probably be empty\n *\n * @class Context\n * @implements {ContextInfo}\n */\nlet Context = /*#__PURE__*/(() => {\n  class Context {\n    /** The global $2sxc object */\n    $2sxc;\n    /** The current module-instance 2sxc-controller */\n    sxc;\n    /** Setting if it should add HTTP headers. Default is true. You may want to change this if you have an own interceptor.  */\n    addHttpHeaders;\n    /** The current app name - used in API calls */\n    appNameInPath;\n    /** The current edition to use for the application. */\n    edition;\n    /** The API edition to use - if you use API-editions (recommended). Will usually be the same as the edition. */\n    apiEdition;\n    /** The Module ID if it was custom-configured. Will be 'unknown' if not manually set, as then the auto-configure will be used */\n    moduleId;\n    /** The Content Block ID if it was custom-configured. Will be 'unknown' if not manually set, as then the auto-configure will be used */\n    contentBlockId;\n    /**\n     * The path angular is running in - it's important for lazy-loading to work properly.\n     *\n     * New in v11.01\n     */\n    angularPath;\n    appTagService;\n    preConfiguration;\n    constructor() {\n      this.$2sxc = window.$2sxc;\n      if (this.$2sxc === undefined) {\n        throw new Error('window.$2sxc is null - you probably forgot to include the script before loading angular');\n      }\n      this.check2sxcVersion();\n      constructorCount++;\n      if (constructorCount > 1) {\n        console.warn('The Context object of sxc-angular was created more than once. This is unexpected, and will probably lead to problems with the api calls.');\n      }\n    }\n    check2sxcVersion() {\n      // Actually the required version is 10.25.2, but 2sxc-ui reports 10.25.1 in 2sxc 10.25.2\n      const requiredVersion = [10, 25, 1];\n      const version = this.$2sxc.sysinfo.version.split('.').map(v => parseInt(v));\n      // Reduce version to comparision number - 0 means equal, 1 means version > requiredVersion, -1 means version < requiredVersion\n      const compareVersions = requiredVersion.reduce((acc, _, i) => acc != 0 ? acc : Math.sign(version[i] - requiredVersion[i]), 0);\n      if (compareVersions < 0) {\n        throw new Error(`Installed 2sxc version is ${version.join('.')} but ${requiredVersion.join('.')} is required for sxc-angular.`);\n      }\n    }\n    /**\n     * Pre-Configure this context - can be used to configure values in a subclass\n     * @param preConfig Pre-Configuration values for this context\n     */\n    preConfigure(preConfig) {\n      this.preConfiguration = preConfig;\n      return this;\n    }\n    /**\n     * Configure 2sxc in the context of a HTMLNode.\n     * @param htmlNode the HTMLNode\n     */\n    autoConfigure(htmlNode) {\n      this.appTagService = new AppTagService(htmlNode);\n      let settings = {\n        ...runtimeDefaults,\n        // defaults - lowest priority\n        ...this.getContextFromAppTag(),\n        // app tags override settings\n        ...this.preConfiguration\n      };\n      // Use pre-configured values already in settings if defined; otherwise\n      // get from HTMLNode\n      settings.sxc = settings.sxc || (settings.moduleId ? this.$2sxc(settings.moduleId, settings.contentBlockId) : this.$2sxc(htmlNode.nativeElement));\n      if (!settings.sxc) {\n        throw new Error('couldn\\'t get sxc instance - reason unknown');\n      }\n      this.sxc = settings.sxc;\n      this.addHttpHeaders = settings.addHttpHeaders;\n      this.appNameInPath = settings.appNameInPath;\n      this.edition = settings.edition;\n      this.apiEdition = settings.apiEdition;\n      // new in 11.01 - change the base path for angular chunks if needed\n      if (settings.angularPath) {\n        this.angularPath = settings.angularPath;\n        console.log('will set webpcak base to: ' + settings.angularPath);\n        __webpack_public_path__ = settings.angularPath;\n        console.log('done setting');\n      }\n    }\n    /**\n     * Get an attribute value from the app-tag\n     * @param name attribute name\n     */\n    getAppAttribute(name) {\n      return this.appTagService.getAttribute(name);\n    }\n    /**\n     * Get context information like module-id from the app-root tag\n     * new in Sxc-Angular 8\n     */\n    getContextFromAppTag() {\n      let contextFromApp = {\n        edition: this.appTagService.getAttribute(appTag.edition),\n        apiEdition: this.appTagService.getAttribute(appTag.apiEdition),\n        // 2021-02-26 2dm v11.01 added\n        angularPath: this.appTagService.getAttribute(appTag.angularPath)\n      };\n      // Return an object containing only the not-null properties\n      return contextFromApp;\n    }\n    static ɵfac = function Context_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Context)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Context,\n      factory: Context.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Context;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** @internal */\nfunction getHttpParams(params) {\n  return typeof params === 'string' ? new HttpParams({\n    fromString: params\n  }) : params instanceof HttpParams ? params : new HttpParams({\n    fromObject: params\n  });\n}\n\n/** @internal */\nconst apiRouteName = 'api';\n/** @internal */\nconst contentRouteName = 'content';\n/** @internal */\nconst queryRouteName = 'query';\n/** @internal */\nconst routeRoot = 'app/auto/';\n/** @internal */\nconst routeApi = `${routeRoot}${apiRouteName}`;\n/** @internal */\nconst routeQuery = `${routeRoot}${queryRouteName}`;\n/** @internal */\nconst routeContent = `${routeRoot}${contentRouteName}`;\n\n/**\n * Quickly call WebApis on the current App\n *\n * @export\n * @class SxcApiService\n */\nclass SxcApiService {\n  http;\n  controller;\n  constructor(http, controller) {\n    this.http = http;\n    this.controller = controller;\n  }\n  /**\n   * Get the request URL of the api\n   */\n  url(method) {\n    return `${routeApi}/${this.controller}/${method}`;\n  }\n  /**\n   * Do a GET request to the specified 2sxc api controller\n   */\n  get(method, urlParams) {\n    const requestParams = getHttpParams(urlParams);\n    return this.http.get(this.url(method), {\n      params: requestParams\n    });\n  }\n  /**\n   * Do a POST request to the specified 2sxc api controller\n   */\n  post(method, urlParams, body) {\n    const requestParams = getHttpParams(urlParams);\n    return this.http.post(this.url(method), body, {\n      params: requestParams\n    });\n  }\n  /**\n   * Do a PUT request to the specified 2sxc api controller\n   */\n  put(method, urlParams, body) {\n    const requestParams = getHttpParams(urlParams);\n    return this.http.put(this.url(method), body, {\n      params: requestParams\n    });\n  }\n  /**\n   * Do a DELETE request to the specified 2sxc api controller\n   */\n  delete(method, urlParams) {\n    const requestParams = getHttpParams(urlParams);\n    return this.http.put(this.url(method), {\n      params: requestParams\n    });\n  }\n}\n\n/**\n * A helper to access data from 2sxc\n *\n * @class SxcDataService\n * @template T Type which the system will return\n */\nclass SxcDataService {\n  http;\n  contentType;\n  constructor(http, contentType) {\n    this.http = http;\n    this.contentType = contentType;\n  }\n  /**\n   * Get all items of this type\n   */\n  getAll() {\n    const url = `${routeContent}/${this.contentType}`;\n    return this.http.get(url);\n  }\n  /**\n   * get the specific item with the ID\n   */\n  getOne(id) {\n    const url = `${routeContent}/${this.contentType}/${id}`;\n    return this.http.get(url);\n  }\n  /**\n   * Internal implementation of create\n   */\n  create(item, metadataFor) {\n    const url = `${routeContent}/${this.contentType}`;\n    item = metadataFor != null ? {\n      ...item,\n      For: metadataFor\n    } : item;\n    return this.http.post(url, item);\n  }\n  /**\n   * Update the specific item with the ID to the item\n   */\n  update(id, item) {\n    const url = `${routeContent}/${this.contentType}/${id}`;\n    return this.http.post(url, item);\n  }\n  /**\n   * Delete the specific item with ID/with GUID\n   */\n  delete(id) {\n    const url = `${routeContent}/${this.contentType}/${id}`;\n    return this.http.delete(url);\n  }\n}\n\n/**\n * Query object for getting typed data.\n * @export\n * @class SxcQueryService\n * @template T type (usually an interface) of the data coming back\n */\nclass SxcQueryService {\n  http;\n  name;\n  constructor(http, name) {\n    this.http = http;\n    this.name = name;\n  }\n  streamParamKey = 'stream';\n  /**\n   * Internal implementation of getAll\n   */\n  getAll(params, data) {\n    const url = `${routeQuery}/${this.name}`;\n    const streamParams = getHttpParams(params);\n    if (data) return this.http.post(url, data, {\n      params: streamParams\n    });\n    return this.http.get(url, {\n      params: streamParams\n    });\n  }\n  /**\n   * Internal implementation of getStream\n   */\n  getStream(stream, urlParams, data) {\n    const url = `${routeQuery}/${this.name}?${this.streamParamKey}=${stream}`;\n    const streamParams = getHttpParams(urlParams);\n    if (data) return this.http.post(url, data, {\n      params: streamParams\n    }).pipe(map(res => res[stream]));\n    return this.http.get(url, {\n      params: streamParams\n    }).pipe(map(res => res[stream]));\n  }\n  /**\n   * Internal implementation of getStreams\n   */\n  getStreams(streams, urlParams, data) {\n    const url = `${routeQuery}/${this.name}?${this.streamParamKey}=${streams.join(',')}`;\n    const streamParams = getHttpParams(urlParams);\n    if (data) return this.http.post(url, data, {\n      params: streamParams\n    });\n    return this.http.get(url, {\n      params: streamParams\n    });\n  }\n}\n\n/**\n * 2sxc App Instance Object\n * <br>\n * gives you access to content and query streams using the content$ and query$ commands\n * you can also use the content and query managers, but these are currently not so useful.\n *\n * @export\n * @class SxcApp\n */\nlet SxcApp = /*#__PURE__*/(() => {\n  class SxcApp {\n    http;\n    constructor(http) {\n      this.http = http;\n    }\n    /**\n     * Cet a content manager object for a specific ContentType\n     * @param contentType name of the content-type\n     * @returns a query object with .getAll(), .getOne(), .create(), .update(), .delete()\n     */\n    data(contentType) {\n      return new SxcDataService(this.http, contentType);\n    }\n    /**\n     * get a query object to then start queries\n     * @param name the query name\n     * @returns a SxcQueryService object with .getAll(), .getStreams(), .getStream()\n     */\n    query(name) {\n      return new SxcQueryService(this.http, name);\n    }\n    /**\n     * get an api object to then start api-calls\n     * @param controller the api controller\n     * @returns an SxcApiService object with .url(), .get<T>(), .post<T>(), .put<T>(), .delete<T>() method\n     */\n    api(controller) {\n      return new SxcApiService(this.http, controller);\n    }\n    static ɵfac = function SxcApp_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SxcApp)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SxcApp,\n      factory: SxcApp.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return SxcApp;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SxcHttpInterceptor = /*#__PURE__*/(() => {\n  class SxcHttpInterceptor {\n    context;\n    constructor(context) {\n      this.context = context;\n    }\n    intercept(req, next) {\n      // skip interceptor for CORS requests\n      if (!this.isSameOrigin(req)) return next.handle(req);\n      let url = req.url;\n      let ctx = this.context;\n      if (ctx.$2sxc) {\n        url = ctx.$2sxc.http.apiUrl(req.url);\n      }\n      // change to use api of an edition, if an edition was specified\n      // but only do this on api-routes, the others don't support editions\n      if (ctx.apiEdition) {\n        url = url.replace(routeApi, routeRoot + ctx.apiEdition + '/' + apiRouteName);\n      }\n      if (ctx.appNameInPath) {\n        url = url.replace(routeRoot, `app/${ctx.appNameInPath}/`);\n      }\n      let headers = {};\n      if (ctx.addHttpHeaders && ctx.sxc) {\n        headers = ctx.sxc.webApi.headers();\n        headers = this.convertAllPropertiesToString(headers);\n      }\n      // Clone the request and update the url with 2sxc params.\n      const newReq = req.clone({\n        url: url,\n        setHeaders: headers\n      });\n      return next.handle(newReq);\n    }\n    isSameOrigin(req) {\n      let url = req.url.toLowerCase();\n      let isRelativeUrl = true;\n      if (url.startsWith('https://') || url.startsWith('http://')) {\n        isRelativeUrl = false;\n      } else if (url.startsWith('//')) {\n        // protocol relative url\n        isRelativeUrl = false;\n        url = window.location.protocol + url;\n      }\n      if (isRelativeUrl) return true;\n      if (url.startsWith(`${window.location.protocol}//${window.location.host}`)) return true;\n      return false;\n    }\n    convertAllPropertiesToString(obj) {\n      return Object.keys(obj).reduce((a, k) => ({\n        ...a,\n        [k]: obj[k].toString()\n      }), {});\n    }\n    static ɵfac = function SxcHttpInterceptor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SxcHttpInterceptor)(i0.ɵɵinject(Context));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SxcHttpInterceptor,\n      factory: SxcHttpInterceptor.ɵfac\n    });\n  }\n  return SxcHttpInterceptor;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Register the `SxcInterceptor` in a Module.\n * Happens automatically when you import the SxcRootModule.\n */\nconst SxcHttpInterceptorProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: SxcHttpInterceptor,\n  multi: true\n};\n\n/**\n * The Root module which must be included in the application root.\n * It ensures that context etc. is singleton across the entire application\n * @export\n * @class SxcRootModule\n */\nlet SxcRootModule = /*#__PURE__*/(() => {\n  class SxcRootModule {\n    // This constructor is a special helper to prevent use in sub-modules\n    // https://angular.io/guide/singleton-services#prevent-reimport-of-the-greetingmodule\n    constructor(parentModule) {\n      if (parentModule) throw new Error('SxcRootModule is already loaded. Import it in the root AppModule only');\n    }\n    static ɵfac = function SxcRootModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SxcRootModule)(i0.ɵɵinject(SxcRootModule, 12));\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: SxcRootModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [SxcApp, Context, SxcHttpInterceptorProvider]\n    });\n  }\n  return SxcRootModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SxcToolbarDirective = /*#__PURE__*/(() => {\n  class SxcToolbarDirective {\n    elementRef;\n    context;\n    config = {};\n    constructor(elementRef, context) {\n      this.elementRef = elementRef;\n      this.context = context;\n    }\n    ngOnInit() {\n      const sxc = this.context.sxc;\n      if (!sxc.manage) return; // edit not available, probably not logged in\n      this.elementRef.nativeElement.innerHTML = sxc.manage.getToolbar(this.config.toolbar, this.config.settings);\n    }\n    static ɵfac = function SxcToolbarDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SxcToolbarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(Context));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: SxcToolbarDirective,\n      selectors: [[\"sxc-toolbar\"]],\n      inputs: {\n        config: \"config\"\n      },\n      standalone: false\n    });\n  }\n  return SxcToolbarDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The toolbar attribute to be used on any HTML tag.\n * Will bring the floating edit-toolbar to the UI if the user is logged in\n *\n * @export\n * @class SxcTagToolbarDirective\n * @implements {OnInit}\n */\nlet SxcTagToolbarDirective = /*#__PURE__*/(() => {\n  class SxcTagToolbarDirective {\n    element;\n    context;\n    /**\n     * The configuration of this toolbar\n     * @type {*} see 2sxc docs, can be a string, string[], or an object\n     */\n    sxcToolbar; // old name for compatibility\n    /**\n     * A refresh callback when an action on the toolbar requires data to be refreshed.\n     * If not specified, the page will simply reload, if specified, this action will run and page-reload won't happen.\n     * New in v.11.12\n     */\n    refresh = new EventEmitter();\n    constructor(element, context) {\n      this.element = element;\n      this.context = context;\n    }\n    ngOnInit() {\n      if (!this.context?.sxc?.isEditMode()) return;\n      const node = this.element.nativeElement;\n      this.preventRefreshIfListenerConfigured();\n      node.setAttribute(\"sxc-toolbar\", JSON.stringify(this.sxcToolbar || {}));\n      return this.context.$2sxc?._manage?._toolbarManager.build(node);\n    }\n    /**\n     * Check if the event emiter has a listener, and if yes, stop automatic page reload\n     */\n    preventRefreshIfListenerConfigured() {\n      //\n      if (this.refresh.observers.length > 0) {\n        this.element.nativeElement.addEventListener('toolbar-init', event => {\n          event?.detail?.workflow?.add({\n            command: 'refresh',\n            // only capture refresh requests\n            code: wfArgs => {\n              this.refresh.emit(wfArgs); // emit event\n              return false; // prevent default refresh of the 2sxc API\n            }\n          });\n        });\n      }\n    }\n    static ɵfac = function SxcTagToolbarDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || SxcTagToolbarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(Context));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: SxcTagToolbarDirective,\n      selectors: [[\"\", \"sxc-toolbar\", \"\"]],\n      inputs: {\n        sxcToolbar: [0, \"sxc-toolbar\", \"sxcToolbar\"]\n      },\n      outputs: {\n        refresh: \"refresh\"\n      },\n      standalone: false\n    });\n  }\n  return SxcTagToolbarDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This module provides content-editing / management features to Angular.\n * It ensures that you can use attributes like sxc-toolbar\n * and tags like <sxc-toolbar>\n *\n * @export\n * @class ContentManagerModule\n */\nlet ContentManagerModule = /*#__PURE__*/(() => {\n  class ContentManagerModule {\n    static ɵfac = function ContentManagerModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ContentManagerModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: ContentManagerModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [SxcApp]\n    });\n  }\n  return ContentManagerModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A root app component which initializes the context-providers once the app is loaded\n * This is the earliest moment we can access the ElementRef, because before that\n * it's not attached to the DOM, so auto-detect wouldn't work.\n * @export\n * @class SxcAppComponent\n */\nclass SxcAppComponent {\n  /**\n   *\n   * @param element the angular ElementRef - required to auto-detect moduleId and more\n   * @param context the context service, which handles and shares auto-detection\n   * @param enableDefaultSubmit causes enter-hits to submit the asp.net forms (defaults to false)\n   */\n  constructor(element, context, enableDefaultSubmit) {\n    // auto-config to pick up tab-id, module id, etc.\n    context.autoConfigure(element);\n    // prevent asp.net submit action caused by enter-keys inside our app\n    if (!enableDefaultSubmit) element.nativeElement.addEventListener('keydown', e => {\n      if (e.target.tagName.toLowerCase() === 'input' && e.keyCode === 13) e.preventDefault();\n    });\n  }\n}\n\n/*\n  Primary exports\n  The exports here must be chosen wisely, because they should really only contain the publicly used / created / typed objects.\n*/\n// ------------------------- Modules -------------------------\n// The root module which should be in the application root\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AppTagService, ContentManagerModule, Context, SxcApiService, SxcApp, SxcAppComponent, SxcDataService, SxcHttpInterceptorProvider, SxcQueryService, SxcRootModule, SxcTagToolbarDirective, SxcToolbarDirective };\n","import { Context as DnnContext } from '@2sic.com/sxc-angular';\r\nimport { HttpClient, httpResource } from '@angular/common/http';\r\nimport { inject, Injectable, Injector, Signal, signal } from '@angular/core';\r\nimport { firstValueFrom } from 'rxjs';\r\nimport { Context } from '../../shared/services/context';\r\n\r\n/**\r\n * Base class for all services that need to make HTTP calls.\r\n * Provides important typical information and services, especially\r\n * * apiUrl(name) - to get the full API URL\r\n * * appId - the current app id\r\n * * zoneId - the current zone id\r\n */\r\n@Injectable()\r\nexport class HttpServiceBaseSignal {\r\n\r\n  protected http = inject(HttpClient);\r\n  protected context = inject(Context);\r\n\r\n  // Retrieves the current Angular Injector instance from the DI system and stores it as a protected property.\r\n  // This allows you to create instances (e.g., services) later in this specific context.\r\n  protected injector = inject(Injector);\r\n\r\n  #dnnContext = inject(DnnContext);\r\n\r\n  /**\r\n   * Convert a short 2sxc-url into the correct full URL on the system.\r\n   * @param name 2sxc-style short url\r\n   * @returns\r\n   */\r\n  protected apiUrl(name: string) {\r\n    return this.#dnnContext.$2sxc.http.apiUrl(name);\r\n  }\r\n\r\n  /**\r\n   * The current app id\r\n   */\r\n  protected get appId() { return this.context.appId.toString(); }\r\n\r\n  /**\r\n   * The current zone id\r\n   */\r\n  protected get zoneId() { return this.context.zoneId.toString(); }\r\n\r\n  /**\r\n * NEW V20 Helper method to create an httpResource<T> with additional options such as a custom injector.\r\n * Advantage: If the httpResource API changes in the future, you only need to update this method in one place.\r\n * @param request - The request callback or object for httpResource<T>. \r\n *                  The signature is identical to the first parameter of httpResource<T>.\r\n * @returns A new httpResource<T> signal with centrally configurable options.\r\n */\r\n  protected newHttpResource<T>(request: Parameters<typeof httpResource>[0]) {\r\n    return httpResource<T>(request, { injector: this.injector });\r\n  }\r\n\r\n  /**   \r\n   *  Makes an HTTP GET request and returns a Signal with the response body of type T\r\n   * @param endpoint - The API endpoint path (will be combined with base URL)\r\n   *  @param options - Angular HttpClient options (headers, params, etc.)\r\n   * @param initial - Initial value for the Signal before the HTTP call\r\n   * @returns Signal that resolves to the HTTP response body of type T\r\n  */\r\n  protected postSignal<ResultType>(endpoint: string, body: Parameters<typeof this.http.post>[1], options: Parameters<typeof this.http.post>[2], initial: ResultType): Signal<ResultType> {\r\n    const target = signal<ResultType>(initial);\r\n    this.http.post<ResultType>(this.apiUrl(endpoint), body, options).subscribe(d => {\r\n      target.set(d)\r\n    });\r\n    return target;\r\n  }\r\n\r\n  /**\r\n   * Makes an HTTP GET request and returns a Promise with just the status code\r\n   * @param endpoint - The API endpoint path(will be combined with base URL)\r\n   * @param options - Angular HttpClient options(headers, params, etc.)\r\n   * @returns Promise that resolves to the HTTP status code(or error status code)\r\n  */\r\n  protected getStatusPromise(\r\n    endpoint: string,\r\n    options?: Parameters<typeof this.http.get>[1]\r\n  ): Promise<number> {\r\n    try {\r\n      // Ensure observe: 'response' is included in the options\r\n      const httpOptions = {\r\n        ...options,\r\n        observe: 'response' as const\r\n      };\r\n      // Convert the Observable returned by HttpClient to a Promise\r\n      return firstValueFrom(\r\n        this.http.get(this.apiUrl(endpoint), httpOptions)\r\n      )\r\n        .then(response => response.status)\r\n        .catch(error => {\r\n          console.error(`HTTP error in getStatusPromise:`, error);\r\n          return error?.status ?? 500;\r\n        });\r\n    } catch (e: any) {\r\n      // This catch handles any synchronous errors\r\n      console.error(`Error in getStatusPromise:`, e);\r\n      return Promise.resolve(500);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Makes an HTTP GET request and returns a Promise with the response body of type T\r\n   * @param endpoint - The API endpoint path (will be combined with base URL)\r\n   * @param options - Angular HttpClient options (headers, params, etc.)\r\n   * @returns Promise that resolves to the HTTP response body of type T (or rejects/returns null on error)\r\n   */\r\n  protected fetchPromise<T>(\r\n    endpoint: string,\r\n    options?: Parameters<typeof this.http.get>[1]\r\n  ): Promise<T> {\r\n    try {\r\n      // Ensure observe: 'body' is used (default for HttpClient.get)\r\n      const httpOptions = {\r\n        ...options,\r\n        observe: 'body' as const\r\n      };\r\n      // Convert the Observable returned by HttpClient to a Promise\r\n      return firstValueFrom(\r\n        this.http.get<T>(this.apiUrl(endpoint), httpOptions)\r\n      ).catch(error => {\r\n        console.error(`HTTP error in fetchPromise:`, error);\r\n        // You can throw, return null, or handle as you wish\r\n        throw error;\r\n      });\r\n    } catch (e: any) {\r\n      // Handles synchronous errors\r\n      console.error(`Error in fetchPromise:`, e);\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","names":["appTag","AppTagService","appElement","attributeName","runtimeDefaults","constructorCount","Context","requiredVersion","version","v","acc","_","i","preConfig","htmlNode","settings","__spreadValues","name","__ngFactoryType__","ɵɵdefineInjectable","apiRouteName","contentRouteName","queryRouteName","routeRoot","routeApi","routeQuery","routeContent","SxcHttpInterceptor","context","req","next","url","ctx","routeApi","routeRoot","apiRouteName","headers","newReq","isRelativeUrl","obj","a","k","__spreadProps","__spreadValues","__ngFactoryType__","ɵɵinject","Context","ɵɵdefineInjectable","SxcHttpInterceptorProvider","HTTP_INTERCEPTORS","SxcAppComponent","element","context","enableDefaultSubmit","e","HttpServiceBaseSignal","constructor","http","inject","HttpClient","context","Context","injector","Injector","#dnnContext","DnnContext","apiUrl","name","$2sxc","appId","toString","zoneId","newHttpResource","request","httpResource","postSignal","endpoint","body","options","initial","target","signal","post","subscribe","d","set","getStatusPromise","httpOptions","__spreadProps","__spreadValues","observe","firstValueFrom","get","then","response","status","catch","error","console","e","Promise","resolve","fetchPromise","reject","factory","ɵfac"],"x_google_ignoreList":[0]}