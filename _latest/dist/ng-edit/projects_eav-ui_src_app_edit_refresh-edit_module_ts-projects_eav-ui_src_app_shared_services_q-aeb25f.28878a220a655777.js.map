{"version":3,"file":"projects_eav-ui_src_app_edit_refresh-edit_module_ts-projects_eav-ui_src_app_shared_services_q-aeb25f.28878a220a655777.js","mappings":"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","names":["RefreshEditComponent","constructor","router","route","params","snapshot","oldEditUrl","items","newEditUrl","currentUrl","UrlHelpers","calculatePathFromRoot","lastIndex","lastIndexOf","newUrl","substring","replace","navigate","static","this","t","i0","i1","_angular_core__WEBPACK_IMPORTED_MODULE_1__","VBU","selectors","standalone","features","decls","vars","template","rf","ctx","encapsulation","editRefreshRoutes","path","component","data","title","RefreshEditModule","$C","G2t","RouterModule","forChild","QueryService","ServiceBase","http","context","super","EavLogger","getAvailableEntities","queryUrl","fields","entitiesFilter","log","a","hasParams","urlParams","toLocaleLowerCase","includes","appId","post","Guids","getEntities","contentTypes","itemIds","join","i2","_angular_core__WEBPACK_IMPORTED_MODULE_3__","jDH","factory","ɵfac","toObservable","source","options","injector","assertInInjectionContext","inject","Injector","subject","ReplaySubject","watcher","effect","value","err","untracked","error","next","manualCleanup","get","DestroyRef","onDestroy","destroy","complete","asObservable","toSignal","requiresCleanup","cleanupRef","state","signal","requireSync","kind","initialValue","sub","subscribe","set","rejectErrors","unsubscribe","bind","computed","current","ɵRuntimeError"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./projects/eav-ui/src/app/edit/refresh-edit.module.ts","./projects/eav-ui/src/app/shared/services/query.service.ts","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { NgModule } from '@angular/core';\r\nimport { Component } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\nimport { ActivatedRoute, Router } from '@angular/router';\r\nimport { EditParams } from './edit-matcher.models';\r\nimport { UrlHelpers } from './shared/helpers';\r\n\r\n@Component({\r\n  template: '',\r\n  standalone: true,\r\n})\r\nexport class RefreshEditComponent {\r\n  constructor(router: Router, route: ActivatedRoute) {\r\n    const params = route.snapshot.params as EditParams;\r\n    const oldEditUrl = `edit/refresh/${params.items}`;\r\n    const newEditUrl = `edit/${params.items}`;\r\n\r\n    const currentUrl = UrlHelpers.calculatePathFromRoot(route);\r\n    const lastIndex = currentUrl.lastIndexOf(oldEditUrl);\r\n    if (lastIndex <= 0) { return; }\r\n    const newUrl = currentUrl.substring(0, lastIndex) + currentUrl.substring(lastIndex).replace(oldEditUrl, newEditUrl);\r\n    router.navigate([newUrl]);\r\n  }\r\n}\r\n\r\nconst editRefreshRoutes: Routes = [\r\n  {\r\n    path: '',\r\n    component: RefreshEditComponent,\r\n    data: { title: 'Refreshing Edit Dialog' }\r\n  },\r\n];\r\n\r\n@NgModule({\r\n  imports: [\r\n    RouterModule.forChild(editRefreshRoutes),\r\n    RefreshEditComponent,\r\n  ],\r\n})\r\nexport class RefreshEditModule { }\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { EavLogger } from '../logging/eav-logger';\r\nimport { ServiceBase } from './service-base';\r\nimport { Context } from './context';\r\nimport { QueryStreams } from '../models/query-stream.model';\r\n\r\nconst logThis = false;\r\n\r\n@Injectable()\r\nexport class QueryService extends ServiceBase {\r\n\r\n  constructor(private http: HttpClient, private context: Context) {\r\n    super(new EavLogger('QueryService', logThis));\r\n  }\r\n\r\n  getAvailableEntities(queryUrl: string, params: string, fields: string, entitiesFilter?: string[]): Observable<QueryStreams> {\r\n    this.log.a('getAvailableEntities', { queryUrl, params, fields, entitiesFilter });\r\n    // Check if any params we should auto-add are already set (like in a query which has these params set in the configuration)\r\n    const hasParams = !!params;\r\n    const paramsLower = params?.toLocaleLowerCase() ?? '';\r\n    const hasAppId = paramsLower.includes('appid=') ?? false;\r\n    const allParams = ''\r\n      + (hasAppId ? '' : `&appId=${this.context.appId}`)\r\n      + (hasParams ? `&${params}` : '')\r\n      + '&$select=' + (fields ?? '' /* special catch to avoid the word \"null\" */);\r\n    // trim initial & because it will always start with an & and it should't\r\n    const urlParams = allParams.substring(1);\r\n    return this.http.post<QueryStreams>(`app/auto/query/${queryUrl}?${urlParams}`,\r\n      {\r\n        Guids: entitiesFilter,\r\n      },\r\n    );\r\n  }\r\n\r\n  getEntities({ contentTypes, itemIds, fields, log }: { contentTypes: string[]; itemIds: string[]; fields: string; log: string }): Observable<QueryStreams> {\r\n    this.log.a(`getEntities(${log})`, { contentTypes, itemIds, fields });\r\n    const allParams =\r\n      '&typeNames=' + (contentTypes?.join(',') ?? '')\r\n      + `&appId=${this.context.appId}`\r\n      + '&itemIds=' + (itemIds?.join(',') ?? '')\r\n      + '&$select=' + (fields ?? '' /* special catch to avoid the word \"null\" */);\r\n    // trim initial & because it will always start with an & and it should't\r\n    const urlParams = allParams.substring(1);\r\n    return this.http.post<QueryStreams>(\r\n      `app/auto/query/System.EntityPicker/Default?${urlParams}`,\r\n      {}\r\n    );\r\n  }\r\n}\r\n","/**\n * @license Angular v17.3.11\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    constructor(source) {\n        this.source = source;\n        this.destroyed = false;\n        this.destroyRef = inject(DestroyRef);\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: value => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n    const destroyRef = ɵgetOutputDestroyRef(ref);\n    return new Observable(observer => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe(v => observer.next(v));\n        return () => subscription.unsubscribe();\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n"],"x_google_ignoreList":[2]}