{"version":3,"file":"projects_eav-ui_src_app_edit_routing_edit-reload_component_ts-projects_eav-ui_src_app_shared_-e50ac3.518896d2a0b2f5f4.js","mappings":"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","names":["logThis","enabled","name","specs","EditReloadComponent","constructor","router","route","this","log","EavLogger","l","fn","p","snapshot","params","url","UrlHelpers","newUrlIfCurrentContainsOldUrl","items","rNull","navigate","r","static","t","i0","i1","_angular_core__WEBPACK_IMPORTED_MODULE_2__","VBU","selectors","standalone","features","decls","vars","template","rf","ctx","encapsulation","logSpecs","all","getAvailableEntities","getEntities","QueryService","http","context","queryUrl","fields","entitiesFilter","fnIf","hasParams","urlParams","toLocaleLowerCase","includes","appId","substring","post","Guids","contentTypes","itemIds","join","i2","jDH","factory","…µfac","ServiceBase","subscriptions","Subscription","ngOnDestroy","destroy","unsubscribe","_angular_core__WEBPACK_IMPORTED_MODULE_1__","toObservable","source","options","injector","assertInInjectionContext","inject","Injector","subject","ReplaySubject","watcher","effect","value","err","untracked","error","next","manualCleanup","get","DestroyRef","onDestroy","complete","asObservable","toSignal","requiresCleanup","cleanupRef","state","signal","requireSync","kind","initialValue","sub","subscribe","set","rejectErrors","bind","computed","current","…µRuntimeError"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./projects/eav-ui/src/app/edit/routing/edit-reload.component.ts","./projects/eav-ui/src/app/shared/services/query.service.ts","./projects/eav-ui/src/app/shared/services/service-base.ts","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { Component } from '@angular/core';\r\nimport { Router, ActivatedRoute } from '@angular/router';\r\nimport { EavLogger } from '../../shared/logging/eav-logger';\r\nimport { EditUrlParams } from './edit-url-params.model';\r\nimport { UrlHelpers } from '../shared/helpers';\r\n\r\nconst logThis = {\r\n  enabled: false,\r\n  name: 'EditReloadComponent',\r\n  specs: {},\r\n};\r\n\r\n/**\r\n * The purpose of this component is to refresh the edit dialog completely.\r\n * It works as follows:\r\n * 1. A close event of the child which requests a full refresh (probably just the history?)\r\n *    will cause the router to replace the Path to a url going to this control. This flushes the previous edit.\r\n * 2. This component will then navigate to the original edit dialog, restoring the original parameters. \r\n * \r\n * TODO: not sure if this is the best way to do this...\r\n */\r\n@Component({\r\n  selector: 'app-edit-reload',\r\n  template: '',\r\n  standalone: true,\r\n})\r\nexport class EditReloadComponent {\r\n\r\n  log = new EavLogger(logThis);\r\n\r\n  constructor(router: Router, route: ActivatedRoute) {\r\n    const l = this.log.fn('constructor', null, 'üîÑÔ∏è');\r\n    const p = route.snapshot.params as EditUrlParams;\r\n    const url = UrlHelpers.newUrlIfCurrentContainsOldUrl(route, `edit/refresh/${p.items}`, `edit/${p.items}`);\r\n    if (!url) return l.rNull('No URL to navigate to');\r\n    router.navigate([url]);\r\n    l.r('‚úÖ refresh complete');\r\n  }\r\n}\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { EavLogger } from '../logging/eav-logger';\r\nimport { Context } from './context';\r\nimport { QueryStreams } from '../models/query-stream.model';\r\n\r\nconst logSpecs = {\r\n  enabled: false,\r\n  name: 'QueryService',\r\n  specs: {\r\n    all: false,\r\n    getAvailableEntities: false,\r\n    getEntities: false,\r\n  }\r\n};\r\n\r\n@Injectable()\r\nexport class QueryService {\r\n\r\n  log = new EavLogger(logSpecs);\r\n  constructor(private http: HttpClient, private context: Context) { }\r\n\r\n  getAvailableEntities(queryUrl: string, params: string, fields: string, entitiesFilter?: string[]): Observable<QueryStreams> {\r\n    this.log.fnIf('getAvailableEntities', { queryUrl, params, fields, entitiesFilter });\r\n    // Check if any params we should auto-add are already set (like in a query which has these params set in the configuration)\r\n    const hasParams = !!params;\r\n    const paramsLower = params?.toLocaleLowerCase() ?? '';\r\n    const hasAppId = paramsLower.includes('appid=') ?? false;\r\n    const allParams = ''\r\n      + (hasAppId ? '' : `&appId=${this.context.appId}`)\r\n      + (hasParams ? `&${params}` : '')\r\n      + '&$select=' + (fields ?? '' /* special catch to avoid the word \"null\" */);\r\n    // trim initial & because it will always start with an & and it should't\r\n    const urlParams = allParams.substring(1);\r\n    return this.http.post<QueryStreams>(`app/auto/query/${queryUrl}?${urlParams}`,\r\n      {\r\n        Guids: entitiesFilter,\r\n      },\r\n    );\r\n  }\r\n\r\n  getEntities({ contentTypes, itemIds, fields, log }: { contentTypes: string[]; itemIds: string[]; fields: string; log: string }): Observable<QueryStreams> {\r\n    this.log.fnIf(`getEntities`, { log, contentTypes, itemIds, fields });\r\n    const allParams =\r\n      '&typeNames=' + (contentTypes?.join(',') ?? '')\r\n      + `&appId=${this.context.appId}`\r\n      + '&itemIds=' + (itemIds?.join(',') ?? '')\r\n      + '&$select=' + (fields ?? '' /* special catch to avoid the word \"null\" */);\r\n    // trim initial & because it will always start with an & and it should't\r\n    const urlParams = allParams.substring(1);\r\n    return this.http.post<QueryStreams>(\r\n      `app/auto/query/System.EntityPicker/Default?${urlParams}`,\r\n      {}\r\n    );\r\n  }\r\n}\r\n","import { Injectable, OnDestroy } from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\n\r\n/** Base class for services, withOUT logging */\r\n@Injectable()\r\nexport abstract class ServiceBase implements OnDestroy {\r\n\r\n  protected subscriptions = new Subscription();\r\n\r\n  // todo use this instead\r\n  ngOnDestroy(): void {\r\n    this.destroy();\r\n  }\r\n\r\n  destroy() {\r\n    this.subscriptions.unsubscribe();\r\n  }\r\n\r\n  // Note: we can't do this, because angular compiler complains about wanting to implement OnDestroy\r\n  // and if we do that, it will want a decorator, which we can't have here.\r\n  // ngOnDestroy() {\r\n  //   this.destroy();\r\n  // }\r\n\r\n}\r\n","/**\n * @license Angular v17.3.11\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, …µRuntimeError, …µgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    constructor(source) {\n        this.source = source;\n        this.destroyed = false;\n        this.destroyRef = inject(DestroyRef);\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new …µRuntimeError(953 /* …µRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: value => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n    const destroyRef = …µgetOutputDestroyRef(ref);\n    return new Observable(observer => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe(v => observer.next(v));\n        return () => subscription.unsubscribe();\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new …µRuntimeError(601 /* …µRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new …µRuntimeError(601 /* …µRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n"],"x_google_ignoreList":[3]}