{"version":3,"sources":["C:/Projects/2sxc/eav-item-dialog-angular/node_modules/@angular/cdk/__ivy_ngcc__/fesm5/text-field.js","C:/Projects/2sxc/eav-item-dialog-angular/node_modules/@angular/material/__ivy_ngcc__/fesm5/input.js","./src/app/shared/components/dialog-entry/dialog-entry.component.html","./src/app/shared/components/dialog-entry/dialog-entry.component.ts"],"names":["listenerOptions","passive","AutofillMonitor","_platform","_ngZone","this","_monitoredElements","Map","prototype","monitor","elementOrRef","_this","isBrowser","element","info","get","subject","asObservable","result","Subject","cssClass","listener","event","animationName","classList","contains","remove","run","next","target","isAutofilled","add","runOutsideAngular","addEventListener","set","unlisten","removeEventListener","stopMonitoring","complete","delete","ngOnDestroy","forEach","_info","ɵprov","factory","token","providedIn","ɵfac","t","TextFieldModule","ɵmod","type","ɵinj","imports","MAT_INPUT_VALUE_ACCESSOR","MAT_INPUT_INVALID_TYPES","nextUniqueId","MatInputBase","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","_super","MatInput","_elementRef","inputValueAccessor","_autofillMonitor","ngZone","call","_uid","_isServer","_isNativeSelect","focused","stateChanges","controlType","autofilled","_disabled","_required","_type","_readonly","_neverEmptyInputTypes","filter","has","nativeElement","_inputValueAccessor","_previousNativeValue","value","id","IOS","el","selectionStart","selectionEnd","setSelectionRange","nodeName","toLowerCase","multiple","Object","defineProperty","disabled","enumerable","configurable","_id","_validateType","_isTextarea","ngOnInit","subscribe","ngOnChanges","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","focus","options","_focusChanged","isFocused","readonly","_onInput","newValue","indexOf","Error","_isNeverEmpty","_isBadInput","validity","badInput","selectElement","firstOption","empty","selectedIndex","label","setDescribedByIds","ids","_ariaDescribedby","join","onContainerClick","ɵdir","selectors","hostAttrs","hostVars","hostBindings","rf","ctx","required","placeholder","errorState","toString","inputs","errorStateMatcher","exportAs","features","provide","useExisting","MatInputModule","providers","dialog","viewContainerRef","router","route","context","loaded$","navigation","getCurrentNavigation","dialogData","extras","state","dialogConfig","snapshot","data","name","getComponent","then","component","initContext","init","dialogRef","open","backdropClass","panelClass","panelSize","showScrollbar","autoFocus","closeOnNavigation","position","top","afterClosed","pipe","pathFromRoot","length","window","parent","$2sxc","totalPopup","close","error","navigate","url","relativeTo","DialogEntryComponent"],"mappings":"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","file":"default~app-administration-app-administration-module~apps-management-apps-management-module~content-~2c2e19c5.e39310c6b69cd72370dd.js","sourcesContent":["import { normalizePassiveListenerOptions, Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Injectable, NgZone, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Directive, ElementRef, Output, Optional, Inject, Input, HostListener, NgModule } from '@angular/core';\nimport { coerceElement, coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { EMPTY, Subject, fromEvent } from 'rxjs';\nimport { auditTime, takeUntil } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Options to pass to the animationstart listener. */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nvar listenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nvar AutofillMonitor = /** @class */ (function () {\n    function AutofillMonitor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    AutofillMonitor.prototype.monitor = function (elementOrRef) {\n        var _this = this;\n        if (!this._platform.isBrowser) {\n            return EMPTY;\n        }\n        var element = coerceElement(elementOrRef);\n        var info = this._monitoredElements.get(element);\n        if (info) {\n            return info.subject.asObservable();\n        }\n        var result = new Subject();\n        var cssClass = 'cdk-text-field-autofilled';\n        var listener = (function (event) {\n            // Animation events fire on initial element render, we check for the presence of the autofill\n            // CSS class to make sure this is a real change in state, not just the initial render before\n            // we fire off events.\n            if (event.animationName === 'cdk-text-field-autofill-start' &&\n                !element.classList.contains(cssClass)) {\n                element.classList.add(cssClass);\n                _this._ngZone.run(function () { return result.next({ target: event.target, isAutofilled: true }); });\n            }\n            else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                element.classList.contains(cssClass)) {\n                element.classList.remove(cssClass);\n                _this._ngZone.run(function () { return result.next({ target: event.target, isAutofilled: false }); });\n            }\n        });\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('animationstart', listener, listenerOptions);\n            element.classList.add('cdk-text-field-autofill-monitored');\n        });\n        this._monitoredElements.set(element, {\n            subject: result,\n            unlisten: function () {\n                element.removeEventListener('animationstart', listener, listenerOptions);\n            }\n        });\n        return result.asObservable();\n    };\n    AutofillMonitor.prototype.stopMonitoring = function (elementOrRef) {\n        var element = coerceElement(elementOrRef);\n        var info = this._monitoredElements.get(element);\n        if (info) {\n            info.unlisten();\n            info.subject.complete();\n            element.classList.remove('cdk-text-field-autofill-monitored');\n            element.classList.remove('cdk-text-field-autofilled');\n            this._monitoredElements.delete(element);\n        }\n    };\n    AutofillMonitor.prototype.ngOnDestroy = function () {\n        var _this = this;\n        this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    /** @nocollapse */\n    AutofillMonitor.ctorParameters = function () { return [\n        { type: Platform },\n        { type: NgZone }\n    ]; };\n    AutofillMonitor.ɵprov = ɵɵdefineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(ɵɵinject(Platform), ɵɵinject(NgZone)); }, token: AutofillMonitor, providedIn: \"root\" });\nAutofillMonitor.ɵfac = function AutofillMonitor_Factory(t) { return new (t || AutofillMonitor)(ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AutofillMonitor, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }]; }, null); })();\n    return AutofillMonitor;\n}());\n/** A directive that can be used to monitor the autofill state of an input. */\nvar CdkAutofill = /** @class */ (function () {\n    function CdkAutofill(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /** Emits when the autofill state of the element changes. */\n        this.cdkAutofill = new EventEmitter();\n    }\n    CdkAutofill.prototype.ngOnInit = function () {\n        var _this = this;\n        this._autofillMonitor\n            .monitor(this._elementRef)\n            .subscribe(function (event) { return _this.cdkAutofill.emit(event); });\n    };\n    CdkAutofill.prototype.ngOnDestroy = function () {\n        this._autofillMonitor.stopMonitoring(this._elementRef);\n    };\n    /** @nocollapse */\n    CdkAutofill.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: AutofillMonitor }\n    ]; };\n    CdkAutofill.propDecorators = {\n        cdkAutofill: [{ type: Output }]\n    };\nCdkAutofill.ɵfac = function CdkAutofill_Factory(t) { return new (t || CdkAutofill)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(AutofillMonitor)); };\nCdkAutofill.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkAutofill, selectors: [[\"\", \"cdkAutofill\", \"\"]], outputs: { cdkAutofill: \"cdkAutofill\" } });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkAutofill, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkAutofill]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: AutofillMonitor }]; }, { cdkAutofill: [{\n            type: Output\n        }] }); })();\n    return CdkAutofill;\n}());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Directive to automatically resize a textarea to fit its content. */\nvar CdkTextareaAutosize = /** @class */ (function () {\n    function CdkTextareaAutosize(_elementRef, _platform, _ngZone, \n    /** @breaking-change 11.0.0 make document required */\n    document) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new Subject();\n        this._enabled = true;\n        /**\n         * Value of minRows as of last resize. If the minRows has decreased, the\n         * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n         * does not have the same problem because it does not affect the textarea's scrollHeight.\n         */\n        this._previousMinRows = -1;\n        this._document = document;\n        this._textareaElement = this._elementRef.nativeElement;\n    }\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"minRows\", {\n        /** Minimum amount of rows in the textarea. */\n        get: function () { return this._minRows; },\n        set: function (value) {\n            this._minRows = coerceNumberProperty(value);\n            this._setMinHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"maxRows\", {\n        /** Maximum amount of rows in the textarea. */\n        get: function () { return this._maxRows; },\n        set: function (value) {\n            this._maxRows = coerceNumberProperty(value);\n            this._setMaxHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"enabled\", {\n        /** Whether autosizing is enabled or not */\n        get: function () { return this._enabled; },\n        set: function (value) {\n            value = coerceBooleanProperty(value);\n            // Only act if the actual value changed. This specifically helps to not run\n            // resizeToFitContent too early (i.e. before ngAfterViewInit)\n            if (this._enabled !== value) {\n                (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    CdkTextareaAutosize.prototype._setMinHeight = function () {\n        var minHeight = this.minRows && this._cachedLineHeight ?\n            this.minRows * this._cachedLineHeight + \"px\" : null;\n        if (minHeight) {\n            this._textareaElement.style.minHeight = minHeight;\n        }\n    };\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    CdkTextareaAutosize.prototype._setMaxHeight = function () {\n        var maxHeight = this.maxRows && this._cachedLineHeight ?\n            this.maxRows * this._cachedLineHeight + \"px\" : null;\n        if (maxHeight) {\n            this._textareaElement.style.maxHeight = maxHeight;\n        }\n    };\n    CdkTextareaAutosize.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this._platform.isBrowser) {\n            // Remember the height which we started with in case autosizing is disabled\n            this._initialHeight = this._textareaElement.style.height;\n            this.resizeToFitContent();\n            this._ngZone.runOutsideAngular(function () {\n                var window = _this._getWindow();\n                fromEvent(window, 'resize')\n                    .pipe(auditTime(16), takeUntil(_this._destroyed))\n                    .subscribe(function () { return _this.resizeToFitContent(true); });\n            });\n        }\n    };\n    CdkTextareaAutosize.prototype.ngOnDestroy = function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     */\n    CdkTextareaAutosize.prototype._cacheTextareaLineHeight = function () {\n        if (this._cachedLineHeight) {\n            return;\n        }\n        // Use a clone element because we have to override some styles.\n        var textareaClone = this._textareaElement.cloneNode(false);\n        textareaClone.rows = 1;\n        // Use `position: absolute` so that this doesn't cause a browser layout and use\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n        // would affect the height.\n        textareaClone.style.position = 'absolute';\n        textareaClone.style.visibility = 'hidden';\n        textareaClone.style.border = 'none';\n        textareaClone.style.padding = '0';\n        textareaClone.style.height = '';\n        textareaClone.style.minHeight = '';\n        textareaClone.style.maxHeight = '';\n        // In Firefox it happens that textarea elements are always bigger than the specified amount\n        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n        // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n        // to hidden. This ensures that there is no invalid calculation of the line height.\n        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n        textareaClone.style.overflow = 'hidden';\n        this._textareaElement.parentNode.appendChild(textareaClone);\n        this._cachedLineHeight = textareaClone.clientHeight;\n        this._textareaElement.parentNode.removeChild(textareaClone);\n        // Min and max heights have to be re-calculated if the cached line height changes\n        this._setMinHeight();\n        this._setMaxHeight();\n    };\n    CdkTextareaAutosize.prototype.ngDoCheck = function () {\n        if (this._platform.isBrowser) {\n            this.resizeToFitContent();\n        }\n    };\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    CdkTextareaAutosize.prototype.resizeToFitContent = function (force) {\n        var _this = this;\n        if (force === void 0) { force = false; }\n        // If autosizing is disabled, just skip everything else\n        if (!this._enabled) {\n            return;\n        }\n        this._cacheTextareaLineHeight();\n        // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n        // in checking the height of the textarea.\n        if (!this._cachedLineHeight) {\n            return;\n        }\n        var textarea = this._elementRef.nativeElement;\n        var value = textarea.value;\n        // Only resize if the value or minRows have changed since these calculations can be expensive.\n        if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n            return;\n        }\n        var placeholderText = textarea.placeholder;\n        // Reset the textarea height to auto in order to shrink back to its default size.\n        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n        // need to be removed temporarily.\n        textarea.classList.add('cdk-textarea-autosize-measuring');\n        textarea.placeholder = '';\n        // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with\n        // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n        var height = textarea.scrollHeight - 4;\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n        textarea.style.height = height + \"px\";\n        textarea.classList.remove('cdk-textarea-autosize-measuring');\n        textarea.placeholder = placeholderText;\n        this._ngZone.runOutsideAngular(function () {\n            if (typeof requestAnimationFrame !== 'undefined') {\n                requestAnimationFrame(function () { return _this._scrollToCaretPosition(textarea); });\n            }\n            else {\n                setTimeout(function () { return _this._scrollToCaretPosition(textarea); });\n            }\n        });\n        this._previousValue = value;\n        this._previousMinRows = this._minRows;\n    };\n    /**\n     * Resets the textarea to its original size\n     */\n    CdkTextareaAutosize.prototype.reset = function () {\n        // Do not try to change the textarea, if the initialHeight has not been determined yet\n        // This might potentially remove styles when reset() is called before ngAfterViewInit\n        if (this._initialHeight !== undefined) {\n            this._textareaElement.style.height = this._initialHeight;\n        }\n    };\n    // In Ivy the `host` metadata will be merged, whereas in ViewEngine it is overridden. In order\n    // to avoid double event listeners, we need to use `HostListener`. Once Ivy is the default, we\n    // can move this back into `host`.\n    // tslint:disable:no-host-decorator-in-concrete\n    CdkTextareaAutosize.prototype._noopInputHandler = function () {\n        // no-op handler that ensures we're running change detection on input events.\n    };\n    /** Access injected document if available or fallback to global document reference */\n    CdkTextareaAutosize.prototype._getDocument = function () {\n        return this._document || document;\n    };\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    CdkTextareaAutosize.prototype._getWindow = function () {\n        var doc = this._getDocument();\n        return doc.defaultView || window;\n    };\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     */\n    CdkTextareaAutosize.prototype._scrollToCaretPosition = function (textarea) {\n        var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;\n        var document = this._getDocument();\n        // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n        // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n        // between the time we requested the animation frame and when it was executed.\n        // Also note that we have to assert that the textarea is focused before we set the\n        // selection range. Setting the selection range on a non-focused textarea will cause\n        // it to receive focus on IE and Edge.\n        if (!this._destroyed.isStopped && document.activeElement === textarea) {\n            textarea.setSelectionRange(selectionStart, selectionEnd);\n        }\n    };\n    /** @nocollapse */\n    CdkTextareaAutosize.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Platform },\n        { type: NgZone },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    CdkTextareaAutosize.propDecorators = {\n        minRows: [{ type: Input, args: ['cdkAutosizeMinRows',] }],\n        maxRows: [{ type: Input, args: ['cdkAutosizeMaxRows',] }],\n        enabled: [{ type: Input, args: ['cdkTextareaAutosize',] }],\n        _noopInputHandler: [{ type: HostListener, args: ['input',] }]\n    };\nCdkTextareaAutosize.ɵfac = function CdkTextareaAutosize_Factory(t) { return new (t || CdkTextareaAutosize)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)); };\nCdkTextareaAutosize.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkTextareaAutosize, selectors: [[\"textarea\", \"cdkTextareaAutosize\", \"\"]], hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\"], hostBindings: function CdkTextareaAutosize_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function CdkTextareaAutosize_input_HostBindingHandler() { return ctx._noopInputHandler(); });\n    } }, inputs: { minRows: [\"cdkAutosizeMinRows\", \"minRows\"], maxRows: [\"cdkAutosizeMaxRows\", \"maxRows\"], enabled: [\"cdkTextareaAutosize\", \"enabled\"] }, exportAs: [\"cdkTextareaAutosize\"] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkTextareaAutosize, [{\n        type: Directive,\n        args: [{\n                selector: 'textarea[cdkTextareaAutosize]',\n                exportAs: 'cdkTextareaAutosize',\n                host: {\n                    'class': 'cdk-textarea-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1'\n                }\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, { minRows: [{\n            type: Input,\n            args: ['cdkAutosizeMinRows']\n        }], maxRows: [{\n            type: Input,\n            args: ['cdkAutosizeMaxRows']\n        }], enabled: [{\n            type: Input,\n            args: ['cdkTextareaAutosize']\n        }], _noopInputHandler: [{\n            type: HostListener,\n            args: ['input']\n        }] }); })();\n    return CdkTextareaAutosize;\n}());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TextFieldModule = /** @class */ (function () {\n    function TextFieldModule() {\n    }\nTextFieldModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TextFieldModule });\nTextFieldModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TextFieldModule_Factory(t) { return new (t || TextFieldModule)(); }, imports: [[PlatformModule]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextFieldModule, { declarations: function () { return [CdkAutofill,\n        CdkTextareaAutosize]; }, imports: function () { return [PlatformModule]; }, exports: function () { return [CdkAutofill,\n        CdkTextareaAutosize]; } }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TextFieldModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [CdkAutofill, CdkTextareaAutosize],\n                imports: [PlatformModule],\n                exports: [CdkAutofill, CdkTextareaAutosize]\n            }]\n    }], function () { return []; }, null); })();\n    return TextFieldModule;\n}());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n\n//# sourceMappingURL=text-field.js.map","import { __extends } from 'tslib';\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Optional, Self, Inject, NgZone, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { NgControl, NgForm, FormGroupDirective } from '@angular/forms';\nimport { mixinErrorState, ErrorStateMatcher } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.\n * @breaking-change 8.0.0\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@angular/material/core';\nimport * as ɵngcc4 from '@angular/cdk/text-field';\nvar MatTextareaAutosize = /** @class */ (function (_super) {\n    __extends(MatTextareaAutosize, _super);\n    function MatTextareaAutosize() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMinRows\", {\n        get: function () { return this.minRows; },\n        set: function (value) { this.minRows = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMaxRows\", {\n        get: function () { return this.maxRows; },\n        set: function (value) { this.maxRows = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosize\", {\n        get: function () { return this.enabled; },\n        set: function (value) { this.enabled = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matTextareaAutosize\", {\n        get: function () { return this.enabled; },\n        set: function (value) { this.enabled = value; },\n        enumerable: true,\n        configurable: true\n    });\n    MatTextareaAutosize.propDecorators = {\n        matAutosizeMinRows: [{ type: Input }],\n        matAutosizeMaxRows: [{ type: Input }],\n        matAutosize: [{ type: Input, args: ['mat-autosize',] }],\n        matTextareaAutosize: [{ type: Input }]\n    };\nMatTextareaAutosize.ɵfac = function MatTextareaAutosize_Factory(t) { return ɵMatTextareaAutosize_BaseFactory(t || MatTextareaAutosize); };\nMatTextareaAutosize.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatTextareaAutosize, selectors: [[\"textarea\", \"mat-autosize\", \"\"], [\"textarea\", \"matTextareaAutosize\", \"\"]], hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\", \"mat-autosize\"], inputs: { cdkAutosizeMinRows: \"cdkAutosizeMinRows\", cdkAutosizeMaxRows: \"cdkAutosizeMaxRows\", matAutosizeMinRows: \"matAutosizeMinRows\", matAutosizeMaxRows: \"matAutosizeMaxRows\", matAutosize: [\"mat-autosize\", \"matAutosize\"], matTextareaAutosize: \"matTextareaAutosize\" }, exportAs: [\"matTextareaAutosize\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\nvar ɵMatTextareaAutosize_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatTextareaAutosize);\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTextareaAutosize, [{\n        type: Directive,\n        args: [{\n                selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n                exportAs: 'matTextareaAutosize',\n                inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n                host: {\n                    'class': 'cdk-textarea-autosize mat-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1'\n                }\n            }]\n    }], null, { matAutosizeMinRows: [{\n            type: Input\n        }], matAutosizeMaxRows: [{\n            type: Input\n        }], matAutosize: [{\n            type: Input,\n            args: ['mat-autosize']\n        }], matTextareaAutosize: [{\n            type: Input\n        }] }); })();\n    return MatTextareaAutosize;\n}(CdkTextareaAutosize));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(\"Input type \\\"\" + type + \"\\\" isn't supported by matInput.\");\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nvar MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nvar MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit'\n];\nvar nextUniqueId = 0;\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nvar MatInputBase = /** @class */ (function () {\n    function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, \n    /** @docs-private */\n    ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n    return MatInputBase;\n}());\nvar _MatInputMixinBase = mixinErrorState(MatInputBase);\n/** Directive that allows a native input to work inside a `MatFormField`. */\nvar MatInput = /** @class */ (function (_super) {\n    __extends(MatInput, _super);\n    function MatInput(_elementRef, _platform, \n    /** @docs-private */\n    ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n        var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n        _this._elementRef = _elementRef;\n        _this._platform = _platform;\n        _this.ngControl = ngControl;\n        _this._autofillMonitor = _autofillMonitor;\n        _this._uid = \"mat-input-\" + nextUniqueId++;\n        /** Whether the component is being rendered on the server. */\n        _this._isServer = false;\n        /** Whether the component is a native html select. */\n        _this._isNativeSelect = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        _this.focused = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        _this.stateChanges = new Subject();\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        _this.controlType = 'mat-input';\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        _this.autofilled = false;\n        _this._disabled = false;\n        _this._required = false;\n        _this._type = 'text';\n        _this._readonly = false;\n        _this._neverEmptyInputTypes = [\n            'date',\n            'datetime',\n            'datetime-local',\n            'month',\n            'time',\n            'week'\n        ].filter(function (t) { return getSupportedInputTypes().has(t); });\n        var element = _this._elementRef.nativeElement;\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        _this._inputValueAccessor = inputValueAccessor || element;\n        _this._previousNativeValue = _this.value;\n        // Force setter to be called in case id was not specified.\n        _this.id = _this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (_platform.IOS) {\n            ngZone.runOutsideAngular(function () {\n                _elementRef.nativeElement.addEventListener('keyup', function (event) {\n                    var el = event.target;\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                        // `1, 1` fixes it for the first time that you type text and\n                        // then hold delete. Toggling to `1, 1` and then back to\n                        // `0, 0` seems to completely fix it.\n                        el.setSelectionRange(1, 1);\n                        el.setSelectionRange(0, 0);\n                    }\n                });\n            });\n        }\n        _this._isServer = !_this._platform.isBrowser;\n        _this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\n        if (_this._isNativeSelect) {\n            _this.controlType = element.multiple ? 'mat-native-select-multiple' :\n                'mat-native-select';\n        }\n        return _this;\n    }\n    Object.defineProperty(MatInput.prototype, \"disabled\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: function () {\n            if (this.ngControl && this.ngControl.disabled !== null) {\n                return this.ngControl.disabled;\n            }\n            return this._disabled;\n        },\n        set: function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            // Browsers may not fire the blur event if the input is disabled too quickly.\n            // Reset from here to ensure that the element doesn't become stuck.\n            if (this.focused) {\n                this.focused = false;\n                this.stateChanges.next();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"id\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: function () { return this._id; },\n        set: function (value) { this._id = value || this._uid; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"required\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: function () { return this._required; },\n        set: function (value) { this._required = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"type\", {\n        /** Input type of the element. */\n        get: function () { return this._type; },\n        set: function (value) {\n            this._type = value || 'text';\n            this._validateType();\n            // When using Angular inputs, developers are no longer able to set the properties on the native\n            // input element. To ensure that bindings for `type` work, we need to sync the setter\n            // with the native property. Textarea elements don't support the type property or attribute.\n            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n                this._elementRef.nativeElement.type = this._type;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"value\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: function () { return this._inputValueAccessor.value; },\n        set: function (value) {\n            if (value !== this.value) {\n                this._inputValueAccessor.value = value;\n                this.stateChanges.next();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"readonly\", {\n        /** Whether the element is readonly. */\n        get: function () { return this._readonly; },\n        set: function (value) { this._readonly = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    MatInput.prototype.ngOnInit = function () {\n        var _this = this;\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n                _this.autofilled = event.isAutofilled;\n                _this.stateChanges.next();\n            });\n        }\n    };\n    MatInput.prototype.ngOnChanges = function () {\n        this.stateChanges.next();\n    };\n    MatInput.prototype.ngOnDestroy = function () {\n        this.stateChanges.complete();\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n    };\n    MatInput.prototype.ngDoCheck = function () {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n    };\n    /** Focuses the input. */\n    MatInput.prototype.focus = function (options) {\n        this._elementRef.nativeElement.focus(options);\n    };\n    /** Callback for the cases where the focused state of the input changes. */\n    MatInput.prototype._focusChanged = function (isFocused) {\n        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n            this.focused = isFocused;\n            this.stateChanges.next();\n        }\n    };\n    MatInput.prototype._onInput = function () {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    };\n    /** Determines if the component host is a textarea. */\n    MatInput.prototype._isTextarea = function () {\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n    };\n    /** Does some manual dirty checking on the native input `value` property. */\n    MatInput.prototype._dirtyCheckNativeValue = function () {\n        var newValue = this._elementRef.nativeElement.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    };\n    /** Make sure the input is a supported type. */\n    MatInput.prototype._validateType = function () {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    };\n    /** Checks whether the input type is one of the types that are never empty. */\n    MatInput.prototype._isNeverEmpty = function () {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    };\n    /** Checks whether the input is invalid based on the native validation. */\n    MatInput.prototype._isBadInput = function () {\n        // The `validity` property won't be present on platform-server.\n        var validity = this._elementRef.nativeElement.validity;\n        return validity && validity.badInput;\n    };\n    Object.defineProperty(MatInput.prototype, \"empty\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: function () {\n            return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n                !this.autofilled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"shouldLabelFloat\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: function () {\n            if (this._isNativeSelect) {\n                // For a single-selection `<select>`, the label should float when the selected option has\n                // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n                // overlapping the label with the options.\n                var selectElement = this._elementRef.nativeElement;\n                var firstOption = selectElement.options[0];\n                // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n                // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n                return this.focused || selectElement.multiple || !this.empty ||\n                    !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n            }\n            else {\n                return this.focused || !this.empty;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    MatInput.prototype.setDescribedByIds = function (ids) {\n        this._ariaDescribedby = ids.join(' ');\n    };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    MatInput.prototype.onContainerClick = function () {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n            this.focus();\n        }\n    };\n    /** @nocollapse */\n    MatInput.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Platform },\n        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },\n        { type: NgForm, decorators: [{ type: Optional }] },\n        { type: FormGroupDirective, decorators: [{ type: Optional }] },\n        { type: ErrorStateMatcher },\n        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },\n        { type: AutofillMonitor },\n        { type: NgZone }\n    ]; };\n    MatInput.propDecorators = {\n        disabled: [{ type: Input }],\n        id: [{ type: Input }],\n        placeholder: [{ type: Input }],\n        required: [{ type: Input }],\n        type: [{ type: Input }],\n        errorStateMatcher: [{ type: Input }],\n        value: [{ type: Input }],\n        readonly: [{ type: Input }]\n    };\nMatInput.ɵfac = function MatInput_Factory(t) { return new (t || MatInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AutofillMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nMatInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatInput, selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]], hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"], hostVars: 10, hostBindings: function MatInput_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"blur\", function MatInput_blur_HostBindingHandler() { return ctx._focusChanged(false); })(\"focus\", function MatInput_focus_HostBindingHandler() { return ctx._focusChanged(true); })(\"input\", function MatInput_input_HostBindingHandler() { return ctx._onInput(); });\n    } if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required);\n        ɵngcc0.ɵɵattribute(\"id\", ctx.id)(\"placeholder\", ctx.placeholder)(\"readonly\", ctx.readonly && !ctx._isNativeSelect || null)(\"aria-describedby\", ctx._ariaDescribedby || null)(\"aria-invalid\", ctx.errorState)(\"aria-required\", ctx.required.toString());\n        ɵngcc0.ɵɵclassProp(\"mat-input-server\", ctx._isServer);\n    } }, inputs: { disabled: \"disabled\", id: \"id\", required: \"required\", type: \"type\", value: \"value\", readonly: \"readonly\", placeholder: \"placeholder\", errorStateMatcher: \"errorStateMatcher\" }, exportAs: [\"matInput\"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: MatFormFieldControl, useExisting: MatInput }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatInput, [{\n        type: Directive,\n        args: [{\n                selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\",\n                exportAs: 'matInput',\n                host: {\n                    /**\n                     * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n                     */\n                    'class': 'mat-input-element mat-form-field-autofill-control',\n                    '[class.mat-input-server]': '_isServer',\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\n                    // the native input element. Otherwise property bindings for those don't work.\n                    '[attr.id]': 'id',\n                    '[attr.placeholder]': 'placeholder',\n                    '[disabled]': 'disabled',\n                    '[required]': 'required',\n                    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n                    '[attr.aria-describedby]': '_ariaDescribedby || null',\n                    '[attr.aria-invalid]': 'errorState',\n                    '[attr.aria-required]': 'required.toString()',\n                    '(blur)': '_focusChanged(false)',\n                    '(focus)': '_focusChanged(true)',\n                    '(input)': '_onInput()'\n                },\n                providers: [{ provide: MatFormFieldControl, useExisting: MatInput }]\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: ɵngcc2.NgControl, decorators: [{\n                type: Optional\n            }, {\n                type: Self\n            }] }, { type: ɵngcc2.NgForm, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc2.FormGroupDirective, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc3.ErrorStateMatcher }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Self\n            }, {\n                type: Inject,\n                args: [MAT_INPUT_VALUE_ACCESSOR]\n            }] }, { type: ɵngcc4.AutofillMonitor }, { type: ɵngcc0.NgZone }]; }, { disabled: [{\n            type: Input\n        }], id: [{\n            type: Input\n        }], required: [{\n            type: Input\n        }], type: [{\n            type: Input\n        }], value: [{\n            type: Input\n        }], readonly: [{\n            type: Input\n        }], placeholder: [{\n            type: Input\n        }], errorStateMatcher: [{\n            type: Input\n        }] }); })();\n    return MatInput;\n}(_MatInputMixinBase));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar MatInputModule = /** @class */ (function () {\n    function MatInputModule() {\n    }\nMatInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatInputModule });\nMatInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatInputModule_Factory(t) { return new (t || MatInputModule)(); }, providers: [ErrorStateMatcher], imports: [[\n            TextFieldModule,\n            MatFormFieldModule,\n        ],\n        TextFieldModule,\n        // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n        // be used together with `MatFormField`.\n        MatFormFieldModule] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatInputModule, { declarations: function () { return [MatInput,\n        MatTextareaAutosize]; }, imports: function () { return [TextFieldModule,\n        MatFormFieldModule]; }, exports: function () { return [TextFieldModule,\n        // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n        // be used together with `MatFormField`.\n        MatFormFieldModule,\n        MatInput,\n        MatTextareaAutosize]; } }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatInputModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [MatInput, MatTextareaAutosize],\n                imports: [\n                    TextFieldModule,\n                    MatFormFieldModule,\n                ],\n                exports: [\n                    TextFieldModule,\n                    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n                    // be used together with `MatFormField`.\n                    MatFormFieldModule,\n                    MatInput,\n                    MatTextareaAutosize,\n                ],\n                providers: [ErrorStateMatcher]\n            }]\n    }], function () { return []; }, null); })();\n    return MatInputModule;\n}());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, MatTextareaAutosize, getMatInputUnsupportedTypeError };\n\n//# sourceMappingURL=input.js.map","<ng-container *ngIf=\"loaded$ | async\"></ng-container>\r\n","import { Component, OnInit, OnDestroy, ViewContainerRef } from '@angular/core';\r\nimport { Router, ActivatedRoute } from '@angular/router';\r\nimport { MatDialogRef, MatDialog } from '@angular/material/dialog';\r\nimport { BehaviorSubject } from 'rxjs';\r\nimport { take } from 'rxjs/operators';\r\n\r\nimport { Context } from '../../services/context';\r\nimport { DialogConfig } from '../../models/dialog-config.model';\r\nimport { angularConsoleLog } from '../../helpers/angular-console-log.helper';\r\n\r\n@Component({\r\n  selector: 'app-dialog-entry',\r\n  templateUrl: './dialog-entry.component.html',\r\n  styleUrls: ['./dialog-entry.component.scss']\r\n})\r\nexport class DialogEntryComponent implements OnInit, OnDestroy {\r\n  /** Forces change detection when dialog is async loaded */\r\n  loaded$ = new BehaviorSubject<boolean>(false);\r\n\r\n  private dialogData: { [key: string]: any; };\r\n  private dialogRef: MatDialogRef<any>;\r\n\r\n  constructor(\r\n    private dialog: MatDialog,\r\n    private viewContainerRef: ViewContainerRef,\r\n    private router: Router,\r\n    private route: ActivatedRoute,\r\n    private context: Context,\r\n  ) {\r\n    const navigation = this.router.getCurrentNavigation();\r\n    this.dialogData = navigation?.extras?.state || {};\r\n  }\r\n\r\n  ngOnInit() {\r\n    const dialogConfig: DialogConfig = this.route.snapshot.data.dialog;\r\n    if (dialogConfig == null) {\r\n      throw new Error(`Could not find config for dialog. Did you forget to add DialogConfig to route data?`);\r\n    }\r\n    angularConsoleLog('Open dialog:', dialogConfig.name, 'Context id:', this.context.id, 'Context:', this.context);\r\n\r\n    dialogConfig.getComponent().then(component => {\r\n      if (dialogConfig.initContext) {\r\n        this.context.init(this.route);\r\n      }\r\n\r\n      this.dialogRef = this.dialog.open(component, {\r\n        data: this.dialogData,\r\n        backdropClass: 'dialog-backdrop',\r\n        panelClass: [\r\n          'dialog-panel',\r\n          `dialog-panel-${dialogConfig.panelSize}`,\r\n          dialogConfig.showScrollbar ? 'show-scrollbar' : 'no-scrollbar',\r\n          ...(dialogConfig.panelClass ? dialogConfig.panelClass : []),\r\n        ],\r\n        viewContainerRef: this.viewContainerRef,\r\n        autoFocus: false,\r\n        closeOnNavigation: false,\r\n        // spm NOTE: used to force align-items: flex-start; on cdk-global-overlay-wrapper.\r\n        // Real top margin is overwritten in css e.g. dialog-panel-large\r\n        position: { top: '0' }\r\n      });\r\n\r\n      this.dialogRef.afterClosed().pipe(take(1)).subscribe((data: any) => {\r\n        angularConsoleLog('Dialog was closed:', dialogConfig.name, 'Data:', data);\r\n\r\n        if (this.route.pathFromRoot.length <= 3) {\r\n          try {\r\n            (window.parent as any).$2sxc.totalPopup.close();\r\n          } catch (error) { }\r\n          return;\r\n        }\r\n\r\n        if (this.route.snapshot.url.length > 0) {\r\n          this.router.navigate(['./'], { relativeTo: this.route.parent, state: data });\r\n        } else {\r\n          this.router.navigate(['./'], { relativeTo: this.route.parent.parent, state: data });\r\n        }\r\n      });\r\n\r\n      this.loaded$.next(true);\r\n    });\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.loaded$.complete();\r\n    this.dialogRef.close();\r\n  }\r\n\r\n}\r\n"],"sourceRoot":"webpack:///"}