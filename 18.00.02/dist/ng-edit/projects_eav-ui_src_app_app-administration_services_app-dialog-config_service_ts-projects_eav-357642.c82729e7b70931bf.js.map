{"version":3,"file":"projects_eav-ui_src_app_app-administration_services_app-dialog-config_service_ts-projects_eav-357642.c82729e7b70931bf.js","mappings":"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","names":["AppDialogConfigService","constructor","contextSvcShared","context","this","log","EavLogger","getCurrent$","appId","a","getShared$","static","t","i0","i1","i2","_angular_core__WEBPACK_IMPORTED_MODULE_3__","jDH","factory","ɵfac","GlobalDialogConfigService","http","globalConfigService","dialogSettings$","svcId","getDialogSettings","pipe","shareReplay","refCount","reqBy","get","params","toString","map","dlgSettings","Context","Language","List","filter","language","IsEnabled","tap","allowDebug","Enable","DebugMode","i3","_angular_core__WEBPACK_IMPORTED_MODULE_6__","providedIn","GlobalConfigService","snackBar","debugState","signal","isDebug","computed","allowDebugMode","debugEnabled","debugEnabled$","toObservable","initial","id","sessionStorage","getItem","keyDebug","set","allow","oldConfig","newConfig","toggleDebugEnabled","open","duration","_angular_core__WEBPACK_IMPORTED_MODULE_1__","visualQueryRoutes","path","loadComponent","Promise","all","__webpack_require__","e","then","bind","m","VisualQueryComponent","children","GoToDevRest","route","EditRoutesNoHistory","source","options","injector","assertInInjectionContext","inject","Injector","subject","ReplaySubject","watcher","effect","value","err","untracked","error","next","manualCleanup","DestroyRef","onDestroy","destroy","complete","asObservable","toSignal","requiresCleanup","cleanupRef","state","requireSync","kind","initialValue","sub","subscribe","rejectErrors","unsubscribe","current","ɵRuntimeError"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./projects/eav-ui/src/app/app-administration/services/app-dialog-config.service.ts","./projects/eav-ui/src/app/app-administration/services/global-dialog-config.service.ts","./projects/eav-ui/src/app/shared/services/global-config.service.ts","./projects/eav-ui/src/app/visual-query/visual-query.routing.ts","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { DialogSettings } from '../../shared/models/dialog-settings.model';\r\nimport { Context } from '../../shared/services/context';\r\nimport { EavLogger } from '../../shared/logging/eav-logger';\r\nimport { GlobalDialogConfigService } from './global-dialog-config.service';\r\n\r\nconst logThis = false;\r\nconst nameOfThis = 'DialogConfigService';\r\n\r\n/**\r\n * Context aware dialog configuration service.\r\n * \r\n * It uses the shared service so the settings are cached when re-requested by anything else.\r\n */\r\n@Injectable()\r\nexport class AppDialogConfigService {\r\n\r\n  log = new EavLogger(nameOfThis, logThis);\r\n\r\n  constructor(private contextSvcShared: GlobalDialogConfigService, private context: Context) {\r\n  }\r\n\r\n  getCurrent$(): Observable<DialogSettings> {\r\n    const appId = this.context.appId;\r\n    this.log.a(`getCurrent\\$ - appId:${appId}`);\r\n    return this.contextSvcShared.getShared$(appId);\r\n  }\r\n}\r\n","import { HttpClient } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { map, Observable, shareReplay, tap } from 'rxjs';\r\nimport { DialogSettings } from '../../shared/models/dialog-settings.model';\r\nimport { Context } from '../../shared/services/context';\r\nimport { EavLogger } from '../../shared/logging/eav-logger';\r\nimport { GlobalConfigService } from '../../shared/services/global-config.service';\r\n\r\nconst logThis = false;\r\nconst nameOfThis = 'GlobalDialogConfigService';\r\n\r\nconst webApiSettings = 'admin/dialog/settings';\r\n\r\n/**\r\n * Service for getting dialog settings for the current app.\r\n * \r\n * Note that it should normally be shared, to save resources / network calls.\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class GlobalDialogConfigService {\r\n\r\n  log = new EavLogger(nameOfThis, logThis);\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    private context: Context,\r\n    private globalConfigService: GlobalConfigService,\r\n  ) {\r\n    this.log.a(`using context #${this.context.log.svcId}`);\r\n  }\r\n\r\n  private dialogSettings$: Record<number, Observable<DialogSettings>> = {};\r\n\r\n  getShared$(appId: number): Observable<DialogSettings> {\r\n    this.log.a('getShared$ appId: ' + appId);\r\n    this.dialogSettings$[appId] ??= this.getDialogSettings(appId, 'getShared$')\r\n      .pipe(shareReplay({ refCount: false }));\r\n    return this.dialogSettings$[appId];\r\n  }\r\n\r\n  private getDialogSettings(appId?: number, reqBy?: string): Observable<DialogSettings> {\r\n    this.log.a('getDialogSettings', {appId, reqBy});\r\n    return this.http.get<DialogSettings>(webApiSettings, {\r\n      params: { appId: appId ?? this.context.appId.toString() },\r\n    }).pipe(\r\n      map(dlgSettings => {\r\n        dlgSettings.Context.Language.List = dlgSettings.Context.Language.List.filter(language => language.IsEnabled);\r\n        return dlgSettings;\r\n      }),\r\n      tap(dlgSettings => {\r\n        this.globalConfigService.allowDebug(dlgSettings.Context.Enable.DebugMode);\r\n      }),\r\n    );\r\n  }\r\n}\r\n","import { Injectable, computed, signal } from '@angular/core';\r\nimport { MatSnackBar } from '@angular/material/snack-bar';\r\nimport { toObservable } from '@angular/core/rxjs-interop';\r\nimport { keyDebug } from '../constants/session.constants';\r\n\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class GlobalConfigService {\r\n\r\n  private debugState = signal<GlobalConfig>(null);\r\n\r\n  isDebug = computed(() => !!this.debugState()?.allowDebugMode && !!this.debugState()?.debugEnabled);\r\n\r\n  /** This observable is a left-over, try to remove once more is refactored */\r\n  debugEnabled$ = toObservable(this.isDebug);\r\n\r\n  constructor(private snackBar: MatSnackBar) {\r\n    const initial: GlobalConfig = {\r\n      id: 0,\r\n      debugEnabled: sessionStorage.getItem(keyDebug) === 'true',\r\n      allowDebugMode: false,\r\n    };\r\n    this.debugState.set(initial);\r\n  }\r\n\r\n  allowDebug(allow: boolean): void {\r\n    const oldConfig = this.debugState();\r\n    if (oldConfig.allowDebugMode === allow)\r\n      return;\r\n\r\n    const newConfig: GlobalConfig = {\r\n      ...oldConfig,\r\n      allowDebugMode: allow,\r\n    };\r\n    this.debugState.set(newConfig);\r\n  }\r\n\r\n  toggleDebugEnabled(): void {\r\n    const oldConfig = this.debugState();\r\n    if (!oldConfig.allowDebugMode) {\r\n      this.snackBar.open('You do not have permissions to enter developer mode', null, { duration: 3000 });\r\n      return;\r\n    }\r\n\r\n    const newConfig: GlobalConfig = {\r\n      ...oldConfig,\r\n      debugEnabled: !oldConfig.debugEnabled,\r\n    };\r\n    this.debugState.set(newConfig);\r\n    this.snackBar.open(newConfig.debugEnabled ? 'developer mode on' : 'developer mode off', null, { duration: 3000 });\r\n  }\r\n}\r\n\r\ninterface GlobalConfig {\r\n  id: 0;\r\n  debugEnabled: boolean;\r\n  allowDebugMode: boolean;\r\n}\r\n","import { Routes } from '@angular/router';\r\nimport { GoToDevRest } from '../dev-rest';\r\nimport { EditRoutesNoHistory } from '../edit/edit.routing';\r\n\r\nexport const visualQueryRoutes: Routes = [\r\n  {\r\n    path: '',\r\n    loadComponent: () => import('./visual-query.component').then(m => m.VisualQueryComponent),\r\n    children: [\r\n      GoToDevRest.route,\r\n      ...EditRoutesNoHistory,\r\n    ]\r\n  },\r\n];\r\n\r\n","/**\n * @license Angular v17.3.11\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    constructor(source) {\n        this.source = source;\n        this.destroyed = false;\n        this.destroyRef = inject(DestroyRef);\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: value => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n    const destroyRef = ɵgetOutputDestroyRef(ref);\n    return new Observable(observer => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe(v => observer.next(v));\n        return () => subscription.unsubscribe();\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n"],"x_google_ignoreList":[4]}