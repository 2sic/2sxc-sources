{"version":3,"file":"default-node_modules_angular_material_fesm2022_dialog_mjs.18dbbfc5a091b699.js","mappings":"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","names":["nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","resultSelector","isFunction","undefined","pipe","mapOneOrManyArgs","add","remove","isEventTarget","addEventListener","removeEventListener","map","methodName","handler","isNodeStyleEventEmitter","addListener","removeListener","toCommonHandlerRegistry","isJQueryStyleEventEmitter","on","off","isArrayLike","mergeMap","subTarget","innerFrom","TypeError","Observable","subscriber","args","next","length","timer","dueTime","intervalOrScheduler","scheduler","asyncScheduler","intervalDuration","isScheduler","due","isValidDate","value","Date","isNaN","now","n","schedule","closed","this","complete","pairwise","operate","source","prev","hasPrev","subscribe","createOperatorSubscriber","p","animationFrameProvider","callback","request","requestAnimationFrame","cancel","cancelAnimationFrame","delegate","handle","timestamp","Subscription","animationFrameScheduler","AnimationFrameScheduler","AsyncScheduler","flush","action","_active","flushId","_scheduled","actions","error","shift","execute","state","delay","id","unsubscribe","AnimationFrameAction","AsyncAction","constructor","work","super","requestAsyncId","push","recycleAsyncId","_a","resolved","nextHandle","activeHandles","findAndClearHandle","Immediate","setImmediate","cb","Promise","resolve","then","clearImmediate","immediateProvider","asapScheduler","AsapScheduler","AsapAction","bind","DataSource","isDataSource","connect","ConnectableObservable","ArrayDataSource","_data","isObservable","of","disconnect","_ViewRepeaterOperation","REPLACED","INSERTED","MOVED","REMOVED","_VIEW_REPEATER_STRATEGY","InjectionToken","_DisposeViewRepeaterStrategy","applyChanges","changes","viewContainerRef","itemContextFactory","itemValueResolver","itemViewChanged","forEachOperation","record","adjustedPreviousIndex","currentIndex","view","operation","previousIndex","insertContext","createEmbeddedView","templateRef","context","index","get","move","detach","_RecycleViewRepeaterStrategy","viewCacheSize","_viewCache","_insertView","viewArgsFactory","_detachAndCacheView","_moveView","destroy","cachedView","_insertViewFromCache","$implicit","viewArgs","detachedView","_maybeCacheView","indexOf","pop","insert","SelectionModel","selected","_selected","Array","from","_selection","values","_multiple","initiallySelectedValues","_emitChanges","compareWith","Set","_deselectedToEmit","_selectedToEmit","changed","Subject","forEach","_markSelected","select","_verifyValueAssignment","_hasQueuedChanges","_emitChangeEvent","deselect","_unmarkSelected","setSelection","oldValues","newSelectedSet","filter","has","_getConcreteValue","toggle","isSelected","clear","flushEvent","_unmarkAll","isEmpty","size","hasValue","sort","predicate","isMultipleSelection","added","removed","delete","inputValue","selection","selectedValue","UniqueSelectionDispatcher","_listeners","notify","name","listener","listen","registered","ngOnDestroy","static","fac","t","prov","i0","token","factory","providedIn","scrollBehaviorSupported","supportsScrollBehavior","BlockScrollStrategy","_viewportRuler","document","_previousHTMLStyles","top","left","_isEnabled","_document","attach","enable","_canBeEnabled","root","documentElement","_previousScrollPosition","getViewportScrollPosition","style","coerceCssPixelValue","classList","disable","html","htmlStyle","bodyStyle","body","previousHtmlScrollBehavior","scrollBehavior","previousBodyScrollBehavior","window","scroll","contains","viewport","getViewportSize","scrollHeight","height","scrollWidth","width","CloseScrollStrategy","_scrollDispatcher","_ngZone","_config","_scrollSubscription","_detach","_overlayRef","hasAttached","run","overlayRef","stream","scrolled","scrollable","overlayElement","getElementRef","nativeElement","threshold","_initialScrollPosition","scrollPosition","Math","abs","updatePosition","NoopScrollStrategy","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","bottom","right","isElementClippedByScrolling","scrollContainerRect","RepositionScrollStrategy","scrollThrottle","autoClose","overlayRect","getBoundingClientRect","ScrollStrategyOptions","noop","close","config","block","reposition","i1","DOCUMENT","OverlayConfig","scrollStrategy","panelClass","hasBackdrop","backdropClass","disposeOnNavigation","configKeys","Object","keys","key","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","BaseOverlayDispatcher","_attachedOverlays","splice","OverlayKeyboardDispatcher","_keydownListener","event","overlays","i","_keydownEvents","observers","keydownEvents","_isAttached","runOutsideAngular","OverlayOutsideClickDispatcher","_platform","_cursorStyleIsSet","_pointerDownListener","_pointerDownEventTarget","_getEventTarget","_clickListener","origin","type","slice","_outsidePointerEvents","outsidePointerEvents","_addEventListeners","IOS","_cursorOriginalValue","cursor","i1$1","OverlayContainer","_containerElement","getContainerElement","_createContainer","containerClass","isBrowser","_isTestEnvironment","oppositePlatformContainers","querySelectorAll","container","createElement","setAttribute","appendChild","OverlayRef","_portalOutlet","_host","_pane","_keyboardDispatcher","_location","_outsideClickDispatcher","_animationsDisabled","_backdropElement","_backdropClick","_attachments","_detachments","_locationChanges","EMPTY","_backdropClickHandler","_backdropTransitionendHandler","_disposeBackdrop","_scrollStrategy","_positionStrategy","positionStrategy","backdropElement","hostElement","portal","parentElement","_previousHostParent","attachResult","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","take","_togglePointerEvents","_attachBackdrop","_toggleClasses","dispose","onDestroy","detachBackdrop","detachmentResult","_detachContentWhenStable","isAttached","_disposeScrollStrategy","backdropClick","attachments","detachments","getConfig","apply","updatePositionStrategy","strategy","updateSize","sizeConfig","setDirection","dir","direction","addPanelClass","classes","removePanelClass","getDirection","updateScrollStrategy","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","showingClass","insertBefore","nextSibling","parentNode","backdropToDetach","_backdropTimeout","setTimeout","cssClasses","isAdd","coerceArray","c","subscription","takeUntil","merge","children","backdrop","clearTimeout","boundingBoxClass","cssUnitPattern","FlexibleConnectedPositionStrategy","positions","_preferredPositions","connectedTo","_overlayContainer","_lastBoundingBoxSize","_isPushed","_canPush","_growAfterOpen","_hasFlexibleDimensions","_positionLocked","_viewportMargin","_scrollables","_positionChanges","_resizeSubscription","_offsetX","_offsetY","_appliedPanelClasses","positionChanges","setOrigin","_validatePositions","_boundingBox","_isDisposed","_isInitialRender","_lastPosition","change","reapplyLastPosition","_clearPanelClasses","_resetOverlayElementStyles","_resetBoundingBoxStyles","_viewportRect","_getNarrowedViewportRect","_originRect","_getOriginRect","_overlayRect","_containerRect","originRect","viewportRect","containerRect","flexibleFits","fallback","pos","originPoint","_getOriginPoint","overlayPoint","_getOverlayPoint","overlayFit","_getOverlayFit","isCompletelyWithinViewport","_applyPosition","_canFitWithFlexibleDimensions","position","boundingBoxRect","_calculateBoundingBoxRect","visibleArea","bestFit","bestScore","fit","score","weight","_previousPushAmount","extendStyles","alignItems","justifyContent","lastPosition","withScrollableContainers","scrollables","withPositions","withViewportMargin","margin","withFlexibleDimensions","flexibleDimensions","withGrowAfterOpen","growAfterOpen","withPush","canPush","withLockedPosition","isLocked","_origin","withDefaultOffsetX","offset","withDefaultOffsetY","withTransformOriginOn","selector","_transformOriginSelector","x","y","originX","startX","_isRtl","endX","originY","overlayStartX","overlayStartY","overlayX","overlayY","point","rawOverlayRect","overlay","getRoundedBoundingClientRect","offsetX","_getOffset","offsetY","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","fitsInViewportVertically","fitsInViewportHorizontally","availableHeight","availableWidth","getPixelValue","_pushOverlayOnScreen","start","overflowRight","max","overflowBottom","overflowTop","overflowLeft","pushX","pushY","_setTransformOrigin","_setOverlayElementStyles","_setBoundingBoxStyles","_addPanelClasses","scrollVisibility","_getScrollVisibility","_lastScrollVisibility","compareScrollVisibility","a","b","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","changeEvent","elements","xOrigin","yOrigin","transformOrigin","isRtl","smallestDistanceToViewportEdge","min","previousHeight","previousWidth","styles","_hasExactPosition","transform","hasExactPosition","hasFlexibleDimensions","_getExactOverlayY","_getExactOverlayX","transformString","trim","clientHeight","horizontalStyleProperty","clientWidth","originBounds","overlayBounds","scrollContainerBounds","overflows","reduce","currentValue","currentOverflow","axis","cssClass","ElementRef","Element","destination","hasOwnProperty","input","units","split","parseFloat","clientRect","floor","wrapperClass","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_alignItems","_xPosition","_xOffset","_width","_height","end","centerHorizontally","centerVertically","parentStyles","shouldBeFlushHorizontally","shouldBeFlushVertically","xPosition","xOffset","marginLeft","marginRight","marginTop","marginBottom","parent","OverlayPositionBuilder","global","flexibleConnectedTo","nextUniqueId","Overlay","scrollStrategies","_componentFactoryResolver","_positionBuilder","_injector","_directionality","_animationsModuleType","create","host","_createHostElement","pane","_createPaneElement","portalOutlet","_createPortalOutlet","overlayConfig","_appRef","ApplicationRef","DomPortalOutlet","i5","i6","ANIMATION_MODULE_TYPE","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","inject","CdkOverlayOrigin","elementRef","dir","selectors","exportAs","standalone","CdkConnectedOverlay","_position","_updatePositionStrategy","_disposeOnNavigation","_overlay","scrollStrategyFactory","_dir","_backdropSubscription","_attachSubscription","_detachSubscription","_positionSubscription","NgZone","viewportMargin","open","disableClose","lockPosition","EventEmitter","positionChange","overlayKeydown","overlayOutsideClick","_templatePortal","TemplatePortal","_scrollStrategyFactory","ngOnChanges","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","emit","keyCode","ESCAPE","hasModifierKey","preventDefault","_getOriginElement","_createPositionStrategy","currentPosition","_getOrigin","transformOriginSelector","takeWhile","inclusive","result","inputs","None","HasDecoratorInputTransform","booleanAttribute","outputs","features","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","provide","deps","useFactory","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","OverlayModule","mod","inj","providers","imports","BidiModule","PortalModule","ScrollingModule","Portal","_attachedHost","setAttachedHost","ComponentPortal","component","injector","componentFactoryResolver","projectableNodes","DomPortal","BasePortalOutlet","attachDomPortal","_attachedPortal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","setDisposeFn","fn","_disposeFn","outletElement","_defaultInjector","anchorNode","createComment","replaceChild","componentFactory","resolveComponentFactory","componentRef","createComponent","Injector","NULL","attachView","hostView","viewCount","detachView","_getComponentRootNode","viewContainer","viewRef","rootNodes","rootNode","detectChanges","CdkPortal","CdkPortalOutlet","_viewContainerRef","_isInitialized","attached","_getRootNode","attachedRef","_attachedRef","ngOnInit","ref","nodeType","ELEMENT_NODE","PortalInjector","_parentInjector","_customTokens","notFoundValue","auditTime","duration","audit","durationSelector","lastValue","durationSubscriber","isComplete","endDuration","cleanupDuration","_c0","_c1","VIRTUAL_SCROLL_STRATEGY","FixedSizeVirtualScrollStrategy","itemSize","minBufferPx","maxBufferPx","_scrolledIndexChange","scrolledIndexChange","distinctUntilChanged","_viewport","_itemSize","_minBufferPx","_maxBufferPx","_updateTotalContentSize","_updateRenderedRange","updateItemAndBufferSize","onContentScrolled","onDataLengthChanged","onContentRendered","onRenderedOffsetChanged","scrollToIndex","behavior","scrollToOffset","setTotalContentSize","getDataLength","renderedRange","getRenderedRange","newRange","viewportSize","dataLength","scrollOffset","measureScrollOffset","firstVisibleIndex","maxVisibleItems","ceil","newVisibleIndex","startBuffer","expandStart","endBuffer","expandEnd","setRenderedRange","setRenderedContentOffset","_fixedSizeVirtualScrollStrategyFactory","fixedSizeDir","CdkFixedSizeVirtualScroll","coerceNumberProperty","forwardRef","ScrollDispatcher","_scrolled","_globalSubscription","_scrolledCount","Map","register","set","elementScrolled","deregister","scrollableReference","auditTimeInMs","observer","_addGlobalListener","_removeGlobalListener","_","ancestorScrolled","elementOrElementRef","ancestors","getAncestorScrollContainers","scrollingContainers","_subscription","_scrollableContainsElement","_getWindow","defaultView","coerceElement","scrollableElement","CdkScrollable","scrollDispatcher","ngZone","_destroyed","_elementScrolled","scrollTo","el","getRtlScrollAxisType","RtlScrollAxisType","NORMAL","INVERTED","NEGATED","_applyScrollToOptions","scrollTop","scrollLeft","LEFT","RIGHT","i2","ViewportRuler","_change","_changeListener","_viewportSize","_updateViewportSize","output","getViewportRect","documentRect","scrollY","scrollX","throttleTime","innerWidth","innerHeight","VIRTUAL_SCROLLABLE","CdkVirtualScrollable","measureViewportSize","orientation","viewportEl","SCROLL_SCHEDULER","CdkVirtualScrollViewport","_orientation","_calculateSpacerSize","_changeDetectorRef","viewportRuler","Platform","_detachedSubject","_renderedRangeSubject","appendOnly","renderedRangeStream","_totalContentSize","_totalContentWidth","_totalContentHeight","_renderedRange","_dataLength","_renderedContentOffset","_renderedContentOffsetNeedsRewrite","_isChangeDetectionPending","_runAfterChangeDetection","_viewportChanges","checkViewportSize","_measureViewportSize","startWith","_markChangeDetectionNeeded","forOf","_forOf","dataStream","data","newLength","_doChangeDetection","measureBoundingClientRectWithScrollOffset","range","rangesEqual","r1","r2","getOffsetToRenderedContentStart","to","isHorizontal","Number","_renderedContentTransform","measureRenderedContentSize","_from","measureViewportOffset","fromRect","scrollerClientRect","contentEl","_contentWrapper","offsetWidth","offsetHeight","measureRangeSize","runAfter","markForCheck","runAfterChangeDetection","cmp","viewQuery","rf","ctx","_t","first","hostAttrs","hostVars","hostBindings","virtualScrollable","Optional","Inject","ngContentSelectors","decls","vars","consts","template","encapsulation","changeDetection","getOffset","node","rect","CdkVirtualForOf","cdkVirtualForOf","_cdkVirtualForOf","_dataSourceChanges","cdkVirtualForTrackBy","_cdkVirtualForTrackBy","_needsUpdate","item","cdkVirtualForTemplate","_template","cdkVirtualForTemplateCacheSize","_viewRepeater","_differs","viewChange","switchMap","cur","_changeDataSource","shareReplay","_differ","_onRenderedDataChange","renderedStartIndex","rangeLen","firstNode","lastNode","ngDoCheck","diff","_renderedItems","_applyChanges","_updateContext","find","oldDs","newDs","count","_updateComputedContextProperties","_adjustedPreviousIndex","_getEmbeddedViewArgs","forEachIdentityChange","last","even","odd","useClass","CdkScrollableModule","CdkDialogContainer_ng_template_0_Template","DialogConfig","role","ariaDescribedBy","ariaLabelledBy","ariaLabel","ariaModal","autoFocus","restoreFocus","closeOnNavigation","closeOnDestroy","closeOnOverlayDetachments","CdkDialogContainer","_elementRef","_focusTrapFactory","_interactivityChecker","_focusMonitor","_focusTrap","_elementFocusedBeforeDialogWasOpened","_closeInteractionType","_ariaLabelledByQueue","ChangeDetectorRef","_contentAttached","_addAriaLabelledBy","_removeAriaLabelledBy","_initializeFocusTrap","_handleBackdropClicks","_captureInitialFocus","_trapFocus","_restoreFocus","_recaptureFocus","_containsFocus","_forceFocus","isFocusable","tabIndex","removeAttribute","focus","_focusByCssSelector","elementToFocus","querySelector","focusInitialElementWhenReady","focusedSuccessfully","_focusDialogContainer","focusConfig","focusTargetElement","activeElement","_getFocusedElementPierceShadowDom","focusVia","dependencies","DialogRef","focusOrigin","containerInstance","closedSubject","componentInstance","DIALOG_SCROLL_STRATEGY","DIALOG_DATA","DEFAULT_DIALOG_CONFIG","uniqueId","Dialog","openDialogs","_parentDialog","_openDialogsAtThisLevel","afterOpened","_afterOpenedAtThisLevel","_defaultOptions","_afterAllClosedAtThisLevel","_ariaHiddenElements","afterAllClosed","defer","_getAfterAllClosed","componentOrTemplateRef","getDialogById","_getOverlayConfig","dialogRef","dialogContainer","_attachContainer","_attachDialogContent","_hideNonDialogContentFromAssistiveTechnology","_removeOpenDialog","closeAll","reverseForEach","dialog","userInjector","useValue","containerType","containerPortal","instance","TemplateRef","_createInjector","templateContext","contentRef","fallbackInjector","Directionality","optional","emitEvent","previousValue","overlayContainer","siblings","sibling","nodeName","hasAttribute","getAttribute","items","DialogModule","A11yModule","MatDialogContainer_ng_template_2_Template","MatDialogConfig","delayFocusTrap","OPEN_CLASS","OPENING_CLASS","CLOSING_CLASS","MatDialogContainer","focusTrapFactory","dialogConfig","interactivityChecker","_animationMode","focusMonitor","_animationStateChanged","_animationsEnabled","_actionSectionCount","_hostElement","_enterAnimationDuration","parseCssTime","enterAnimationDuration","_exitAnimationDuration","exitAnimationDuration","_animationTimer","_finishDialogOpen","_clearAnimationClasses","_openAnimationDone","_finishDialogClose","totalTime","_startOpenAnimation","setProperty","TRANSITION_DURATION_PROPERTY","_requestAnimationFrame","_waitForAnimationToComplete","_startExitAnimation","_updateActionSectionCount","delta","location","time","endsWith","substring","MatDialogState","OPEN","CLOSING","CLOSED","MatDialogRef","_ref","_containerInstance","_afterOpened","_beforeClosed","_state","_closeFallbackTimeout","_result","_closeDialogVia","interactionType","dialogResult","afterClosed","beforeClosed","getState","MAT_DIALOG_DATA","MAT_DIALOG_DEFAULT_OPTIONS","MAT_DIALOG_SCROLL_STRATEGY","MatDialog","dialogConfigClass","_dialog","_dialogRefConstructor","_dialogContainerType","_dialogDataToken","cdkRef","cdkConfig","_closeDialogs","dialogs","MatDialogLayoutSection","_dialogRef","getClosestDialog","_onAdd","_onRemove","MatDialogActions","MatDialogActions_BaseFactory","align","MatDialogModule","MatCommonModule"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/observable/fromEvent.js","./node_modules/rxjs/dist/esm/internal/observable/timer.js","./node_modules/rxjs/dist/esm/internal/util/isDate.js","./node_modules/rxjs/dist/esm/internal/operators/pairwise.js","./node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js","./node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js","./node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js","./node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js","./node_modules/rxjs/dist/esm/internal/util/Immediate.js","./node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js","./node_modules/rxjs/dist/esm/internal/scheduler/asap.js","./node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js","./node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js","./node_modules/@angular/cdk/fesm2022/collections.mjs","./node_modules/@angular/cdk/fesm2022/overlay.mjs","./node_modules/rxjs/dist/esm/internal/operators/takeWhile.js","./node_modules/@angular/cdk/fesm2022/portal.mjs","./node_modules/rxjs/dist/esm/internal/operators/auditTime.js","./node_modules/rxjs/dist/esm/internal/operators/audit.js","./node_modules/@angular/cdk/fesm2022/scrolling.mjs","./node_modules/@angular/cdk/fesm2022/dialog.mjs","./node_modules/@angular/material/fesm2022/dialog.mjs"],"sourcesContent":["import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'];\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'];\nconst jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    const [add, remove] = isEventTarget(target)\n        ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options))\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable((subscriber) => {\n        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);\n        add(handler);\n        return () => remove(handler);\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return (methodName) => (handler) => target[methodName](eventName, handler);\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { Observable } from '../Observable';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\nexport function timer(dueTime = 0, intervalOrScheduler, scheduler = asyncScheduler) {\n    let intervalDuration = -1;\n    if (intervalOrScheduler != null) {\n        if (isScheduler(intervalOrScheduler)) {\n            scheduler = intervalOrScheduler;\n        }\n        else {\n            intervalDuration = intervalOrScheduler;\n        }\n    }\n    return new Observable((subscriber) => {\n        let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;\n        if (due < 0) {\n            due = 0;\n        }\n        let n = 0;\n        return scheduler.schedule(function () {\n            if (!subscriber.closed) {\n                subscriber.next(n++);\n                if (0 <= intervalDuration) {\n                    this.schedule(undefined, intervalDuration);\n                }\n                else {\n                    subscriber.complete();\n                }\n            }\n        }, due);\n    });\n}\n","export function isValidDate(value) {\n    return value instanceof Date && !isNaN(value);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function pairwise() {\n    return operate((source, subscriber) => {\n        let prev;\n        let hasPrev = false;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const p = prev;\n            prev = value;\n            hasPrev && subscriber.next([p, value]);\n            hasPrev = true;\n        }));\n    });\n}\n","import { Subscription } from '../Subscription';\nexport const animationFrameProvider = {\n    schedule(callback) {\n        let request = requestAnimationFrame;\n        let cancel = cancelAnimationFrame;\n        const { delegate } = animationFrameProvider;\n        if (delegate) {\n            request = delegate.requestAnimationFrame;\n            cancel = delegate.cancelAnimationFrame;\n        }\n        const handle = request((timestamp) => {\n            cancel = undefined;\n            callback(timestamp);\n        });\n        return new Subscription(() => cancel === null || cancel === void 0 ? void 0 : cancel(handle));\n    },\n    requestAnimationFrame(...args) {\n        const { delegate } = animationFrameProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame)(...args);\n    },\n    cancelAnimationFrame(...args) {\n        const { delegate } = animationFrameProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame)(...args);\n    },\n    delegate: undefined,\n};\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AnimationFrameScheduler extends AsyncScheduler {\n    flush(action) {\n        this._active = true;\n        const flushId = this._scheduled;\n        this._scheduled = undefined;\n        const { actions } = this;\n        let error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { animationFrameProvider } from './animationFrameProvider';\nexport class AnimationFrameAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        var _a;\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        const { actions } = scheduler;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            animationFrameProvider.cancelAnimationFrame(id);\n            scheduler._scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n","let nextHandle = 1;\nlet resolved;\nconst activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexport const Immediate = {\n    setImmediate(cb) {\n        const handle = nextHandle++;\n        activeHandles[handle] = true;\n        if (!resolved) {\n            resolved = Promise.resolve();\n        }\n        resolved.then(() => findAndClearHandle(handle) && cb());\n        return handle;\n    },\n    clearImmediate(handle) {\n        findAndClearHandle(handle);\n    },\n};\nexport const TestTools = {\n    pending() {\n        return Object.keys(activeHandles).length;\n    }\n};\n","import { Immediate } from '../util/Immediate';\nconst { setImmediate, clearImmediate } = Immediate;\nexport const immediateProvider = {\n    setImmediate(...args) {\n        const { delegate } = immediateProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate)(...args);\n    },\n    clearImmediate(handle) {\n        const { delegate } = immediateProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);\n    },\n    delegate: undefined,\n};\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport const asapScheduler = new AsapScheduler(AsapAction);\nexport const asap = asapScheduler;\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AsapScheduler extends AsyncScheduler {\n    flush(action) {\n        this._active = true;\n        const flushId = this._scheduled;\n        this._scheduled = undefined;\n        const { actions } = this;\n        let error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { immediateProvider } from './immediateProvider';\nexport class AsapAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        var _a;\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        const { actions } = scheduler;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            immediateProvider.clearImmediate(id);\n            if (scheduler._scheduled === id) {\n                scheduler._scheduled = undefined;\n            }\n        }\n        return undefined;\n    }\n}\n","import { ConnectableObservable, isObservable, of, Subject } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable } from '@angular/core';\n\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource. We also can't use `isObservable`\n    // here, because of some internal apps.\n    return value && typeof value.connect === 'function' && !(value instanceof ConnectableObservable);\n}\n\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return isObservable(this._data) ? this._data : of(this._data);\n    }\n    disconnect() { }\n}\n\n/** Indicates how a view was changed by a {@link _ViewRepeater}. */\nvar _ViewRepeaterOperation;\n(function (_ViewRepeaterOperation) {\n    /** The content of an existing view was replaced with another item. */\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"REPLACED\"] = 0] = \"REPLACED\";\n    /** A new view was created with `createEmbeddedView`. */\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"INSERTED\"] = 1] = \"INSERTED\";\n    /** The position of a view changed, but the content remains the same. */\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"MOVED\"] = 2] = \"MOVED\";\n    /** A view was detached from the view container. */\n    _ViewRepeaterOperation[_ViewRepeaterOperation[\"REMOVED\"] = 3] = \"REMOVED\";\n})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\n\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n                operation = _ViewRepeaterOperation.INSERTED;\n            }\n            else if (currentIndex == null) {\n                viewContainerRef.remove(adjustedPreviousIndex);\n                operation = _ViewRepeaterOperation.REMOVED;\n            }\n            else {\n                view = viewContainerRef.get(adjustedPreviousIndex);\n                viewContainerRef.move(view, currentIndex);\n                operation = _ViewRepeaterOperation.MOVED;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view?.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() { }\n}\n\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n    constructor() {\n        /**\n         * The size of the cache used to store unused views.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n         */\n        this.viewCacheSize = 20;\n        /**\n         * View cache that stores embedded view instances that have been previously stamped out,\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\n         * creating brand new ones.\n         *\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n         */\n        this._viewCache = [];\n    }\n    /** Apply changes to the DOM. */\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                // Item added.\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n            }\n            else if (currentIndex == null) {\n                // Item removed.\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n                operation = _ViewRepeaterOperation.REMOVED;\n            }\n            else {\n                // Item moved.\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = _ViewRepeaterOperation.MOVED;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view?.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n        for (const view of this._viewCache) {\n            view.destroy();\n        }\n        this._viewCache = [];\n    }\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n        if (cachedView) {\n            cachedView.context.$implicit = value;\n            return undefined;\n        }\n        const viewArgs = viewArgsFactory();\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n    }\n    /** Detaches the view at the given index and inserts into the view cache. */\n    _detachAndCacheView(index, viewContainerRef) {\n        const detachedView = viewContainerRef.detach(index);\n        this._maybeCacheView(detachedView, viewContainerRef);\n    }\n    /** Moves view at the previous index to the current index. */\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n        const view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = value;\n        return view;\n    }\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    _maybeCacheView(view, viewContainerRef) {\n        if (this._viewCache.length < this.viewCacheSize) {\n            this._viewCache.push(view);\n        }\n        else {\n            const index = viewContainerRef.indexOf(view);\n            // The host component could remove views from the container outside of\n            // the view repeater. It's unlikely this will occur, but just in case,\n            // destroy the view on its own, otherwise destroy it through the\n            // container to ensure that all the references are removed.\n            if (index === -1) {\n                view.destroy();\n            }\n            else {\n                viewContainerRef.remove(index);\n            }\n        }\n    }\n    /** Inserts a recycled view from the cache at the given index. */\n    _insertViewFromCache(index, viewContainerRef) {\n        const cachedView = this._viewCache.pop();\n        if (cachedView) {\n            viewContainerRef.insert(cachedView, index);\n        }\n        return cachedView || null;\n    }\n}\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        this.compareWith = compareWith;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new Subject();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /**\n     * Selects a value or an array of values.\n     * @param values The values to select\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Deselects a value or an array of values.\n     * @param values The values to deselect\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Sets the selected values\n     * @param values The new selected values\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    setSelection(...values) {\n        this._verifyValueAssignment(values);\n        const oldValues = this.selected;\n        const newSelectedSet = new Set(values);\n        values.forEach(value => this._markSelected(value));\n        oldValues\n            .filter(value => !newSelectedSet.has(this._getConcreteValue(value, newSelectedSet)))\n            .forEach(value => this._unmarkSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     * @param value The value to toggle\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    toggle(value) {\n        return this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     * @param flushEvent Whether to flush the changes in an event.\n     *   If false, the changes to the selection will be flushed along with the next event.\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    clear(flushEvent = true) {\n        this._unmarkAll();\n        const changed = this._hasQueuedChanges();\n        if (flushEvent) {\n            this._emitChangeEvent();\n        }\n        return changed;\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(this._getConcreteValue(value));\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit,\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        value = this._getConcreteValue(value);\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            if (!this.isSelected(value)) {\n                this._selection.add(value);\n            }\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        value = this._getConcreteValue(value);\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n    /** Whether there are queued up change to be emitted. */\n    _hasQueuedChanges() {\n        return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n    }\n    /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n    _getConcreteValue(inputValue, selection) {\n        if (!this.compareWith) {\n            return inputValue;\n        }\n        else {\n            selection = selection ?? this._selection;\n            for (let selectedValue of selection) {\n                if (this.compareWith(inputValue, selectedValue)) {\n                    return selectedValue;\n                }\n            }\n            return inputValue;\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n    constructor() {\n        this._listeners = [];\n    }\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id, name) {\n        for (let listener of this._listeners) {\n            listener(id, name);\n        }\n    }\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener) {\n        this._listeners.push(listener);\n        return () => {\n            this._listeners = this._listeners.filter((registered) => {\n                return listener !== registered;\n            });\n        };\n    }\n    ngOnDestroy() {\n        this._listeners = [];\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: UniqueSelectionDispatcher, deps: [], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: UniqueSelectionDispatcher, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: UniqueSelectionDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, _ViewRepeaterOperation, getMultipleValuesInSingleSelectionError, isDataSource };\n","import * as i1 from '@angular/cdk/scrolling';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nexport { CdkScrollable, ScrollDispatcher, ViewportRuler } from '@angular/cdk/scrolling';\nimport * as i6 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, ElementRef, ApplicationRef, ANIMATION_MODULE_TYPE, InjectionToken, inject, Directive, NgZone, EventEmitter, booleanAttribute, Input, Output, NgModule } from '@angular/core';\nimport { coerceCssPixelValue, coerceArray } from '@angular/cdk/coercion';\nimport * as i1$1 from '@angular/cdk/platform';\nimport { supportsScrollBehavior, _getEventTarget, _isTestEnvironment } from '@angular/cdk/platform';\nimport { filter, take, takeUntil, takeWhile } from 'rxjs/operators';\nimport * as i5 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { Subject, Subscription, merge } from 'rxjs';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\n\nconst scrollBehaviorSupported = supportsScrollBehavior();\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n    constructor(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach() { }\n    /** Blocks page-level scroll while the attached overlay is open. */\n    enable() {\n        if (this._canBeEnabled()) {\n            const root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    }\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    disable() {\n        if (this._isEnabled) {\n            const html = this._document.documentElement;\n            const body = this._document.body;\n            const htmlStyle = html.style;\n            const bodyStyle = body.style;\n            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n            this._isEnabled = false;\n            htmlStyle.left = this._previousHTMLStyles.left;\n            htmlStyle.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n            // because it can throw off feature detections in `supportsScrollBehavior` which\n            // checks for `'scrollBehavior' in documentElement.style`.\n            if (scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n            }\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            if (scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n                bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n            }\n        }\n    }\n    _canBeEnabled() {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        const html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        const body = this._document.body;\n        const viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    }\n}\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n    constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /** Detaches the overlay ref and disables the scroll strategy. */\n        this._detach = () => {\n            this.disable();\n            if (this._overlayRef.hasAttached()) {\n                this._ngZone.run(() => this._overlayRef.detach());\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables the closing of the attached overlay on scroll. */\n    enable() {\n        if (this._scrollSubscription) {\n            return;\n        }\n        const stream = this._scrollDispatcher.scrolled(0).pipe(filter(scrollable => {\n            return (!scrollable ||\n                !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement));\n        }));\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(() => {\n                const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n                    this._detach();\n                }\n                else {\n                    this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    }\n    /** Disables the closing the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n    /** Does nothing, as this scroll strategy is a no-op. */\n    enable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    disable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    attach() { }\n}\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(containerBounds => {\n        const outsideAbove = element.bottom < containerBounds.top;\n        const outsideBelow = element.top > containerBounds.bottom;\n        const outsideLeft = element.right < containerBounds.left;\n        const outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(scrollContainerRect => {\n        const clippedAbove = element.top < scrollContainerRect.top;\n        const clippedBelow = element.bottom > scrollContainerRect.bottom;\n        const clippedLeft = element.left < scrollContainerRect.left;\n        const clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables repositioning of the attached overlay on scroll. */\n    enable() {\n        if (!this._scrollSubscription) {\n            const throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n                this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (this._config && this._config.autoClose) {\n                    const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n                    const { width, height } = this._viewportRuler.getViewportSize();\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    const parentRects = [{ width, height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        this.disable();\n                        this._ngZone.run(() => this._overlayRef.detach());\n                    }\n                }\n            });\n        }\n    }\n    /** Disables repositioning of the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /** Do nothing on scroll. */\n        this.noop = () => new NoopScrollStrategy();\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n        /** Block scrolling. */\n        this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n        this._document = document;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollStrategyOptions, deps: [{ token: i1.ScrollDispatcher }, { token: i1.ViewportRuler }, { token: i0.NgZone }, { token: DOCUMENT }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollStrategyOptions, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollStrategyOptions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.ScrollDispatcher }, { type: i1.ViewportRuler }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n    constructor(config) {\n        /** Strategy to be used when handling scroll events while the overlay is open. */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /** Custom class to add to the overlay pane. */\n        this.panelClass = '';\n        /** Whether the overlay has a backdrop. */\n        this.hasBackdrop = false;\n        /** Custom class to add to the backdrop */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.disposeOnNavigation = false;\n        if (config) {\n            // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n            // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n            // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n            const configKeys = Object.keys(config);\n            for (const key of configKeys) {\n                if (config[key] !== undefined) {\n                    // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                    // as \"I don't know *which* key this is, so the only valid value is the intersection\n                    // of all the possible values.\" In this case, that happens to be `undefined`. TypeScript\n                    // is not smart enough to see that the right-hand-side is actually an access of the same\n                    // exact type with the same exact key, meaning that the value type must be identical.\n                    // So we use `any` to work around this.\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n}\n\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n    constructor(origin, overlay, \n    /** Offset along the X axis. */\n    offsetX, \n    /** Offset along the Y axis. */\n    offsetY, \n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.panelClass = panelClass;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {\n}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n    constructor(\n    /** The position used as a result of this change. */\n    connectionPair, \n    /** @docs-private */\n    scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n}\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n    if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"top\", \"bottom\" or \"center\".`);\n    }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n    if (value !== 'start' && value !== 'end' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"start\", \"end\" or \"center\".`);\n    }\n}\n\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass BaseOverlayDispatcher {\n    constructor(document) {\n        /** Currently attached overlays in the order they were attached. */\n        this._attachedOverlays = [];\n        this._document = document;\n    }\n    ngOnDestroy() {\n        this.detach();\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        // Ensure that we don't get the same overlay multiple times.\n        this.remove(overlayRef);\n        this._attachedOverlays.push(overlayRef);\n    }\n    /** Remove an overlay from the list of attached overlay refs. */\n    remove(overlayRef) {\n        const index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this.detach();\n        }\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: BaseOverlayDispatcher, deps: [{ token: DOCUMENT }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: BaseOverlayDispatcher, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: BaseOverlayDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n    constructor(document, \n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    _ngZone) {\n        super(document);\n        this._ngZone = _ngZone;\n        /** Keyboard event listener that will be attached to the body. */\n        this._keydownListener = (event) => {\n            const overlays = this._attachedOverlays;\n            for (let i = overlays.length - 1; i > -1; i--) {\n                // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                // We want to target the most recent overlay, rather than trying to match where the event came\n                // from, because some components might open an overlay, but keep focus on a trigger element\n                // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                // because we don't want overlays that don't handle keyboard events to block the ones below\n                // them that do.\n                if (overlays[i]._keydownEvents.observers.length > 0) {\n                    const keydownEvents = overlays[i]._keydownEvents;\n                    /** @breaking-change 14.0.0 _ngZone will be required. */\n                    if (this._ngZone) {\n                        this._ngZone.run(() => keydownEvents.next(event));\n                    }\n                    else {\n                        keydownEvents.next(event);\n                    }\n                    break;\n                }\n            }\n        };\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        super.add(overlayRef);\n        // Lazily start dispatcher once first overlay is added\n        if (!this._isAttached) {\n            /** @breaking-change 14.0.0 _ngZone will be required. */\n            if (this._ngZone) {\n                this._ngZone.runOutsideAngular(() => this._document.body.addEventListener('keydown', this._keydownListener));\n            }\n            else {\n                this._document.body.addEventListener('keydown', this._keydownListener);\n            }\n            this._isAttached = true;\n        }\n    }\n    /** Detaches the global keyboard event listener. */\n    detach() {\n        if (this._isAttached) {\n            this._document.body.removeEventListener('keydown', this._keydownListener);\n            this._isAttached = false;\n        }\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayKeyboardDispatcher, deps: [{ token: DOCUMENT }, { token: i0.NgZone, optional: true }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayKeyboardDispatcher, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayKeyboardDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.NgZone, decorators: [{\n                    type: Optional\n                }] }] });\n\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n    constructor(document, _platform, \n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    _ngZone) {\n        super(document);\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._cursorStyleIsSet = false;\n        /** Store pointerdown event target to track origin of click. */\n        this._pointerDownListener = (event) => {\n            this._pointerDownEventTarget = _getEventTarget(event);\n        };\n        /** Click event listener that will be attached to the body propagate phase. */\n        this._clickListener = (event) => {\n            const target = _getEventTarget(event);\n            // In case of a click event, we want to check the origin of the click\n            // (e.g. in case where a user starts a click inside the overlay and\n            // releases the click outside of it).\n            // This is done by using the event target of the preceding pointerdown event.\n            // Every click event caused by a pointer device has a preceding pointerdown\n            // event, unless the click was programmatically triggered (e.g. in a unit test).\n            const origin = event.type === 'click' && this._pointerDownEventTarget\n                ? this._pointerDownEventTarget\n                : target;\n            // Reset the stored pointerdown event target, to avoid having it interfere\n            // in subsequent events.\n            this._pointerDownEventTarget = null;\n            // We copy the array because the original may be modified asynchronously if the\n            // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n            // the for loop.\n            const overlays = this._attachedOverlays.slice();\n            // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n            // We want to target all overlays for which the click could be considered as outside click.\n            // As soon as we reach an overlay for which the click is not outside click we break off\n            // the loop.\n            for (let i = overlays.length - 1; i > -1; i--) {\n                const overlayRef = overlays[i];\n                if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n                    continue;\n                }\n                // If it's a click inside the overlay, just break - we should do nothing\n                // If it's an outside click (both origin and target of the click) dispatch the mouse event,\n                // and proceed with the next overlay\n                if (overlayRef.overlayElement.contains(target) ||\n                    overlayRef.overlayElement.contains(origin)) {\n                    break;\n                }\n                const outsidePointerEvents = overlayRef._outsidePointerEvents;\n                /** @breaking-change 14.0.0 _ngZone will be required. */\n                if (this._ngZone) {\n                    this._ngZone.run(() => outsidePointerEvents.next(event));\n                }\n                else {\n                    outsidePointerEvents.next(event);\n                }\n            }\n        };\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        super.add(overlayRef);\n        // Safari on iOS does not generate click events for non-interactive\n        // elements. However, we want to receive a click for any element outside\n        // the overlay. We can force a \"clickable\" state by setting\n        // `cursor: pointer` on the document body. See:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n        // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n        if (!this._isAttached) {\n            const body = this._document.body;\n            /** @breaking-change 14.0.0 _ngZone will be required. */\n            if (this._ngZone) {\n                this._ngZone.runOutsideAngular(() => this._addEventListeners(body));\n            }\n            else {\n                this._addEventListeners(body);\n            }\n            // click event is not fired on iOS. To make element \"clickable\" we are\n            // setting the cursor to pointer\n            if (this._platform.IOS && !this._cursorStyleIsSet) {\n                this._cursorOriginalValue = body.style.cursor;\n                body.style.cursor = 'pointer';\n                this._cursorStyleIsSet = true;\n            }\n            this._isAttached = true;\n        }\n    }\n    /** Detaches the global keyboard event listener. */\n    detach() {\n        if (this._isAttached) {\n            const body = this._document.body;\n            body.removeEventListener('pointerdown', this._pointerDownListener, true);\n            body.removeEventListener('click', this._clickListener, true);\n            body.removeEventListener('auxclick', this._clickListener, true);\n            body.removeEventListener('contextmenu', this._clickListener, true);\n            if (this._platform.IOS && this._cursorStyleIsSet) {\n                body.style.cursor = this._cursorOriginalValue;\n                this._cursorStyleIsSet = false;\n            }\n            this._isAttached = false;\n        }\n    }\n    _addEventListeners(body) {\n        body.addEventListener('pointerdown', this._pointerDownListener, true);\n        body.addEventListener('click', this._clickListener, true);\n        body.addEventListener('auxclick', this._clickListener, true);\n        body.addEventListener('contextmenu', this._clickListener, true);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayOutsideClickDispatcher, deps: [{ token: DOCUMENT }, { token: i1$1.Platform }, { token: i0.NgZone, optional: true }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayOutsideClickDispatcher, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayOutsideClickDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i1$1.Platform }, { type: i0.NgZone, decorators: [{\n                    type: Optional\n                }] }] });\n\n/** Container inside which all overlays will render. */\nclass OverlayContainer {\n    constructor(document, _platform) {\n        this._platform = _platform;\n        this._document = document;\n    }\n    ngOnDestroy() {\n        this._containerElement?.remove();\n    }\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    getContainerElement() {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    }\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    _createContainer() {\n        const containerClass = 'cdk-overlay-container';\n        // TODO(crisbeto): remove the testing check once we have an overlay testing\n        // module or Angular starts tearing down the testing `NgModule`. See:\n        // https://github.com/angular/angular/issues/18831\n        if (this._platform.isBrowser || _isTestEnvironment()) {\n            const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` + `.${containerClass}[platform=\"test\"]`);\n            // Remove any old containers from the opposite platform.\n            // This can happen when transitioning from the server to the client.\n            for (let i = 0; i < oppositePlatformContainers.length; i++) {\n                oppositePlatformContainers[i].remove();\n            }\n        }\n        const container = this._document.createElement('div');\n        container.classList.add(containerClass);\n        // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n        // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n        // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n        // To mitigate the problem we made it so that only containers from a different platform are\n        // cleared, but the side-effect was that people started depending on the overly-aggressive\n        // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n        // module which does the cleanup, we try to detect that we're in a test environment and we\n        // always clear the container. See #17006.\n        // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n        if (_isTestEnvironment()) {\n            container.setAttribute('platform', 'test');\n        }\n        else if (!this._platform.isBrowser) {\n            container.setAttribute('platform', 'server');\n        }\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayContainer, deps: [{ token: DOCUMENT }, { token: i1$1.Platform }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayContainer, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayContainer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i1$1.Platform }] });\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n    constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false) {\n        this._portalOutlet = _portalOutlet;\n        this._host = _host;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._location = _location;\n        this._outsideClickDispatcher = _outsideClickDispatcher;\n        this._animationsDisabled = _animationsDisabled;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        this._locationChanges = Subscription.EMPTY;\n        this._backdropClickHandler = (event) => this._backdropClick.next(event);\n        this._backdropTransitionendHandler = (event) => {\n            this._disposeBackdrop(event.target);\n        };\n        /** Stream of keydown events dispatched to this overlay. */\n        this._keydownEvents = new Subject();\n        /** Stream of mouse outside events dispatched to this overlay. */\n        this._outsidePointerEvents = new Subject();\n        if (_config.scrollStrategy) {\n            this._scrollStrategy = _config.scrollStrategy;\n            this._scrollStrategy.attach(this);\n        }\n        this._positionStrategy = _config.positionStrategy;\n    }\n    /** The overlay's HTML element */\n    get overlayElement() {\n        return this._pane;\n    }\n    /** The overlay's backdrop HTML element. */\n    get backdropElement() {\n        return this._backdropElement;\n    }\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     */\n    get hostElement() {\n        return this._host;\n    }\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    attach(portal) {\n        // Insert the host into the DOM before attaching the portal, otherwise\n        // the animations module will skip animations on repeat attachments.\n        if (!this._host.parentElement && this._previousHostParent) {\n            this._previousHostParent.appendChild(this._host);\n        }\n        const attachResult = this._portalOutlet.attach(portal);\n        if (this._positionStrategy) {\n            this._positionStrategy.attach(this);\n        }\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._scrollStrategy) {\n            this._scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n            // The overlay could've been detached before the zone has stabilized.\n            if (this.hasAttached()) {\n                this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, true);\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        if (this._config.disposeOnNavigation) {\n            this._locationChanges = this._location.subscribe(() => this.dispose());\n        }\n        this._outsideClickDispatcher.add(this);\n        // TODO(crisbeto): the null check is here, because the portal outlet returns `any`.\n        // We should be guaranteed for the result to be `ComponentRef | EmbeddedViewRef`, but\n        // `instanceof EmbeddedViewRef` doesn't appear to work at the moment.\n        if (typeof attachResult?.onDestroy === 'function') {\n            // In most cases we control the portal and we know when it is being detached so that\n            // we can finish the disposal process. The exception is if the user passes in a custom\n            // `ViewContainerRef` that isn't destroyed through the overlay API. Note that we use\n            // `detach` here instead of `dispose`, because we don't know if the user intends to\n            // reattach the overlay at a later point. It also has the advantage of waiting for animations.\n            attachResult.onDestroy(() => {\n                if (this.hasAttached()) {\n                    // We have to delay the `detach` call, because detaching immediately prevents\n                    // other destroy hooks from running. This is likely a framework bug similar to\n                    // https://github.com/angular/angular/issues/46119\n                    this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));\n                }\n            });\n        }\n        return attachResult;\n    }\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    detach() {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._positionStrategy && this._positionStrategy.detach) {\n            this._positionStrategy.detach();\n        }\n        if (this._scrollStrategy) {\n            this._scrollStrategy.disable();\n        }\n        const detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking.\n        this._keyboardDispatcher.remove(this);\n        // Keeping the host element in the DOM can cause scroll jank, because it still gets\n        // rendered, even though it's transparent and unclickable which is why we remove it.\n        this._detachContentWhenStable();\n        this._locationChanges.unsubscribe();\n        this._outsideClickDispatcher.remove(this);\n        return detachmentResult;\n    }\n    /** Cleans up the overlay from the DOM. */\n    dispose() {\n        const isAttached = this.hasAttached();\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._disposeScrollStrategy();\n        this._disposeBackdrop(this._backdropElement);\n        this._locationChanges.unsubscribe();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        this._outsidePointerEvents.complete();\n        this._outsideClickDispatcher.remove(this);\n        this._host?.remove();\n        this._previousHostParent = this._pane = this._host = null;\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    }\n    /** Whether the overlay has attached content. */\n    hasAttached() {\n        return this._portalOutlet.hasAttached();\n    }\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    backdropClick() {\n        return this._backdropClick;\n    }\n    /** Gets an observable that emits when the overlay has been attached. */\n    attachments() {\n        return this._attachments;\n    }\n    /** Gets an observable that emits when the overlay has been detached. */\n    detachments() {\n        return this._detachments;\n    }\n    /** Gets an observable of keydown events targeted to this overlay. */\n    keydownEvents() {\n        return this._keydownEvents;\n    }\n    /** Gets an observable of pointer events targeted outside this overlay. */\n    outsidePointerEvents() {\n        return this._outsidePointerEvents;\n    }\n    /** Gets the current overlay configuration, which is immutable. */\n    getConfig() {\n        return this._config;\n    }\n    /** Updates the position of the overlay based on the position strategy. */\n    updatePosition() {\n        if (this._positionStrategy) {\n            this._positionStrategy.apply();\n        }\n    }\n    /** Switches to a new position strategy and updates the overlay position. */\n    updatePositionStrategy(strategy) {\n        if (strategy === this._positionStrategy) {\n            return;\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._positionStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            this.updatePosition();\n        }\n    }\n    /** Update the size properties of the overlay. */\n    updateSize(sizeConfig) {\n        this._config = { ...this._config, ...sizeConfig };\n        this._updateElementSize();\n    }\n    /** Sets the LTR/RTL direction for the overlay. */\n    setDirection(dir) {\n        this._config = { ...this._config, direction: dir };\n        this._updateElementDirection();\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, true);\n        }\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, false);\n        }\n    }\n    /**\n     * Returns the layout direction of the overlay panel.\n     */\n    getDirection() {\n        const direction = this._config.direction;\n        if (!direction) {\n            return 'ltr';\n        }\n        return typeof direction === 'string' ? direction : direction.value;\n    }\n    /** Switches to a new scroll strategy. */\n    updateScrollStrategy(strategy) {\n        if (strategy === this._scrollStrategy) {\n            return;\n        }\n        this._disposeScrollStrategy();\n        this._scrollStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            strategy.enable();\n        }\n    }\n    /** Updates the text direction of the overlay panel. */\n    _updateElementDirection() {\n        this._host.setAttribute('dir', this.getDirection());\n    }\n    /** Updates the size of the overlay element based on the overlay config. */\n    _updateElementSize() {\n        if (!this._pane) {\n            return;\n        }\n        const style = this._pane.style;\n        style.width = coerceCssPixelValue(this._config.width);\n        style.height = coerceCssPixelValue(this._config.height);\n        style.minWidth = coerceCssPixelValue(this._config.minWidth);\n        style.minHeight = coerceCssPixelValue(this._config.minHeight);\n        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n    }\n    /** Toggles the pointer events for the overlay pane element. */\n    _togglePointerEvents(enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n    }\n    /** Attaches a backdrop for this overlay. */\n    _attachBackdrop() {\n        const showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._animationsDisabled) {\n            this._backdropElement.classList.add('cdk-overlay-backdrop-noop-animation');\n        }\n        if (this._config.backdropClass) {\n            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n        }\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._host.parentElement.insertBefore(this._backdropElement, this._host);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', this._backdropClickHandler);\n        // Add class to fade-in the backdrop after one frame.\n        if (!this._animationsDisabled && typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => {\n                    if (this._backdropElement) {\n                        this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    }\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     */\n    _updateStackingOrder() {\n        if (this._host.nextSibling) {\n            this._host.parentNode.appendChild(this._host);\n        }\n    }\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    detachBackdrop() {\n        const backdropToDetach = this._backdropElement;\n        if (!backdropToDetach) {\n            return;\n        }\n        if (this._animationsDisabled) {\n            this._disposeBackdrop(backdropToDetach);\n            return;\n        }\n        backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n        this._ngZone.runOutsideAngular(() => {\n            backdropToDetach.addEventListener('transitionend', this._backdropTransitionendHandler);\n        });\n        // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n        // In this case we make it unclickable and we try to remove it after a delay.\n        backdropToDetach.style.pointerEvents = 'none';\n        // Run this outside the Angular zone because there's nothing that Angular cares about.\n        // If it were to run inside the Angular zone, every test that used Overlay would have to be\n        // either async or fakeAsync.\n        this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {\n            this._disposeBackdrop(backdropToDetach);\n        }, 500));\n    }\n    /** Toggles a single CSS class or an array of classes on an element. */\n    _toggleClasses(element, cssClasses, isAdd) {\n        const classes = coerceArray(cssClasses || []).filter(c => !!c);\n        if (classes.length) {\n            isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);\n        }\n    }\n    /** Detaches the overlay content next time the zone stabilizes. */\n    _detachContentWhenStable() {\n        // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n        // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n        // be patched to run inside the zone, which will throw us into an infinite loop.\n        this._ngZone.runOutsideAngular(() => {\n            // We can't remove the host here immediately, because the overlay pane's content\n            // might still be animating. This stream helps us avoid interrupting the animation\n            // by waiting for the pane to become empty.\n            const subscription = this._ngZone.onStable\n                .pipe(takeUntil(merge(this._attachments, this._detachments)))\n                .subscribe(() => {\n                // Needs a couple of checks for the pane and host, because\n                // they may have been removed by the time the zone stabilizes.\n                if (!this._pane || !this._host || this._pane.children.length === 0) {\n                    if (this._pane && this._config.panelClass) {\n                        this._toggleClasses(this._pane, this._config.panelClass, false);\n                    }\n                    if (this._host && this._host.parentElement) {\n                        this._previousHostParent = this._host.parentElement;\n                        this._host.remove();\n                    }\n                    subscription.unsubscribe();\n                }\n            });\n        });\n    }\n    /** Disposes of a scroll strategy. */\n    _disposeScrollStrategy() {\n        const scrollStrategy = this._scrollStrategy;\n        if (scrollStrategy) {\n            scrollStrategy.disable();\n            if (scrollStrategy.detach) {\n                scrollStrategy.detach();\n            }\n        }\n    }\n    /** Removes a backdrop element from the DOM. */\n    _disposeBackdrop(backdrop) {\n        if (backdrop) {\n            backdrop.removeEventListener('click', this._backdropClickHandler);\n            backdrop.removeEventListener('transitionend', this._backdropTransitionendHandler);\n            backdrop.remove();\n            // It is possible that a new portal has been attached to this overlay since we started\n            // removing the backdrop. If that is the case, only clear the backdrop reference if it\n            // is still the same instance that we started to remove.\n            if (this._backdropElement === backdrop) {\n                this._backdropElement = null;\n            }\n        }\n        if (this._backdropTimeout) {\n            clearTimeout(this._backdropTimeout);\n            this._backdropTimeout = undefined;\n        }\n    }\n}\n\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass FlexibleConnectedPositionStrategy {\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n        /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n        this._lastBoundingBoxSize = { width: 0, height: 0 };\n        /** Whether the overlay was pushed in a previous positioning. */\n        this._isPushed = false;\n        /** Whether the overlay can be pushed on-screen on the initial open. */\n        this._canPush = true;\n        /** Whether the overlay can grow via flexible width/height after the initial open. */\n        this._growAfterOpen = false;\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        this._hasFlexibleDimensions = true;\n        /** Whether the overlay position is locked. */\n        this._positionLocked = false;\n        /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n        this._viewportMargin = 0;\n        /** The Scrollable containers used to check scrollable view properties on position change. */\n        this._scrollables = [];\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        /** Subject that emits whenever the position changes. */\n        this._positionChanges = new Subject();\n        /** Subscription to viewport size changes. */\n        this._resizeSubscription = Subscription.EMPTY;\n        /** Default offset for the overlay along the x axis. */\n        this._offsetX = 0;\n        /** Default offset for the overlay along the y axis. */\n        this._offsetY = 0;\n        /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n        this._appliedPanelClasses = [];\n        /** Observable sequence of position changes. */\n        this.positionChanges = this._positionChanges;\n        this.setOrigin(connectedTo);\n    }\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef &&\n            overlayRef !== this._overlayRef &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('This position strategy is already attached to an overlay');\n        }\n        this._validatePositions();\n        overlayRef.hostElement.classList.add(boundingBoxClass);\n        this._overlayRef = overlayRef;\n        this._boundingBox = overlayRef.hostElement;\n        this._pane = overlayRef.overlayElement;\n        this._isDisposed = false;\n        this._isInitialRender = true;\n        this._lastPosition = null;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n            // When the window is resized, we want to trigger the next reposition as if it\n            // was an initial render, in order for the strategy to pick a new optimal position,\n            // otherwise position locking will cause it to stay at the old one.\n            this._isInitialRender = true;\n            this.apply();\n        });\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * @docs-private\n     */\n    apply() {\n        // We shouldn't do anything if the strategy was disposed or we're on the server.\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the old position, in order to\n        // prevent the overlay from jumping around.\n        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n            this.reapplyLastPosition();\n            return;\n        }\n        this._clearPanelClasses();\n        this._resetOverlayElementStyles();\n        this._resetBoundingBoxStyles();\n        // We need the bounding rects for the origin, the overlay and the container to determine how to position\n        // the overlay relative to the origin.\n        // We use the viewport rect to determine whether a position would go off-screen.\n        this._viewportRect = this._getNarrowedViewportRect();\n        this._originRect = this._getOriginRect();\n        this._overlayRect = this._pane.getBoundingClientRect();\n        this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n        const originRect = this._originRect;\n        const overlayRect = this._overlayRect;\n        const viewportRect = this._viewportRect;\n        const containerRect = this._containerRect;\n        // Positions where the overlay will fit with flexible dimensions.\n        const flexibleFits = [];\n        // Fallback if none of the preferred positions fit within the viewport.\n        let fallback;\n        // Go through each of the preferred positions looking for a good fit.\n        // If a good fit is found, it will be applied immediately.\n        for (let pos of this._preferredPositions) {\n            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n            let originPoint = this._getOriginPoint(originRect, containerRect, pos);\n            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n            // overlay in this position. We use the top-left corner for calculations and later translate\n            // this into an appropriate (top, left, bottom, right) style.\n            let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            // Calculate how well the overlay would fit into the viewport with this point.\n            let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n            // If the overlay, without any further work, fits into the viewport, use this position.\n            if (overlayFit.isCompletelyWithinViewport) {\n                this._isPushed = false;\n                this._applyPosition(pos, originPoint);\n                return;\n            }\n            // If the overlay has flexible dimensions, we can use this position\n            // so long as there's enough space for the minimum dimensions.\n            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                // Save positions where the overlay will fit with flexible dimensions. We will use these\n                // if none of the positions fit *without* flexible dimensions.\n                flexibleFits.push({\n                    position: pos,\n                    origin: originPoint,\n                    overlayRect,\n                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos),\n                });\n                continue;\n            }\n            // If the current preferred position does not fit on the screen, remember the position\n            // if it has more visible area on-screen than we've seen and move onto the next preferred\n            // position.\n            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                fallback = { overlayFit, overlayPoint, originPoint, position: pos, overlayRect };\n            }\n        }\n        // If there are any positions where the overlay would fit with flexible dimensions, choose the\n        // one that has the greatest area available modified by the position's weight\n        if (flexibleFits.length) {\n            let bestFit = null;\n            let bestScore = -1;\n            for (const fit of flexibleFits) {\n                const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestFit = fit;\n                }\n            }\n            this._isPushed = false;\n            this._applyPosition(bestFit.position, bestFit.origin);\n            return;\n        }\n        // When none of the preferred positions fit within the viewport, take the position\n        // that went off-screen the least and attempt to push it on-screen.\n        if (this._canPush) {\n            // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n            this._isPushed = true;\n            this._applyPosition(fallback.position, fallback.originPoint);\n            return;\n        }\n        // All options for getting the overlay within the viewport have been exhausted, so go with the\n        // position that went off-screen the least.\n        this._applyPosition(fallback.position, fallback.originPoint);\n    }\n    detach() {\n        this._clearPanelClasses();\n        this._lastPosition = null;\n        this._previousPushAmount = null;\n        this._resizeSubscription.unsubscribe();\n    }\n    /** Cleanup after the element gets destroyed. */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // We can't use `_resetBoundingBoxStyles` here, because it resets\n        // some properties to zero, rather than removing them.\n        if (this._boundingBox) {\n            extendStyles(this._boundingBox.style, {\n                top: '',\n                left: '',\n                right: '',\n                bottom: '',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        }\n        if (this._pane) {\n            this._resetOverlayElementStyles();\n        }\n        if (this._overlayRef) {\n            this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n        }\n        this.detach();\n        this._positionChanges.complete();\n        this._overlayRef = this._boundingBox = null;\n        this._isDisposed = true;\n    }\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    reapplyLastPosition() {\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        const lastPosition = this._lastPosition;\n        if (lastPosition) {\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            this._viewportRect = this._getNarrowedViewportRect();\n            this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n            const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);\n            this._applyPosition(lastPosition, originPoint);\n        }\n        else {\n            this.apply();\n        }\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._scrollables = scrollables;\n        return this;\n    }\n    /**\n     * Adds new preferred positions.\n     * @param positions List of positions options for this overlay.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions;\n        // If the last calculated position object isn't part of the positions anymore, clear\n        // it in order to avoid it being picked up if the consumer tries to re-apply.\n        if (positions.indexOf(this._lastPosition) === -1) {\n            this._lastPosition = null;\n        }\n        this._validatePositions();\n        return this;\n    }\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @param margin Required margin between the overlay and the viewport edge in pixels.\n     */\n    withViewportMargin(margin) {\n        this._viewportMargin = margin;\n        return this;\n    }\n    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n    withFlexibleDimensions(flexibleDimensions = true) {\n        this._hasFlexibleDimensions = flexibleDimensions;\n        return this;\n    }\n    /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n    withGrowAfterOpen(growAfterOpen = true) {\n        this._growAfterOpen = growAfterOpen;\n        return this;\n    }\n    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    withPush(canPush = true) {\n        this._canPush = canPush;\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked = true) {\n        this._positionLocked = isLocked;\n        return this;\n    }\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @param origin Reference to the new origin.\n     */\n    setOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @param offset New offset in the X axis.\n     */\n    withDefaultOffsetX(offset) {\n        this._offsetX = offset;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @param offset New offset in the Y axis.\n     */\n    withDefaultOffsetY(offset) {\n        this._offsetY = offset;\n        return this;\n    }\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @param selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     */\n    withTransformOriginOn(selector) {\n        this._transformOriginSelector = selector;\n        return this;\n    }\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     */\n    _getOriginPoint(originRect, containerRect, pos) {\n        let x;\n        if (pos.originX == 'center') {\n            // Note: when centering we should always use the `left`\n            // offset, otherwise the position will be wrong in RTL.\n            x = originRect.left + originRect.width / 2;\n        }\n        else {\n            const startX = this._isRtl() ? originRect.right : originRect.left;\n            const endX = this._isRtl() ? originRect.left : originRect.right;\n            x = pos.originX == 'start' ? startX : endX;\n        }\n        // When zooming in Safari the container rectangle contains negative values for the position\n        // and we need to re-add them to the calculated coordinates.\n        if (containerRect.left < 0) {\n            x -= containerRect.left;\n        }\n        let y;\n        if (pos.originY == 'center') {\n            y = originRect.top + originRect.height / 2;\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        // Normally the containerRect's top value would be zero, however when the overlay is attached to an input\n        // (e.g. in an autocomplete), mobile browsers will shift everything in order to put the input in the middle\n        // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n        // otherwise our positioning will be thrown off.\n        // Additionally, when zooming in Safari this fixes the vertical position.\n        if (containerRect.top < 0) {\n            y -= containerRect.top;\n        }\n        return { x, y };\n    }\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     */\n    _getOverlayPoint(originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the\n        // potential overlay position relative to the origin point.\n        let overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n        }\n        let overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY,\n        };\n    }\n    /** Gets how well an overlay at the given point will fit within the viewport. */\n    _getOverlayFit(point, rawOverlayRect, viewport, position) {\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        let { x, y } = point;\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        // Account for the offsets since they could push the overlay out of the viewport.\n        if (offsetX) {\n            x += offsetX;\n        }\n        if (offsetY) {\n            y += offsetY;\n        }\n        // How much the overlay would overflow at this position, on each side.\n        let leftOverflow = 0 - x;\n        let rightOverflow = x + overlay.width - viewport.width;\n        let topOverflow = 0 - y;\n        let bottomOverflow = y + overlay.height - viewport.height;\n        // Visible parts of the element on each axis.\n        let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n        let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n        let visibleArea = visibleWidth * visibleHeight;\n        return {\n            visibleArea,\n            isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,\n            fitsInViewportVertically: visibleHeight === overlay.height,\n            fitsInViewportHorizontally: visibleWidth == overlay.width,\n        };\n    }\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @param fit How well the overlay fits in the viewport at some position.\n     * @param point The (x, y) coordinates of the overlay at some position.\n     * @param viewport The geometry of the viewport.\n     */\n    _canFitWithFlexibleDimensions(fit, point, viewport) {\n        if (this._hasFlexibleDimensions) {\n            const availableHeight = viewport.bottom - point.y;\n            const availableWidth = viewport.right - point.x;\n            const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n            const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n            const verticalFit = fit.fitsInViewportVertically || (minHeight != null && minHeight <= availableHeight);\n            const horizontalFit = fit.fitsInViewportHorizontally || (minWidth != null && minWidth <= availableWidth);\n            return verticalFit && horizontalFit;\n        }\n        return false;\n    }\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the\n     * right and bottom).\n     *\n     * @param start Starting point from which the overlay is pushed.\n     * @param rawOverlayRect Dimensions of the overlay.\n     * @param scrollPosition Current viewport scroll position.\n     * @returns The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {\n        // If the position is locked and we've pushed the overlay already, reuse the previous push\n        // amount, rather than pushing it again. If we were to continue pushing, the element would\n        // remain in the viewport, which goes against the expectations when position locking is enabled.\n        if (this._previousPushAmount && this._positionLocked) {\n            return {\n                x: start.x + this._previousPushAmount.x,\n                y: start.y + this._previousPushAmount.y,\n            };\n        }\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        const viewport = this._viewportRect;\n        // Determine how much the overlay goes outside the viewport on each\n        // side, which we'll use to decide which direction to push it.\n        const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n        const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n        const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n        const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n        // Amount by which to push the overlay in each axis such that it remains on-screen.\n        let pushX = 0;\n        let pushY = 0;\n        // If the overlay fits completely within the bounds of the viewport, push it from whichever\n        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n        // viewport and allow for the trailing end of the overlay to go out of bounds.\n        if (overlay.width <= viewport.width) {\n            pushX = overflowLeft || -overflowRight;\n        }\n        else {\n            pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;\n        }\n        if (overlay.height <= viewport.height) {\n            pushY = overflowTop || -overflowBottom;\n        }\n        else {\n            pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;\n        }\n        this._previousPushAmount = { x: pushX, y: pushY };\n        return {\n            x: start.x + pushX,\n            y: start.y + pushY,\n        };\n    }\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @param position The position preference\n     * @param originPoint The point on the origin element where the overlay is connected.\n     */\n    _applyPosition(position, originPoint) {\n        this._setTransformOrigin(position);\n        this._setOverlayElementStyles(originPoint, position);\n        this._setBoundingBoxStyles(originPoint, position);\n        if (position.panelClass) {\n            this._addPanelClasses(position.panelClass);\n        }\n        // Notify that the position has been changed along with its change properties.\n        // We only emit if we've got any subscriptions, because the scroll visibility\n        // calculations can be somewhat expensive.\n        if (this._positionChanges.observers.length) {\n            const scrollVisibility = this._getScrollVisibility();\n            // We're recalculating on scroll, but we only want to emit if anything\n            // changed since downstream code might be hitting the `NgZone`.\n            if (position !== this._lastPosition ||\n                !this._lastScrollVisibility ||\n                !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {\n                const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);\n                this._positionChanges.next(changeEvent);\n            }\n            this._lastScrollVisibility = scrollVisibility;\n        }\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastPosition = position;\n        this._isInitialRender = false;\n    }\n    /** Sets the transform origin based on the configured selector and the passed-in position.  */\n    _setTransformOrigin(position) {\n        if (!this._transformOriginSelector) {\n            return;\n        }\n        const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n        let xOrigin;\n        let yOrigin = position.overlayY;\n        if (position.overlayX === 'center') {\n            xOrigin = 'center';\n        }\n        else if (this._isRtl()) {\n            xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n        }\n        else {\n            xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n        }\n        for (let i = 0; i < elements.length; i++) {\n            elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n        }\n    }\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     */\n    _calculateBoundingBoxRect(origin, position) {\n        const viewport = this._viewportRect;\n        const isRtl = this._isRtl();\n        let height, top, bottom;\n        if (position.overlayY === 'top') {\n            // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n            top = origin.y;\n            height = viewport.height - top + this._viewportMargin;\n        }\n        else if (position.overlayY === 'bottom') {\n            // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n            // the viewport margin back in, because the viewport rect is narrowed down to remove the\n            // margin, whereas the `origin` position is calculated based on its `DOMRect`.\n            bottom = viewport.height - origin.y + this._viewportMargin * 2;\n            height = viewport.height - bottom + this._viewportMargin;\n        }\n        else {\n            // If neither top nor bottom, it means that the overlay is vertically centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n            // `origin.y - viewport.top`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n            const previousHeight = this._lastBoundingBoxSize.height;\n            height = smallestDistanceToViewportEdge * 2;\n            top = origin.y - smallestDistanceToViewportEdge;\n            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                top = origin.y - previousHeight / 2;\n            }\n        }\n        // The overlay is opening 'right-ward' (the content flows to the right).\n        const isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) || (position.overlayX === 'end' && isRtl);\n        // The overlay is opening 'left-ward' (the content flows to the left).\n        const isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) || (position.overlayX === 'start' && isRtl);\n        let width, left, right;\n        if (isBoundedByLeftViewportEdge) {\n            right = viewport.width - origin.x + this._viewportMargin * 2;\n            width = origin.x - this._viewportMargin;\n        }\n        else if (isBoundedByRightViewportEdge) {\n            left = origin.x;\n            width = viewport.right - origin.x;\n        }\n        else {\n            // If neither start nor end, it means that the overlay is horizontally centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.right - origin.x` and\n            // `origin.x - viewport.left`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n            const previousWidth = this._lastBoundingBoxSize.width;\n            width = smallestDistanceToViewportEdge * 2;\n            left = origin.x - smallestDistanceToViewportEdge;\n            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                left = origin.x - previousWidth / 2;\n            }\n        }\n        return { top: top, left: left, bottom: bottom, right: right, width, height };\n    }\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stretches to the bounds of the viewport.\n     *\n     * @param origin The point on the origin element where the overlay is connected.\n     * @param position The position preference\n     */\n    _setBoundingBoxStyles(origin, position) {\n        const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n        // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n        // when applying a new size.\n        if (!this._isInitialRender && !this._growAfterOpen) {\n            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n        }\n        const styles = {};\n        if (this._hasExactPosition()) {\n            styles.top = styles.left = '0';\n            styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n            styles.width = styles.height = '100%';\n        }\n        else {\n            const maxHeight = this._overlayRef.getConfig().maxHeight;\n            const maxWidth = this._overlayRef.getConfig().maxWidth;\n            styles.height = coerceCssPixelValue(boundingBoxRect.height);\n            styles.top = coerceCssPixelValue(boundingBoxRect.top);\n            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n            styles.width = coerceCssPixelValue(boundingBoxRect.width);\n            styles.left = coerceCssPixelValue(boundingBoxRect.left);\n            styles.right = coerceCssPixelValue(boundingBoxRect.right);\n            // Push the pane content towards the proper direction.\n            if (position.overlayX === 'center') {\n                styles.alignItems = 'center';\n            }\n            else {\n                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n            }\n            if (position.overlayY === 'center') {\n                styles.justifyContent = 'center';\n            }\n            else {\n                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n            }\n            if (maxHeight) {\n                styles.maxHeight = coerceCssPixelValue(maxHeight);\n            }\n            if (maxWidth) {\n                styles.maxWidth = coerceCssPixelValue(maxWidth);\n            }\n        }\n        this._lastBoundingBoxSize = boundingBoxRect;\n        extendStyles(this._boundingBox.style, styles);\n    }\n    /** Resets the styles for the bounding box so that a new positioning can be computed. */\n    _resetBoundingBoxStyles() {\n        extendStyles(this._boundingBox.style, {\n            top: '0',\n            left: '0',\n            right: '0',\n            bottom: '0',\n            height: '',\n            width: '',\n            alignItems: '',\n            justifyContent: '',\n        });\n    }\n    /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n    _resetOverlayElementStyles() {\n        extendStyles(this._pane.style, {\n            top: '',\n            left: '',\n            bottom: '',\n            right: '',\n            position: '',\n            transform: '',\n        });\n    }\n    /** Sets positioning styles to the overlay element. */\n    _setOverlayElementStyles(originPoint, position) {\n        const styles = {};\n        const hasExactPosition = this._hasExactPosition();\n        const hasFlexibleDimensions = this._hasFlexibleDimensions;\n        const config = this._overlayRef.getConfig();\n        if (hasExactPosition) {\n            const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n        }\n        else {\n            styles.position = 'static';\n        }\n        // Use a transform to apply the offsets. We do this because the `center` positions rely on\n        // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n        // off the position. We also can't use margins, because they won't have an effect in some\n        // cases where the element doesn't have anything to \"push off of\". Finally, this works\n        // better both with flexible and non-flexible positioning.\n        let transformString = '';\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        if (offsetX) {\n            transformString += `translateX(${offsetX}px) `;\n        }\n        if (offsetY) {\n            transformString += `translateY(${offsetY}px)`;\n        }\n        styles.transform = transformString.trim();\n        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n        // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n        // Note that this doesn't apply when we have an exact position, in which case we do want to\n        // apply them because they'll be cleared from the bounding box.\n        if (config.maxHeight) {\n            if (hasExactPosition) {\n                styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxHeight = '';\n            }\n        }\n        if (config.maxWidth) {\n            if (hasExactPosition) {\n                styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxWidth = '';\n            }\n        }\n        extendStyles(this._pane.style, styles);\n    }\n    /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayY(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the\n        // preferred position has changed since the last `apply`.\n        let styles = { top: '', bottom: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n        // above or below the origin and the direction in which the element will expand.\n        if (position.overlayY === 'bottom') {\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            const documentHeight = this._document.documentElement.clientHeight;\n            styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n        }\n        else {\n            styles.top = coerceCssPixelValue(overlayPoint.y);\n        }\n        return styles;\n    }\n    /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayX(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        let styles = { left: '', right: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        let horizontalStyleProperty;\n        if (this._isRtl()) {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        if (horizontalStyleProperty === 'right') {\n            const documentWidth = this._document.documentElement.clientWidth;\n            styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n        }\n        else {\n            styles.left = coerceCssPixelValue(overlayPoint.x);\n        }\n        return styles;\n    }\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     */\n    _getScrollVisibility() {\n        // Note: needs fresh rects since the position could've changed.\n        const originBounds = this._getOriginRect();\n        const overlayBounds = this._pane.getBoundingClientRect();\n        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n        // every time, we should be able to use the scrollTop of the containers if the size of those\n        // containers hasn't changed.\n        const scrollContainerBounds = this._scrollables.map(scrollable => {\n            return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n        });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    }\n    /** Subtracts the amount that an element is overflowing on an axis from its length. */\n    _subtractOverflows(length, ...overflows) {\n        return overflows.reduce((currentValue, currentOverflow) => {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    }\n    /** Narrows the given viewport rect by the current _viewportMargin. */\n    _getNarrowedViewportRect() {\n        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n        // and `innerHeight` that do. This is necessary, because the overlay container uses\n        // 100% `width` and `height` which don't include the scrollbar either.\n        const width = this._document.documentElement.clientWidth;\n        const height = this._document.documentElement.clientHeight;\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        return {\n            top: scrollPosition.top + this._viewportMargin,\n            left: scrollPosition.left + this._viewportMargin,\n            right: scrollPosition.left + width - this._viewportMargin,\n            bottom: scrollPosition.top + height - this._viewportMargin,\n            width: width - 2 * this._viewportMargin,\n            height: height - 2 * this._viewportMargin,\n        };\n    }\n    /** Whether the we're dealing with an RTL context */\n    _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /** Determines whether the overlay uses exact or flexible positioning. */\n    _hasExactPosition() {\n        return !this._hasFlexibleDimensions || this._isPushed;\n    }\n    /** Retrieves the offset of a position along the x or y axis. */\n    _getOffset(position, axis) {\n        if (axis === 'x') {\n            // We don't do something like `position['offset' + axis]` in\n            // order to avoid breaking minifiers that rename properties.\n            return position.offsetX == null ? this._offsetX : position.offsetX;\n        }\n        return position.offsetY == null ? this._offsetY : position.offsetY;\n    }\n    /** Validates that the current position match the expected values. */\n    _validatePositions() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!this._preferredPositions.length) {\n                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n            }\n            // TODO(crisbeto): remove these once Angular's template type\n            // checking is advanced enough to catch these cases.\n            this._preferredPositions.forEach(pair => {\n                validateHorizontalPosition('originX', pair.originX);\n                validateVerticalPosition('originY', pair.originY);\n                validateHorizontalPosition('overlayX', pair.overlayX);\n                validateVerticalPosition('overlayY', pair.overlayY);\n            });\n        }\n    }\n    /** Adds a single CSS class or an array of classes on the overlay panel. */\n    _addPanelClasses(cssClasses) {\n        if (this._pane) {\n            coerceArray(cssClasses).forEach(cssClass => {\n                if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                    this._appliedPanelClasses.push(cssClass);\n                    this._pane.classList.add(cssClass);\n                }\n            });\n        }\n    }\n    /** Clears the classes that the position strategy has applied from the overlay panel. */\n    _clearPanelClasses() {\n        if (this._pane) {\n            this._appliedPanelClasses.forEach(cssClass => {\n                this._pane.classList.remove(cssClass);\n            });\n            this._appliedPanelClasses = [];\n        }\n    }\n    /** Returns the DOMRect of the current origin. */\n    _getOriginRect() {\n        const origin = this._origin;\n        if (origin instanceof ElementRef) {\n            return origin.nativeElement.getBoundingClientRect();\n        }\n        // Check for Element so SVG elements are also supported.\n        if (origin instanceof Element) {\n            return origin.getBoundingClientRect();\n        }\n        const width = origin.width || 0;\n        const height = origin.height || 0;\n        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n        return {\n            top: origin.y,\n            bottom: origin.y + height,\n            left: origin.x,\n            right: origin.x + width,\n            height,\n            width,\n        };\n    }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            destination[key] = source[key];\n        }\n    }\n    return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n    if (typeof input !== 'number' && input != null) {\n        const [value, units] = input.split(cssUnitPattern);\n        return !units || units === 'px' ? parseFloat(value) : null;\n    }\n    return input || null;\n}\n/**\n * Gets a version of an element's bounding `DOMRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `DOMRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect) {\n    return {\n        top: Math.floor(clientRect.top),\n        right: Math.floor(clientRect.right),\n        bottom: Math.floor(clientRect.bottom),\n        left: Math.floor(clientRect.left),\n        width: Math.floor(clientRect.width),\n        height: Math.floor(clientRect.height),\n    };\n}\n/** Returns whether two `ScrollingVisibility` objects are identical. */\nfunction compareScrollVisibility(a, b) {\n    if (a === b) {\n        return true;\n    }\n    return (a.isOriginClipped === b.isOriginClipped &&\n        a.isOriginOutsideView === b.isOriginOutsideView &&\n        a.isOverlayClipped === b.isOverlayClipped &&\n        a.isOverlayOutsideView === b.isOverlayOutsideView);\n}\nconst STANDARD_DROPDOWN_BELOW_POSITIONS = [\n    { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n    { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom' },\n    { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' },\n    { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom' },\n];\nconst STANDARD_DROPDOWN_ADJACENT_POSITIONS = [\n    { originX: 'end', originY: 'top', overlayX: 'start', overlayY: 'top' },\n    { originX: 'end', originY: 'bottom', overlayX: 'start', overlayY: 'bottom' },\n    { originX: 'start', originY: 'top', overlayX: 'end', overlayY: 'top' },\n    { originX: 'start', originY: 'bottom', overlayX: 'end', overlayY: 'bottom' },\n];\n\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n    constructor() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._alignItems = '';\n        this._xPosition = '';\n        this._xOffset = '';\n        this._width = '';\n        this._height = '';\n        this._isDisposed = false;\n    }\n    attach(overlayRef) {\n        const config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n        overlayRef.hostElement.classList.add(wrapperClass);\n        this._isDisposed = false;\n    }\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    top(value = '') {\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    left(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'left';\n        return this;\n    }\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    bottom(value = '') {\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    right(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'right';\n        return this;\n    }\n    /**\n     * Sets the overlay to the start of the viewport, depending on the overlay direction.\n     * This will be to the left in LTR layouts and to the right in RTL.\n     * @param offset Offset from the edge of the screen.\n     */\n    start(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'start';\n        return this;\n    }\n    /**\n     * Sets the overlay to the end of the viewport, depending on the overlay direction.\n     * This will be to the right in LTR layouts and to the left in RTL.\n     * @param offset Offset from the edge of the screen.\n     */\n    end(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'end';\n        return this;\n    }\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    width(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    }\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    height(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    }\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    centerHorizontally(offset = '') {\n        this.left(offset);\n        this._xPosition = 'center';\n        return this;\n    }\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    centerVertically(offset = '') {\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    }\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     */\n    apply() {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parentStyles = this._overlayRef.hostElement.style;\n        const config = this._overlayRef.getConfig();\n        const { width, height, maxWidth, maxHeight } = config;\n        const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') &&\n            (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n        const shouldBeFlushVertically = (height === '100%' || height === '100vh') &&\n            (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n        const xPosition = this._xPosition;\n        const xOffset = this._xOffset;\n        const isRtl = this._overlayRef.getConfig().direction === 'rtl';\n        let marginLeft = '';\n        let marginRight = '';\n        let justifyContent = '';\n        if (shouldBeFlushHorizontally) {\n            justifyContent = 'flex-start';\n        }\n        else if (xPosition === 'center') {\n            justifyContent = 'center';\n            if (isRtl) {\n                marginRight = xOffset;\n            }\n            else {\n                marginLeft = xOffset;\n            }\n        }\n        else if (isRtl) {\n            if (xPosition === 'left' || xPosition === 'end') {\n                justifyContent = 'flex-end';\n                marginLeft = xOffset;\n            }\n            else if (xPosition === 'right' || xPosition === 'start') {\n                justifyContent = 'flex-start';\n                marginRight = xOffset;\n            }\n        }\n        else if (xPosition === 'left' || xPosition === 'start') {\n            justifyContent = 'flex-start';\n            marginLeft = xOffset;\n        }\n        else if (xPosition === 'right' || xPosition === 'end') {\n            justifyContent = 'flex-end';\n            marginRight = xOffset;\n        }\n        styles.position = this._cssPosition;\n        styles.marginLeft = shouldBeFlushHorizontally ? '0' : marginLeft;\n        styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = shouldBeFlushHorizontally ? '0' : marginRight;\n        parentStyles.justifyContent = justifyContent;\n        parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n    }\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * @docs-private\n     */\n    dispose() {\n        if (this._isDisposed || !this._overlayRef) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parent = this._overlayRef.hostElement;\n        const parentStyles = parent.style;\n        parent.classList.remove(wrapperClass);\n        parentStyles.justifyContent =\n            parentStyles.alignItems =\n                styles.marginTop =\n                    styles.marginBottom =\n                        styles.marginLeft =\n                            styles.marginRight =\n                                styles.position =\n                                    '';\n        this._overlayRef = null;\n        this._isDisposed = true;\n    }\n}\n\n/** Builder for overlay position strategy. */\nclass OverlayPositionBuilder {\n    constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    global() {\n        return new GlobalPositionStrategy();\n    }\n    /**\n     * Creates a flexible position strategy.\n     * @param origin Origin relative to which to position the overlay.\n     */\n    flexibleConnectedTo(origin) {\n        return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayPositionBuilder, deps: [{ token: i1.ViewportRuler }, { token: DOCUMENT }, { token: i1$1.Platform }, { token: OverlayContainer }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayPositionBuilder, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayPositionBuilder, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.ViewportRuler }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i1$1.Platform }, { type: OverlayContainer }] });\n\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\n// Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n// which needs to be different depending on where OverlayModule is imported.\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n    constructor(\n    /** Scrolling strategies that can be used when creating an overlay. */\n    scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher, _animationsModuleType) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._directionality = _directionality;\n        this._location = _location;\n        this._outsideClickDispatcher = _outsideClickDispatcher;\n        this._animationsModuleType = _animationsModuleType;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    create(config) {\n        const host = this._createHostElement();\n        const pane = this._createPaneElement(host);\n        const portalOutlet = this._createPortalOutlet(pane);\n        const overlayConfig = new OverlayConfig(config);\n        overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n        return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === 'NoopAnimations');\n    }\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    position() {\n        return this._positionBuilder;\n    }\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @returns Newly-created pane element\n     */\n    _createPaneElement(host) {\n        const pane = this._document.createElement('div');\n        pane.id = `cdk-overlay-${nextUniqueId++}`;\n        pane.classList.add('cdk-overlay-pane');\n        host.appendChild(pane);\n        return pane;\n    }\n    /**\n     * Creates the host element that wraps around an overlay\n     * and can be used for advanced positioning.\n     * @returns Newly-create host element.\n     */\n    _createHostElement() {\n        const host = this._document.createElement('div');\n        this._overlayContainer.getContainerElement().appendChild(host);\n        return host;\n    }\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param pane The DOM element to turn into a portal outlet.\n     * @returns A portal outlet for the given DOM element.\n     */\n    _createPortalOutlet(pane) {\n        // We have to resolve the ApplicationRef later in order to allow people\n        // to use overlay-based providers during app initialization.\n        if (!this._appRef) {\n            this._appRef = this._injector.get(ApplicationRef);\n        }\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: Overlay, deps: [{ token: ScrollStrategyOptions }, { token: OverlayContainer }, { token: i0.ComponentFactoryResolver }, { token: OverlayPositionBuilder }, { token: OverlayKeyboardDispatcher }, { token: i0.Injector }, { token: i0.NgZone }, { token: DOCUMENT }, { token: i5.Directionality }, { token: i6.Location }, { token: OverlayOutsideClickDispatcher }, { token: ANIMATION_MODULE_TYPE, optional: true }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: Overlay, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: Overlay, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: ScrollStrategyOptions }, { type: OverlayContainer }, { type: i0.ComponentFactoryResolver }, { type: OverlayPositionBuilder }, { type: OverlayKeyboardDispatcher }, { type: i0.Injector }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i5.Directionality }, { type: i6.Location }, { type: OverlayOutsideClickDispatcher }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [ANIMATION_MODULE_TYPE]\n                }, {\n                    type: Optional\n                }] }] });\n\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [\n    {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top',\n    },\n    {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom',\n    },\n    {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom',\n    },\n    {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top',\n    },\n];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy', {\n    providedIn: 'root',\n    factory: () => {\n        const overlay = inject(Overlay);\n        return () => overlay.scrollStrategies.reposition();\n    },\n});\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef) {\n        this.elementRef = elementRef;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkOverlayOrigin, deps: [{ token: i0.ElementRef }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkOverlayOrigin, isStandalone: true, selector: \"[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\", exportAs: [\"cdkOverlayOrigin\"], ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkOverlayOrigin, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }] });\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n    /** The offset in pixels for the overlay connection point on the x-axis */\n    get offsetX() {\n        return this._offsetX;\n    }\n    set offsetX(offsetX) {\n        this._offsetX = offsetX;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /** The offset in pixels for the overlay connection point on the y-axis */\n    get offsetY() {\n        return this._offsetY;\n    }\n    set offsetY(offsetY) {\n        this._offsetY = offsetY;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */\n    get disposeOnNavigation() {\n        return this._disposeOnNavigation;\n    }\n    set disposeOnNavigation(value) {\n        this._disposeOnNavigation = value;\n    }\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n        this._overlay = _overlay;\n        this._dir = _dir;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._attachSubscription = Subscription.EMPTY;\n        this._detachSubscription = Subscription.EMPTY;\n        this._positionSubscription = Subscription.EMPTY;\n        this._disposeOnNavigation = false;\n        this._ngZone = inject(NgZone);\n        /** Margin between the overlay and the viewport edges. */\n        this.viewportMargin = 0;\n        /** Whether the overlay is open. */\n        this.open = false;\n        /** Whether the overlay can be closed by user interaction. */\n        this.disableClose = false;\n        /** Whether or not the overlay should attach a backdrop. */\n        this.hasBackdrop = false;\n        /** Whether or not the overlay should be locked when scrolling. */\n        this.lockPosition = false;\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        this.flexibleDimensions = false;\n        /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n        this.growAfterOpen = false;\n        /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n        this.push = false;\n        /** Event emitted when the backdrop is clicked. */\n        this.backdropClick = new EventEmitter();\n        /** Event emitted when the position has changed. */\n        this.positionChange = new EventEmitter();\n        /** Event emitted when the overlay has been attached. */\n        this.attach = new EventEmitter();\n        /** Event emitted when the overlay has been detached. */\n        this.detach = new EventEmitter();\n        /** Emits when there are keyboard events that are targeted at the overlay. */\n        this.overlayKeydown = new EventEmitter();\n        /** Emits when there are mouse outside click events that are targeted at the overlay. */\n        this.overlayOutsideClick = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n        this._scrollStrategyFactory = scrollStrategyFactory;\n        this.scrollStrategy = this._scrollStrategyFactory();\n    }\n    /** The associated overlay reference. */\n    get overlayRef() {\n        return this._overlayRef;\n    }\n    /** The element's layout direction. */\n    get dir() {\n        return this._dir ? this._dir.value : 'ltr';\n    }\n    ngOnDestroy() {\n        this._attachSubscription.unsubscribe();\n        this._detachSubscription.unsubscribe();\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n    }\n    ngOnChanges(changes) {\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n            this._overlayRef.updateSize({\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n            });\n            if (changes['origin'] && this.open) {\n                this._position.apply();\n            }\n        }\n        if (changes['open']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    }\n    /** Creates an overlay */\n    _createOverlay() {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        const overlayRef = (this._overlayRef = this._overlay.create(this._buildConfig()));\n        this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n        this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n        overlayRef.keydownEvents().subscribe((event) => {\n            this.overlayKeydown.next(event);\n            if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n                event.preventDefault();\n                this._detachOverlay();\n            }\n        });\n        this._overlayRef.outsidePointerEvents().subscribe((event) => {\n            const origin = this._getOriginElement();\n            const target = _getEventTarget(event);\n            if (!origin || (origin !== target && !origin.contains(target))) {\n                this.overlayOutsideClick.next(event);\n            }\n        });\n    }\n    /** Builds the overlay config based on the directive's inputs */\n    _buildConfig() {\n        const positionStrategy = (this._position =\n            this.positionStrategy || this._createPositionStrategy());\n        const overlayConfig = new OverlayConfig({\n            direction: this._dir,\n            positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop,\n            disposeOnNavigation: this.disposeOnNavigation,\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        if (this.panelClass) {\n            overlayConfig.panelClass = this.panelClass;\n        }\n        return overlayConfig;\n    }\n    /** Updates the state of a position strategy, based on the values of the directive inputs. */\n    _updatePositionStrategy(positionStrategy) {\n        const positions = this.positions.map(currentPosition => ({\n            originX: currentPosition.originX,\n            originY: currentPosition.originY,\n            overlayX: currentPosition.overlayX,\n            overlayY: currentPosition.overlayY,\n            offsetX: currentPosition.offsetX || this.offsetX,\n            offsetY: currentPosition.offsetY || this.offsetY,\n            panelClass: currentPosition.panelClass || undefined,\n        }));\n        return positionStrategy\n            .setOrigin(this._getOrigin())\n            .withPositions(positions)\n            .withFlexibleDimensions(this.flexibleDimensions)\n            .withPush(this.push)\n            .withGrowAfterOpen(this.growAfterOpen)\n            .withViewportMargin(this.viewportMargin)\n            .withLockedPosition(this.lockPosition)\n            .withTransformOriginOn(this.transformOriginSelector);\n    }\n    /** Returns the position strategy of the overlay to be set on the overlay config */\n    _createPositionStrategy() {\n        const strategy = this._overlay.position().flexibleConnectedTo(this._getOrigin());\n        this._updatePositionStrategy(strategy);\n        return strategy;\n    }\n    _getOrigin() {\n        if (this.origin instanceof CdkOverlayOrigin) {\n            return this.origin.elementRef;\n        }\n        else {\n            return this.origin;\n        }\n    }\n    _getOriginElement() {\n        if (this.origin instanceof CdkOverlayOrigin) {\n            return this.origin.elementRef.nativeElement;\n        }\n        if (this.origin instanceof ElementRef) {\n            return this.origin.nativeElement;\n        }\n        if (typeof Element !== 'undefined' && this.origin instanceof Element) {\n            return this.origin;\n        }\n        return null;\n    }\n    /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n    _attachOverlay() {\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        else {\n            // Update the overlay size, in case the directive's inputs have changed\n            this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n        }\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n                this.backdropClick.emit(event);\n            });\n        }\n        else {\n            this._backdropSubscription.unsubscribe();\n        }\n        this._positionSubscription.unsubscribe();\n        // Only subscribe to `positionChanges` if requested, because putting\n        // together all the information for it can be expensive.\n        if (this.positionChange.observers.length > 0) {\n            this._positionSubscription = this._position.positionChanges\n                .pipe(takeWhile(() => this.positionChange.observers.length > 0))\n                .subscribe(position => {\n                this._ngZone.run(() => this.positionChange.emit(position));\n                if (this.positionChange.observers.length === 0) {\n                    this._positionSubscription.unsubscribe();\n                }\n            });\n        }\n    }\n    /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n    _detachOverlay() {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkConnectedOverlay, deps: [{ token: Overlay }, { token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY }, { token: i5.Directionality, optional: true }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.2.0\", type: CdkConnectedOverlay, isStandalone: true, selector: \"[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\", inputs: { origin: [\"cdkConnectedOverlayOrigin\", \"origin\"], positions: [\"cdkConnectedOverlayPositions\", \"positions\"], positionStrategy: [\"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"], offsetX: [\"cdkConnectedOverlayOffsetX\", \"offsetX\"], offsetY: [\"cdkConnectedOverlayOffsetY\", \"offsetY\"], width: [\"cdkConnectedOverlayWidth\", \"width\"], height: [\"cdkConnectedOverlayHeight\", \"height\"], minWidth: [\"cdkConnectedOverlayMinWidth\", \"minWidth\"], minHeight: [\"cdkConnectedOverlayMinHeight\", \"minHeight\"], backdropClass: [\"cdkConnectedOverlayBackdropClass\", \"backdropClass\"], panelClass: [\"cdkConnectedOverlayPanelClass\", \"panelClass\"], viewportMargin: [\"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"], scrollStrategy: [\"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"], open: [\"cdkConnectedOverlayOpen\", \"open\"], disableClose: [\"cdkConnectedOverlayDisableClose\", \"disableClose\"], transformOriginSelector: [\"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"], hasBackdrop: [\"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\", booleanAttribute], lockPosition: [\"cdkConnectedOverlayLockPosition\", \"lockPosition\", booleanAttribute], flexibleDimensions: [\"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\", booleanAttribute], growAfterOpen: [\"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\", booleanAttribute], push: [\"cdkConnectedOverlayPush\", \"push\", booleanAttribute], disposeOnNavigation: [\"cdkConnectedOverlayDisposeOnNavigation\", \"disposeOnNavigation\", booleanAttribute] }, outputs: { backdropClick: \"backdropClick\", positionChange: \"positionChange\", attach: \"attach\", detach: \"detach\", overlayKeydown: \"overlayKeydown\", overlayOutsideClick: \"overlayOutsideClick\" }, exportAs: [\"cdkConnectedOverlay\"], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkConnectedOverlay, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: Overlay }, { type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]\n                }] }, { type: i5.Directionality, decorators: [{\n                    type: Optional\n                }] }], propDecorators: { origin: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOrigin']\n            }], positions: [{\n                type: Input,\n                args: ['cdkConnectedOverlayPositions']\n            }], positionStrategy: [{\n                type: Input,\n                args: ['cdkConnectedOverlayPositionStrategy']\n            }], offsetX: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOffsetX']\n            }], offsetY: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOffsetY']\n            }], width: [{\n                type: Input,\n                args: ['cdkConnectedOverlayWidth']\n            }], height: [{\n                type: Input,\n                args: ['cdkConnectedOverlayHeight']\n            }], minWidth: [{\n                type: Input,\n                args: ['cdkConnectedOverlayMinWidth']\n            }], minHeight: [{\n                type: Input,\n                args: ['cdkConnectedOverlayMinHeight']\n            }], backdropClass: [{\n                type: Input,\n                args: ['cdkConnectedOverlayBackdropClass']\n            }], panelClass: [{\n                type: Input,\n                args: ['cdkConnectedOverlayPanelClass']\n            }], viewportMargin: [{\n                type: Input,\n                args: ['cdkConnectedOverlayViewportMargin']\n            }], scrollStrategy: [{\n                type: Input,\n                args: ['cdkConnectedOverlayScrollStrategy']\n            }], open: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOpen']\n            }], disableClose: [{\n                type: Input,\n                args: ['cdkConnectedOverlayDisableClose']\n            }], transformOriginSelector: [{\n                type: Input,\n                args: ['cdkConnectedOverlayTransformOriginOn']\n            }], hasBackdrop: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayHasBackdrop', transform: booleanAttribute }]\n            }], lockPosition: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayLockPosition', transform: booleanAttribute }]\n            }], flexibleDimensions: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayFlexibleDimensions', transform: booleanAttribute }]\n            }], growAfterOpen: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayGrowAfterOpen', transform: booleanAttribute }]\n            }], push: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayPush', transform: booleanAttribute }]\n            }], disposeOnNavigation: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayDisposeOnNavigation', transform: booleanAttribute }]\n            }], backdropClick: [{\n                type: Output\n            }], positionChange: [{\n                type: Output\n            }], attach: [{\n                type: Output\n            }], detach: [{\n                type: Output\n            }], overlayKeydown: [{\n                type: Output\n            }], overlayOutsideClick: [{\n                type: Output\n            }] } });\n/** @docs-private */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\nclass OverlayModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayModule, imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin], exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule] }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayModule, providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER], imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: OverlayModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n                    providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],\n                }]\n        }] });\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nclass FullscreenOverlayContainer extends OverlayContainer {\n    constructor(_document, platform) {\n        super(_document, platform);\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._fullScreenEventName && this._fullScreenListener) {\n            this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n        }\n    }\n    _createContainer() {\n        super._createContainer();\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n    }\n    _adjustParentForFullscreenChange() {\n        if (!this._containerElement) {\n            return;\n        }\n        const fullscreenElement = this.getFullscreenElement();\n        const parent = fullscreenElement || this._document.body;\n        parent.appendChild(this._containerElement);\n    }\n    _addFullscreenChangeListener(fn) {\n        const eventName = this._getEventName();\n        if (eventName) {\n            if (this._fullScreenListener) {\n                this._document.removeEventListener(eventName, this._fullScreenListener);\n            }\n            this._document.addEventListener(eventName, fn);\n            this._fullScreenListener = fn;\n        }\n    }\n    _getEventName() {\n        if (!this._fullScreenEventName) {\n            const _document = this._document;\n            if (_document.fullscreenEnabled) {\n                this._fullScreenEventName = 'fullscreenchange';\n            }\n            else if (_document.webkitFullscreenEnabled) {\n                this._fullScreenEventName = 'webkitfullscreenchange';\n            }\n            else if (_document.mozFullScreenEnabled) {\n                this._fullScreenEventName = 'mozfullscreenchange';\n            }\n            else if (_document.msFullscreenEnabled) {\n                this._fullScreenEventName = 'MSFullscreenChange';\n            }\n        }\n        return this._fullScreenEventName;\n    }\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    getFullscreenElement() {\n        const _document = this._document;\n        return (_document.fullscreenElement ||\n            _document.webkitFullscreenElement ||\n            _document.mozFullScreenElement ||\n            _document.msFullscreenElement ||\n            null);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: FullscreenOverlayContainer, deps: [{ token: DOCUMENT }, { token: i1$1.Platform }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: FullscreenOverlayContainer, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: FullscreenOverlayContainer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i1$1.Platform }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BlockScrollStrategy, CdkConnectedOverlay, CdkOverlayOrigin, CloseScrollStrategy, ConnectedOverlayPositionChange, ConnectionPositionPair, FlexibleConnectedPositionStrategy, FullscreenOverlayContainer, GlobalPositionStrategy, NoopScrollStrategy, Overlay, OverlayConfig, OverlayContainer, OverlayKeyboardDispatcher, OverlayModule, OverlayOutsideClickDispatcher, OverlayPositionBuilder, OverlayRef, RepositionScrollStrategy, STANDARD_DROPDOWN_ADJACENT_POSITIONS, STANDARD_DROPDOWN_BELOW_POSITIONS, ScrollStrategyOptions, ScrollingVisibility, validateHorizontalPosition, validateVerticalPosition };\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function takeWhile(predicate, inclusive = false) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const result = predicate(value, index++);\n            (result || inclusive) && subscriber.next(value);\n            !result && subscriber.complete();\n        }));\n    });\n}\n","import * as i0 from '@angular/core';\nimport { ElementRef, Injector, Directive, EventEmitter, Inject, Input, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n    /** Attach this portal to a host. */\n    attach(host) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (host == null) {\n                throwNullPortalOutletError();\n            }\n            if (host.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n        }\n        this._attachedHost = host;\n        return host.attach(this);\n    }\n    /** Detach this portal from its host */\n    detach() {\n        let host = this._attachedHost;\n        if (host != null) {\n            this._attachedHost = null;\n            host.detach();\n        }\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwNoPortalAttachedError();\n        }\n    }\n    /** Whether this portal is attached to a host. */\n    get isAttached() {\n        return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    setAttachedHost(host) {\n        this._attachedHost = host;\n    }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n    constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {\n        super();\n        this.component = component;\n        this.viewContainerRef = viewContainerRef;\n        this.injector = injector;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.projectableNodes = projectableNodes;\n    }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n    constructor(\n    /** The embedded template that will be used to instantiate an embedded View in the host. */\n    templateRef, \n    /** Reference to the ViewContainer into which the template will be stamped out. */\n    viewContainerRef, \n    /** Contextual data to be passed in to the embedded view. */\n    context, \n    /** The injector to use for the embedded view. */\n    injector) {\n        super();\n        this.templateRef = templateRef;\n        this.viewContainerRef = viewContainerRef;\n        this.context = context;\n        this.injector = injector;\n    }\n    get origin() {\n        return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    attach(host, context = this.context) {\n        this.context = context;\n        return super.attach(host);\n    }\n    detach() {\n        this.context = undefined;\n        return super.detach();\n    }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass DomPortal extends Portal {\n    constructor(element) {\n        super();\n        this.element = element instanceof ElementRef ? element.nativeElement : element;\n    }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n    constructor() {\n        /** Whether this host has already been permanently disposed. */\n        this._isDisposed = false;\n        // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n        this.attachDomPortal = null;\n    }\n    /** Whether this host has an attached portal. */\n    hasAttached() {\n        return !!this._attachedPortal;\n    }\n    /** Attaches a portal. */\n    attach(portal) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!portal) {\n                throwNullPortalError();\n            }\n            if (this.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n            if (this._isDisposed) {\n                throwPortalOutletAlreadyDisposedError();\n            }\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n            // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n        }\n        else if (this.attachDomPortal && portal instanceof DomPortal) {\n            this._attachedPortal = portal;\n            return this.attachDomPortal(portal);\n        }\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwUnknownPortalTypeError();\n        }\n    }\n    /** Detaches a previously attached portal. */\n    detach() {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    }\n    /** Permanently dispose of this portal host. */\n    dispose() {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    }\n    /** @docs-private */\n    setDisposeFn(fn) {\n        this._disposeFn = fn;\n    }\n    _invokeDisposeFn() {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {\n}\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n    /**\n     * @param outletElement Element into which the content is projected.\n     * @param _componentFactoryResolver Used to resolve the component factory.\n     *   Only required when attaching component portals.\n     * @param _appRef Reference to the application. Only used in component portals when there\n     *   is no `ViewContainerRef` available.\n     * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't\n     *   have one. Only used for component portals.\n     * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually\n     *   become a required parameter.\n     */\n    constructor(\n    /** Element into which the content is projected. */\n    outletElement, _componentFactoryResolver, _appRef, _defaultInjector, \n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document) {\n        super();\n        this.outletElement = outletElement;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._defaultInjector = _defaultInjector;\n        /**\n         * Attaches a DOM portal by transferring its content into the outlet.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 10.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            element.parentNode.insertBefore(anchorNode, element);\n            this.outletElement.appendChild(element);\n            this._attachedPortal = portal;\n            super.setDisposeFn(() => {\n                // We can't use `replaceWith` here because IE doesn't support it.\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        const resolver = (portal.componentFactoryResolver || this._componentFactoryResolver);\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !resolver) {\n            throw Error('Cannot attach component portal to outlet without a ComponentFactoryResolver.');\n        }\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        let componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || undefined);\n            this.setDisposeFn(() => componentRef.destroy());\n        }\n        else {\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._appRef) {\n                throw Error('Cannot attach component portal to outlet without an ApplicationRef.');\n            }\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(() => {\n                // Verify that the ApplicationRef has registered views before trying to detach a host view.\n                // This check also protects the `detachView` from being called on a destroyed ApplicationRef.\n                if (this._appRef.viewCount > 0) {\n                    this._appRef.detachView(componentRef.hostView);\n                }\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        this._attachedPortal = portal;\n        return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        let viewContainer = portal.viewContainerRef;\n        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {\n            injector: portal.injector,\n        });\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n        // Note that we want to detect changes after the nodes have been moved so that\n        // any directives inside the portal that are looking at the DOM inside a lifecycle\n        // hook won't be invoked too early.\n        viewRef.detectChanges();\n        this.setDisposeFn(() => {\n            let index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        });\n        this._attachedPortal = portal;\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     */\n    dispose() {\n        super.dispose();\n        this.outletElement.remove();\n    }\n    /** Gets the root HTMLElement for an instantiated component. */\n    _getComponentRootNode(componentRef) {\n        return componentRef.hostView.rootNodes[0];\n    }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {\n}\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nclass CdkPortal extends TemplatePortal {\n    constructor(templateRef, viewContainerRef) {\n        super(templateRef, viewContainerRef);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkPortal, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkPortal, isStandalone: true, selector: \"[cdkPortal]\", exportAs: [\"cdkPortal\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkPortal, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkPortal]',\n                    exportAs: 'cdkPortal',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }] });\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\nclass TemplatePortalDirective extends CdkPortal {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: TemplatePortalDirective, deps: null, target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: TemplatePortalDirective, isStandalone: true, selector: \"[cdk-portal], [portal]\", providers: [\n            {\n                provide: CdkPortal,\n                useExisting: TemplatePortalDirective,\n            },\n        ], exportAs: [\"cdkPortal\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: TemplatePortalDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-portal], [portal]',\n                    exportAs: 'cdkPortal',\n                    providers: [\n                        {\n                            provide: CdkPortal,\n                            useExisting: TemplatePortalDirective,\n                        },\n                    ],\n                    standalone: true,\n                }]\n        }] });\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nclass CdkPortalOutlet extends BasePortalOutlet {\n    constructor(_componentFactoryResolver, _viewContainerRef, \n    /**\n     * @deprecated `_document` parameter to be made required.\n     * @breaking-change 9.0.0\n     */\n    _document) {\n        super();\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._viewContainerRef = _viewContainerRef;\n        /** Whether the portal component is initialized. */\n        this._isInitialized = false;\n        /** Emits when a portal is attached to the outlet. */\n        this.attached = new EventEmitter();\n        /**\n         * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 9.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            portal.setAttachedHost(this);\n            element.parentNode.insertBefore(anchorNode, element);\n            this._getRootNode().appendChild(element);\n            this._attachedPortal = portal;\n            super.setDisposeFn(() => {\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /** Portal associated with the Portal outlet. */\n    get portal() {\n        return this._attachedPortal;\n    }\n    set portal(portal) {\n        // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n        // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n        // and attach a portal programmatically in the parent component. When Angular does the first CD\n        // round, it will fire the setter with empty string, causing the user's content to be cleared.\n        if (this.hasAttached() && !portal && !this._isInitialized) {\n            return;\n        }\n        if (this.hasAttached()) {\n            super.detach();\n        }\n        if (portal) {\n            super.attach(portal);\n        }\n        this._attachedPortal = portal || null;\n    }\n    /** Component or view reference that is attached to the portal. */\n    get attachedRef() {\n        return this._attachedRef;\n    }\n    ngOnInit() {\n        this._isInitialized = true;\n    }\n    ngOnDestroy() {\n        super.dispose();\n        this._attachedRef = this._attachedPortal = null;\n    }\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || undefined);\n        // If we're using a view container that's different from the injected one (e.g. when the portal\n        // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n        // inside of the alternate view container.\n        if (viewContainerRef !== this._viewContainerRef) {\n            this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n        }\n        super.setDisposeFn(() => ref.destroy());\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n    }\n    /**\n     * Attach the given TemplatePortal to this PortalHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        portal.setAttachedHost(this);\n        const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {\n            injector: portal.injector,\n        });\n        super.setDisposeFn(() => this._viewContainerRef.clear());\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n    }\n    /** Gets the root node of the portal outlet. */\n    _getRootNode() {\n        const nativeElement = this._viewContainerRef.element.nativeElement;\n        // The directive could be set on a template which will result in a comment\n        // node being the root. Use the comment's parent node if that is the case.\n        return (nativeElement.nodeType === nativeElement.ELEMENT_NODE\n            ? nativeElement\n            : nativeElement.parentNode);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkPortalOutlet, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ViewContainerRef }, { token: DOCUMENT }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkPortalOutlet, isStandalone: true, selector: \"[cdkPortalOutlet]\", inputs: { portal: [\"cdkPortalOutlet\", \"portal\"] }, outputs: { attached: \"attached\" }, exportAs: [\"cdkPortalOutlet\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkPortalOutlet, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkPortalOutlet]',\n                    exportAs: 'cdkPortalOutlet',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }], propDecorators: { portal: [{\n                type: Input,\n                args: ['cdkPortalOutlet']\n            }], attached: [{\n                type: Output\n            }] } });\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass PortalHostDirective extends CdkPortalOutlet {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: PortalHostDirective, deps: null, target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: PortalHostDirective, isStandalone: true, selector: \"[cdkPortalHost], [portalHost]\", inputs: { portal: [\"cdkPortalHost\", \"portal\"] }, providers: [\n            {\n                provide: CdkPortalOutlet,\n                useExisting: PortalHostDirective,\n            },\n        ], exportAs: [\"cdkPortalHost\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: PortalHostDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalHost',\n                    inputs: [{ name: 'portal', alias: 'cdkPortalHost' }],\n                    providers: [\n                        {\n                            provide: CdkPortalOutlet,\n                            useExisting: PortalHostDirective,\n                        },\n                    ],\n                    standalone: true,\n                }]\n        }] });\nclass PortalModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: PortalModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: PortalModule, imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective], exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective] }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: PortalModule }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: PortalModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n                    exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n                }]\n        }] });\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n    constructor(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    get(token, notFoundValue) {\n        const value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BasePortalHost, BasePortalOutlet, CdkPortal, CdkPortalOutlet, ComponentPortal, DomPortal, DomPortalHost, DomPortalOutlet, Portal, PortalHostDirective, PortalInjector, PortalModule, TemplatePortal, TemplatePortalDirective };\n","import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nexport function auditTime(duration, scheduler = asyncScheduler) {\n    return audit(() => timer(duration, scheduler));\n}\n","import { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function audit(durationSelector) {\n    return operate((source, subscriber) => {\n        let hasValue = false;\n        let lastValue = null;\n        let durationSubscriber = null;\n        let isComplete = false;\n        const endDuration = () => {\n            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            durationSubscriber = null;\n            if (hasValue) {\n                hasValue = false;\n                const value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n            isComplete && subscriber.complete();\n        };\n        const cleanupDuration = () => {\n            durationSubscriber = null;\n            isComplete && subscriber.complete();\n        };\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            hasValue = true;\n            lastValue = value;\n            if (!durationSubscriber) {\n                innerFrom(durationSelector(value)).subscribe((durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));\n            }\n        }, () => {\n            isComplete = true;\n            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }));\n    });\n}\n","import { coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, Directive, Input, Injectable, Optional, Inject, inject, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Output, ViewChild, SkipSelf, ElementRef, NgModule } from '@angular/core';\nimport { Subject, of, Observable, fromEvent, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/platform';\nimport { getRtlScrollAxisType, RtlScrollAxisType, supportsScrollBehavior, Platform } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i2$1 from '@angular/cdk/collections';\nimport { isDataSource, ArrayDataSource, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\n\n/** The injection token used to specify the virtual scrolling strategy. */\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new Subject();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() {\n        /* no-op */\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() {\n        /* no-op */\n    }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        // Prevent NaN as result when dividing by zero.\n        let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports fixed-size items. */\nclass CdkFixedSizeVirtualScroll {\n    constructor() {\n        this._itemSize = 20;\n        this._minBufferPx = 100;\n        this._maxBufferPx = 200;\n        /** The scroll strategy used by this directive. */\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    /** The size of the items in the list (in pixels). */\n    get itemSize() {\n        return this._itemSize;\n    }\n    set itemSize(value) {\n        this._itemSize = coerceNumberProperty(value);\n    }\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx() {\n        return this._minBufferPx;\n    }\n    set minBufferPx(value) {\n        this._minBufferPx = coerceNumberProperty(value);\n    }\n    /**\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n     */\n    get maxBufferPx() {\n        return this._maxBufferPx;\n    }\n    set maxBufferPx(value) {\n        this._maxBufferPx = coerceNumberProperty(value);\n    }\n    ngOnChanges() {\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkFixedSizeVirtualScroll, deps: [], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkFixedSizeVirtualScroll, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[itemSize]\", inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, providers: [\n            {\n                provide: VIRTUAL_SCROLL_STRATEGY,\n                useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                deps: [forwardRef(() => CdkFixedSizeVirtualScroll)],\n            },\n        ], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkFixedSizeVirtualScroll, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[itemSize]',\n                    standalone: true,\n                    providers: [\n                        {\n                            provide: VIRTUAL_SCROLL_STRATEGY,\n                            useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                            deps: [forwardRef(() => CdkFixedSizeVirtualScroll)],\n                        },\n                    ],\n                }]\n        }], propDecorators: { itemSize: [{\n                type: Input\n            }], minBufferPx: [{\n                type: Input\n            }], maxBufferPx: [{\n                type: Input\n            }] } });\n\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nclass ScrollDispatcher {\n    constructor(_ngZone, _platform, document) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n        this._scrolled = new Subject();\n        /** Keeps track of the global `scroll` and `resize` subscriptions. */\n        this._globalSubscription = null;\n        /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n        this._document = document;\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    register(scrollable) {\n        if (!this.scrollContainers.has(scrollable)) {\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));\n        }\n    }\n    /**\n     * De-registers a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    deregister(scrollable) {\n        const scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    }\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n        if (!this._platform.isBrowser) {\n            return of();\n        }\n        return new Observable((observer) => {\n            if (!this._globalSubscription) {\n                this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            const subscription = auditTimeInMs > 0\n                ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer)\n                : this._scrolled.subscribe(observer);\n            this._scrolledCount++;\n            return () => {\n                subscription.unsubscribe();\n                this._scrolledCount--;\n                if (!this._scrolledCount) {\n                    this._removeGlobalListener();\n                }\n            };\n        });\n    }\n    ngOnDestroy() {\n        this._removeGlobalListener();\n        this.scrollContainers.forEach((_, container) => this.deregister(container));\n        this._scrolled.complete();\n    }\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementOrElementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(target => {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    }\n    /** Returns all registered Scrollables that contain the provided element. */\n    getAncestorScrollContainers(elementOrElementRef) {\n        const scrollingContainers = [];\n        this.scrollContainers.forEach((_subscription, scrollable) => {\n            if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Returns true if the element is contained within the provided Scrollable. */\n    _scrollableContainsElement(scrollable, elementOrElementRef) {\n        let element = coerceElement(elementOrElementRef);\n        let scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while ((element = element.parentElement));\n        return false;\n    }\n    /** Sets up the global scroll listeners. */\n    _addGlobalListener() {\n        this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n            const window = this._getWindow();\n            return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n        });\n    }\n    /** Cleans up the global scroll listener. */\n    _removeGlobalListener() {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollDispatcher, deps: [{ token: i0.NgZone }, { token: i1.Platform }, { token: DOCUMENT, optional: true }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollDispatcher, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.Platform }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nclass CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        this.elementRef = elementRef;\n        this.scrollDispatcher = scrollDispatcher;\n        this.ngZone = ngZone;\n        this.dir = dir;\n        this._destroyed = new Subject();\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll')\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(observer)));\n    }\n    ngOnInit() {\n        this.scrollDispatcher.register(this);\n    }\n    ngOnDestroy() {\n        this.scrollDispatcher.deregister(this);\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Returns observable that emits when a scroll event is fired on the host element. */\n    elementScrolled() {\n        return this._elementScrolled;\n    }\n    /** Gets the ElementRef for the viewport. */\n    getElementRef() {\n        return this.elementRef;\n    }\n    /**\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param options specified the offsets to scroll to.\n     */\n    scrollTo(options) {\n        const el = this.elementRef.nativeElement;\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        // Rewrite start & end offsets as right or left offsets.\n        if (options.left == null) {\n            options.left = isRtl ? options.end : options.start;\n        }\n        if (options.right == null) {\n            options.right = isRtl ? options.start : options.end;\n        }\n        // Rewrite the bottom offset as a top offset.\n        if (options.bottom != null) {\n            options.top =\n                el.scrollHeight - el.clientHeight - options.bottom;\n        }\n        // Rewrite the right offset as a left offset.\n        if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {\n            if (options.left != null) {\n                options.right =\n                    el.scrollWidth - el.clientWidth - options.left;\n            }\n            if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n                options.left = options.right;\n            }\n            else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n                options.left = options.right ? -options.right : options.right;\n            }\n        }\n        else {\n            if (options.right != null) {\n                options.left =\n                    el.scrollWidth - el.clientWidth - options.right;\n            }\n        }\n        this._applyScrollToOptions(options);\n    }\n    _applyScrollToOptions(options) {\n        const el = this.elementRef.nativeElement;\n        if (supportsScrollBehavior()) {\n            el.scrollTo(options);\n        }\n        else {\n            if (options.top != null) {\n                el.scrollTop = options.top;\n            }\n            if (options.left != null) {\n                el.scrollLeft = options.left;\n            }\n        }\n    }\n    /**\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param from The edge to measure from.\n     */\n    measureScrollOffset(from) {\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const el = this.elementRef.nativeElement;\n        if (from == 'top') {\n            return el.scrollTop;\n        }\n        if (from == 'bottom') {\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\n        }\n        // Rewrite start & end as left or right offsets.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        if (from == 'start') {\n            from = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            from = isRtl ? LEFT : RIGHT;\n        }\n        if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n            else {\n                return el.scrollLeft;\n            }\n        }\n        else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\n            }\n            else {\n                return -el.scrollLeft;\n            }\n        }\n        else {\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n            // (scrollWidth - clientWidth) when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft;\n            }\n            else {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n        }\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkScrollable, deps: [{ token: i0.ElementRef }, { token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkScrollable, isStandalone: true, selector: \"[cdk-scrollable], [cdkScrollable]\", ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkScrollable, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\nclass ViewportRuler {\n    constructor(_platform, ngZone, document) {\n        this._platform = _platform;\n        /** Stream of viewport change events. */\n        this._change = new Subject();\n        /** Event listener that will be used to handle the viewport change events. */\n        this._changeListener = (event) => {\n            this._change.next(event);\n        };\n        this._document = document;\n        ngZone.runOutsideAngular(() => {\n            if (_platform.isBrowser) {\n                const window = this._getWindow();\n                // Note that bind the events ourselves, rather than going through something like RxJS's\n                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n                window.addEventListener('resize', this._changeListener);\n                window.addEventListener('orientationchange', this._changeListener);\n            }\n            // Clear the cached position so that the viewport is re-measured next time it is required.\n            // We don't need to keep track of the subscription, because it is completed on destroy.\n            this.change().subscribe(() => (this._viewportSize = null));\n        });\n    }\n    ngOnDestroy() {\n        if (this._platform.isBrowser) {\n            const window = this._getWindow();\n            window.removeEventListener('resize', this._changeListener);\n            window.removeEventListener('orientationchange', this._changeListener);\n        }\n        this._change.complete();\n    }\n    /** Returns the viewport's width and height. */\n    getViewportSize() {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n        if (!this._platform.isBrowser) {\n            this._viewportSize = null;\n        }\n        return output;\n    }\n    /** Gets a DOMRect for the viewport's bounds. */\n    getViewportRect() {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        const scrollPosition = this.getViewportScrollPosition();\n        const { width, height } = this.getViewportSize();\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height,\n            width,\n        };\n    }\n    /** Gets the (top, left) scroll position of the viewport. */\n    getViewportScrollPosition() {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n            return { top: 0, left: 0 };\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        const document = this._document;\n        const window = this._getWindow();\n        const documentElement = document.documentElement;\n        const documentRect = documentElement.getBoundingClientRect();\n        const top = -documentRect.top ||\n            document.body.scrollTop ||\n            window.scrollY ||\n            documentElement.scrollTop ||\n            0;\n        const left = -documentRect.left ||\n            document.body.scrollLeft ||\n            window.scrollX ||\n            documentElement.scrollLeft ||\n            0;\n        return { top, left };\n    }\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * This stream emits outside of the Angular zone.\n     * @param throttleTime Time in milliseconds to throttle the stream.\n     */\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Updates the cached viewport size. */\n    _updateViewportSize() {\n        const window = this._getWindow();\n        this._viewportSize = this._platform.isBrowser\n            ? { width: window.innerWidth, height: window.innerHeight }\n            : { width: 0, height: 0 };\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ViewportRuler, deps: [{ token: i1.Platform }, { token: i0.NgZone }, { token: DOCUMENT, optional: true }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ViewportRuler, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ViewportRuler, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Platform }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\nconst VIRTUAL_SCROLLABLE = new InjectionToken('VIRTUAL_SCROLLABLE');\n/**\n * Extending the {@link CdkScrollable} to be used as scrolling container for virtual scrolling.\n */\nclass CdkVirtualScrollable extends CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n    }\n    /**\n     * Measure the viewport size for the provided orientation.\n     *\n     * @param orientation The orientation to measure the size from.\n     */\n    measureViewportSize(orientation) {\n        const viewportEl = this.elementRef.nativeElement;\n        return orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollable, deps: [{ token: i0.ElementRef }, { token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkVirtualScrollable, usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollable, decorators: [{\n            type: Directive\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nclass CdkVirtualScrollViewport extends CdkVirtualScrollable {\n    /** The direction the viewport scrolls. */\n    get orientation() {\n        return this._orientation;\n    }\n    set orientation(orientation) {\n        if (this._orientation !== orientation) {\n            this._orientation = orientation;\n            this._calculateSpacerSize();\n        }\n    }\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n        this.elementRef = elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._scrollStrategy = _scrollStrategy;\n        this.scrollable = scrollable;\n        this._platform = inject(Platform);\n        /** Emits when the viewport is detached from a CdkVirtualForOf. */\n        this._detachedSubject = new Subject();\n        /** Emits when the rendered range changes. */\n        this._renderedRangeSubject = new Subject();\n        this._orientation = 'vertical';\n        /**\n         * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n         * will be removed.\n         */\n        this.appendOnly = false;\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\n        // performance.\n        /** Emits when the index of the first element visible in the viewport changes. */\n        this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n        /** A stream that emits whenever the rendered range changes. */\n        this.renderedRangeStream = this._renderedRangeSubject;\n        /**\n         * The total size of all content (in pixels), including content that is not currently rendered.\n         */\n        this._totalContentSize = 0;\n        /** A string representing the `style.width` property value to be used for the spacer element. */\n        this._totalContentWidth = '';\n        /** A string representing the `style.height` property value to be used for the spacer element. */\n        this._totalContentHeight = '';\n        /** The currently rendered range of indices. */\n        this._renderedRange = { start: 0, end: 0 };\n        /** The length of the data bound to this viewport (in number of items). */\n        this._dataLength = 0;\n        /** The size of the viewport (in pixels). */\n        this._viewportSize = 0;\n        /** The last rendered content offset that was set. */\n        this._renderedContentOffset = 0;\n        /**\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\n         * be rewritten as an offset to the start of the content).\n         */\n        this._renderedContentOffsetNeedsRewrite = false;\n        /** Whether there is a pending change detection cycle. */\n        this._isChangeDetectionPending = false;\n        /** A list of functions to run after the next change detection cycle. */\n        this._runAfterChangeDetection = [];\n        /** Subscription to changes in the viewport size. */\n        this._viewportChanges = Subscription.EMPTY;\n        if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n        }\n        this._viewportChanges = viewportRuler.change().subscribe(() => {\n            this.checkViewportSize();\n        });\n        if (!this.scrollable) {\n            // No scrollable is provided, so the virtual-scroll-viewport needs to become a scrollable\n            this.elementRef.nativeElement.classList.add('cdk-virtual-scrollable');\n            this.scrollable = this;\n        }\n    }\n    ngOnInit() {\n        // Scrolling depends on the element dimensions which we can't get during SSR.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (this.scrollable === this) {\n            super.ngOnInit();\n        }\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\n        // ourselves instead.\n        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n            this._measureViewportSize();\n            this._scrollStrategy.attach(this);\n            this.scrollable\n                .elementScrolled()\n                .pipe(\n            // Start off with a fake scroll event so we properly detect our initial position.\n            startWith(null), \n            // Collect multiple events into one until the next animation frame. This way if\n            // there are multiple scroll events in the same frame we only need to recheck\n            // our layout once.\n            auditTime(0, SCROLL_SCHEDULER), \n            // Usually `elementScrolled` is completed when the scrollable is destroyed, but\n            // that may not be the case if a `CdkVirtualScrollableElement` is used so we have\n            // to unsubscribe here just in case.\n            takeUntil(this._destroyed))\n                .subscribe(() => this._scrollStrategy.onContentScrolled());\n            this._markChangeDetectionNeeded();\n        }));\n    }\n    ngOnDestroy() {\n        this.detach();\n        this._scrollStrategy.detach();\n        // Complete all subjects\n        this._renderedRangeSubject.complete();\n        this._detachedSubject.complete();\n        this._viewportChanges.unsubscribe();\n        super.ngOnDestroy();\n    }\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n    attach(forOf) {\n        if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CdkVirtualScrollViewport is already attached.');\n        }\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n        // change detection loop ourselves.\n        this.ngZone.runOutsideAngular(() => {\n            this._forOf = forOf;\n            this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n                const newLength = data.length;\n                if (newLength !== this._dataLength) {\n                    this._dataLength = newLength;\n                    this._scrollStrategy.onDataLengthChanged();\n                }\n                this._doChangeDetection();\n            });\n        });\n    }\n    /** Detaches the current `CdkVirtualForOf`. */\n    detach() {\n        this._forOf = null;\n        this._detachedSubject.next();\n    }\n    /** Gets the length of the data bound to this viewport (in number of items). */\n    getDataLength() {\n        return this._dataLength;\n    }\n    /** Gets the size of the viewport (in pixels). */\n    getViewportSize() {\n        return this._viewportSize;\n    }\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n    // setting it to something else, but its error prone and should probably be split into\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n    /** Get the current rendered range of items. */\n    getRenderedRange() {\n        return this._renderedRange;\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n    }\n    /**\n     * Sets the total size of all content (in pixels), including content that is not currently\n     * rendered.\n     */\n    setTotalContentSize(size) {\n        if (this._totalContentSize !== size) {\n            this._totalContentSize = size;\n            this._calculateSpacerSize();\n            this._markChangeDetectionNeeded();\n        }\n    }\n    /** Sets the currently rendered range of indices. */\n    setRenderedRange(range) {\n        if (!rangesEqual(this._renderedRange, range)) {\n            if (this.appendOnly) {\n                range = { start: 0, end: Math.max(this._renderedRange.end, range.end) };\n            }\n            this._renderedRangeSubject.next((this._renderedRange = range));\n            this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n        }\n    }\n    /**\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n     */\n    getOffsetToRenderedContentStart() {\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n    }\n    /**\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\n     * (in pixels).\n     */\n    setRenderedContentOffset(offset, to = 'to-start') {\n        // In appendOnly, we always start from the top\n        offset = this.appendOnly && to === 'to-start' ? 0 : offset;\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n        // in the negative direction.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        const isHorizontal = this.orientation == 'horizontal';\n        const axis = isHorizontal ? 'X' : 'Y';\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n        this._renderedContentOffset = offset;\n        if (to === 'to-end') {\n            transform += ` translate${axis}(-100%)`;\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n            // expand upward).\n            this._renderedContentOffsetNeedsRewrite = true;\n        }\n        if (this._renderedContentTransform != transform) {\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\n            // into the string.\n            this._renderedContentTransform = transform;\n            this._markChangeDetectionNeeded(() => {\n                if (this._renderedContentOffsetNeedsRewrite) {\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\n                    this._renderedContentOffsetNeedsRewrite = false;\n                    this.setRenderedContentOffset(this._renderedContentOffset);\n                }\n                else {\n                    this._scrollStrategy.onRenderedOffsetChanged();\n                }\n            });\n        }\n    }\n    /**\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n     * @param offset The offset to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToOffset(offset, behavior = 'auto') {\n        const options = { behavior };\n        if (this.orientation === 'horizontal') {\n            options.start = offset;\n        }\n        else {\n            options.top = offset;\n        }\n        this.scrollable.scrollTo(options);\n    }\n    /**\n     * Scrolls to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToIndex(index, behavior = 'auto') {\n        this._scrollStrategy.scrollToIndex(index, behavior);\n    }\n    /**\n     * Gets the current scroll offset from the start of the scrollable (in pixels).\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n     *     in horizontal mode.\n     */\n    measureScrollOffset(from) {\n        // This is to break the call cycle\n        let measureScrollOffset;\n        if (this.scrollable == this) {\n            measureScrollOffset = (_from) => super.measureScrollOffset(_from);\n        }\n        else {\n            measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);\n        }\n        return Math.max(0, measureScrollOffset(from ?? (this.orientation === 'horizontal' ? 'start' : 'top')) -\n            this.measureViewportOffset());\n    }\n    /**\n     * Measures the offset of the viewport from the scrolling container\n     * @param from The edge to measure from.\n     */\n    measureViewportOffset(from) {\n        let fromRect;\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const isRtl = this.dir?.value == 'rtl';\n        if (from == 'start') {\n            fromRect = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            fromRect = isRtl ? LEFT : RIGHT;\n        }\n        else if (from) {\n            fromRect = from;\n        }\n        else {\n            fromRect = this.orientation === 'horizontal' ? 'left' : 'top';\n        }\n        const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);\n        const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];\n        return viewportClientRect - scrollerClientRect;\n    }\n    /** Measure the combined size of all of the rendered items. */\n    measureRenderedContentSize() {\n        const contentEl = this._contentWrapper.nativeElement;\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n    }\n    /**\n     * Measure the total combined size of the given range. Throws if the range includes items that are\n     * not rendered.\n     */\n    measureRangeSize(range) {\n        if (!this._forOf) {\n            return 0;\n        }\n        return this._forOf.measureRangeSize(range, this.orientation);\n    }\n    /** Update the viewport dimensions and re-render. */\n    checkViewportSize() {\n        // TODO: Cleanup later when add logic for handling content resize\n        this._measureViewportSize();\n        this._scrollStrategy.onDataLengthChanged();\n    }\n    /** Measure the viewport size. */\n    _measureViewportSize() {\n        this._viewportSize = this.scrollable.measureViewportSize(this.orientation);\n    }\n    /** Queue up change detection to run. */\n    _markChangeDetectionNeeded(runAfter) {\n        if (runAfter) {\n            this._runAfterChangeDetection.push(runAfter);\n        }\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\n        if (!this._isChangeDetectionPending) {\n            this._isChangeDetectionPending = true;\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._doChangeDetection();\n            }));\n        }\n    }\n    /** Run change detection. */\n    _doChangeDetection() {\n        this._isChangeDetectionPending = false;\n        // Apply the content transform. The transform can't be set via an Angular binding because\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n        // the `Number` function first to coerce it to a numeric value.\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\n        // instead does not properly check the projected content.\n        this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n        const runAfterChangeDetection = this._runAfterChangeDetection;\n        this._runAfterChangeDetection = [];\n        for (const fn of runAfterChangeDetection) {\n            fn();\n        }\n    }\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\n    _calculateSpacerSize() {\n        this._totalContentHeight =\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n        this._totalContentWidth =\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollViewport, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: VIRTUAL_SCROLL_STRATEGY, optional: true }, { token: i2.Directionality, optional: true }, { token: ScrollDispatcher }, { token: ViewportRuler }, { token: VIRTUAL_SCROLLABLE, optional: true }], target: i0.FactoryTarget.Component }); }\n    static { this.cmp = i0.ngDeclareComponent({ minVersion: \"16.1.0\", version: \"17.2.0\", type: CdkVirtualScrollViewport, isStandalone: true, selector: \"cdk-virtual-scroll-viewport\", inputs: { orientation: \"orientation\", appendOnly: [\"appendOnly\", \"appendOnly\", booleanAttribute] }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, host: { properties: { \"class.cdk-virtual-scroll-orientation-horizontal\": \"orientation === \\\"horizontal\\\"\", \"class.cdk-virtual-scroll-orientation-vertical\": \"orientation !== \\\"horizontal\\\"\" }, classAttribute: \"cdk-virtual-scroll-viewport\" }, providers: [\n            {\n                provide: CdkScrollable,\n                useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n                deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n            },\n        ], viewQueries: [{ propertyName: \"_contentWrapper\", first: true, predicate: [\"contentWrapper\"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\", styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollViewport, decorators: [{\n            type: Component,\n            args: [{ selector: 'cdk-virtual-scroll-viewport', host: {\n                        'class': 'cdk-virtual-scroll-viewport',\n                        '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n                        '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\n                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, providers: [\n                        {\n                            provide: CdkScrollable,\n                            useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n                            deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n                        },\n                    ], template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\", styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [VIRTUAL_SCROLL_STRATEGY]\n                }] }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: ScrollDispatcher }, { type: ViewportRuler }, { type: CdkVirtualScrollable, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [VIRTUAL_SCROLLABLE]\n                }] }], propDecorators: { orientation: [{\n                type: Input\n            }], appendOnly: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], scrolledIndexChange: [{\n                type: Output\n            }], _contentWrapper: [{\n                type: ViewChild,\n                args: ['contentWrapper', { static: true }]\n            }] } });\n\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    if (orientation === 'horizontal') {\n        return direction === 'start' ? rect.left : rect.right;\n    }\n    return direction === 'start' ? rect.top : rect.bottom;\n}\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\nclass CdkVirtualForOf {\n    /** The DataSource to display. */\n    get cdkVirtualForOf() {\n        return this._cdkVirtualForOf;\n    }\n    set cdkVirtualForOf(value) {\n        this._cdkVirtualForOf = value;\n        if (isDataSource(value)) {\n            this._dataSourceChanges.next(value);\n        }\n        else {\n            // If value is an an NgIterable, convert it to an array.\n            this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\n        }\n    }\n    /**\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n     * the item and produces a value to be used as the item's identity when tracking changes.\n     */\n    get cdkVirtualForTrackBy() {\n        return this._cdkVirtualForTrackBy;\n    }\n    set cdkVirtualForTrackBy(fn) {\n        this._needsUpdate = true;\n        this._cdkVirtualForTrackBy = fn\n            ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item)\n            : undefined;\n    }\n    /** The template used to stamp out new elements. */\n    set cdkVirtualForTemplate(value) {\n        if (value) {\n            this._needsUpdate = true;\n            this._template = value;\n        }\n    }\n    /**\n     * The size of the cache used to store templates that are not being used for re-use later.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n     */\n    get cdkVirtualForTemplateCacheSize() {\n        return this._viewRepeater.viewCacheSize;\n    }\n    set cdkVirtualForTemplateCacheSize(size) {\n        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\n    }\n    constructor(\n    /** The view container to add items to. */\n    _viewContainerRef, \n    /** The template to use when stamping out new items. */\n    _template, \n    /** The set of available differs. */\n    _differs, \n    /** The strategy used to render items in the virtual scroll viewport. */\n    _viewRepeater, \n    /** The virtual scrolling viewport that these items are being rendered in. */\n    _viewport, ngZone) {\n        this._viewContainerRef = _viewContainerRef;\n        this._template = _template;\n        this._differs = _differs;\n        this._viewRepeater = _viewRepeater;\n        this._viewport = _viewport;\n        /** Emits when the rendered view of the data changes. */\n        this.viewChange = new Subject();\n        /** Subject that emits when a new DataSource instance is given. */\n        this._dataSourceChanges = new Subject();\n        /** Emits whenever the data in the current DataSource changes. */\n        this.dataStream = this._dataSourceChanges.pipe(\n        // Start off with null `DataSource`.\n        startWith(null), \n        // Bundle up the previous and current data sources so we can work with both.\n        pairwise(), \n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\n        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)), \n        // Replay the last emitted data when someone subscribes.\n        shareReplay(1));\n        /** The differ used to calculate changes to the data. */\n        this._differ = null;\n        /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n        this._needsUpdate = false;\n        this._destroyed = new Subject();\n        this.dataStream.subscribe(data => {\n            this._data = data;\n            this._onRenderedDataChange();\n        });\n        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n            this._renderedRange = range;\n            if (this.viewChange.observers.length) {\n                ngZone.run(() => this.viewChange.next(this._renderedRange));\n            }\n            this._onRenderedDataChange();\n        });\n        this._viewport.attach(this);\n    }\n    /**\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n     * in the specified range. Throws an error if the range includes items that are not currently\n     * rendered.\n     */\n    measureRangeSize(range, orientation) {\n        if (range.start >= range.end) {\n            return 0;\n        }\n        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\n        }\n        // The index into the list of rendered views for the first item in the range.\n        const renderedStartIndex = range.start - this._renderedRange.start;\n        // The length of the range we're measuring.\n        const rangeLen = range.end - range.start;\n        // Loop over all the views, find the first and land node and compute the size by subtracting\n        // the top of the first node from the bottom of the last one.\n        let firstNode;\n        let lastNode;\n        // Find the first node by starting from the beginning and going forwards.\n        for (let i = 0; i < rangeLen; i++) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                firstNode = lastNode = view.rootNodes[0];\n                break;\n            }\n        }\n        // Find the last node by starting from the end and going backwards.\n        for (let i = rangeLen - 1; i > -1; i--) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                lastNode = view.rootNodes[view.rootNodes.length - 1];\n                break;\n            }\n        }\n        return firstNode && lastNode\n            ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode)\n            : 0;\n    }\n    ngDoCheck() {\n        if (this._differ && this._needsUpdate) {\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n            // changing (need to do this diff).\n            const changes = this._differ.diff(this._renderedItems);\n            if (!changes) {\n                this._updateContext();\n            }\n            else {\n                this._applyChanges(changes);\n            }\n            this._needsUpdate = false;\n        }\n    }\n    ngOnDestroy() {\n        this._viewport.detach();\n        this._dataSourceChanges.next(undefined);\n        this._dataSourceChanges.complete();\n        this.viewChange.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._viewRepeater.detach();\n    }\n    /** React to scroll state changes in the viewport. */\n    _onRenderedDataChange() {\n        if (!this._renderedRange) {\n            return;\n        }\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n        if (!this._differ) {\n            // Use a wrapper function for the `trackBy` so any new values are\n            // picked up automatically without having to recreate the differ.\n            this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n                return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n            });\n        }\n        this._needsUpdate = true;\n    }\n    /** Swap out one `DataSource` for another. */\n    _changeDataSource(oldDs, newDs) {\n        if (oldDs) {\n            oldDs.disconnect(this);\n        }\n        this._needsUpdate = true;\n        return newDs ? newDs.connect(this) : of();\n    }\n    /** Update the `CdkVirtualForOfContext` for all views. */\n    _updateContext() {\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n            view.detectChanges();\n        }\n    }\n    /** Apply changes to the DOM. */\n    _applyChanges(changes) {\n        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), record => record.item);\n        // Update $implicit for any items that had an identity change.\n        changes.forEachIdentityChange((record) => {\n            const view = this._viewContainerRef.get(record.currentIndex);\n            view.context.$implicit = record.item;\n        });\n        // Update the context variables on all items.\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n        }\n    }\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\n    _updateComputedContextProperties(context) {\n        context.first = context.index === 0;\n        context.last = context.index === context.count - 1;\n        context.even = context.index % 2 === 0;\n        context.odd = !context.even;\n    }\n    _getEmbeddedViewArgs(record, index) {\n        // Note that it's important that we insert the item directly at the proper index,\n        // rather than inserting it and the moving it in place, because if there's a directive\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\n        // comment node which can throw off the move when it's being repeated for all items.\n        return {\n            templateRef: this._template,\n            context: {\n                $implicit: record.item,\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                cdkVirtualForOf: this._cdkVirtualForOf,\n                index: -1,\n                count: -1,\n                first: false,\n                last: false,\n                odd: false,\n                even: false,\n            },\n            index,\n        };\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualForOf, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.IterableDiffers }, { token: _VIEW_REPEATER_STRATEGY }, { token: CdkVirtualScrollViewport, skipSelf: true }, { token: i0.NgZone }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkVirtualForOf, isStandalone: true, selector: \"[cdkVirtualFor][cdkVirtualForOf]\", inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, providers: [{ provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy }], ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualForOf, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkVirtualFor][cdkVirtualForOf]',\n                    providers: [{ provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy }],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.IterableDiffers }, { type: i2$1._RecycleViewRepeaterStrategy, decorators: [{\n                    type: Inject,\n                    args: [_VIEW_REPEATER_STRATEGY]\n                }] }, { type: CdkVirtualScrollViewport, decorators: [{\n                    type: SkipSelf\n                }] }, { type: i0.NgZone }], propDecorators: { cdkVirtualForOf: [{\n                type: Input\n            }], cdkVirtualForTrackBy: [{\n                type: Input\n            }], cdkVirtualForTemplate: [{\n                type: Input\n            }], cdkVirtualForTemplateCacheSize: [{\n                type: Input\n            }] } });\n\n/**\n * Provides a virtual scrollable for the element it is attached to.\n */\nclass CdkVirtualScrollableElement extends CdkVirtualScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return (this.getElementRef().nativeElement.getBoundingClientRect()[from] -\n            this.measureScrollOffset(from));\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollableElement, deps: [{ token: i0.ElementRef }, { token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkVirtualScrollableElement, isStandalone: true, selector: \"[cdkVirtualScrollingElement]\", host: { classAttribute: \"cdk-virtual-scrollable\" }, providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollableElement, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkVirtualScrollingElement]',\n                    providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }],\n                    standalone: true,\n                    host: {\n                        'class': 'cdk-virtual-scrollable',\n                    },\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\n/**\n * Provides as virtual scrollable for the global / window scrollbar.\n */\nclass CdkVirtualScrollableWindow extends CdkVirtualScrollable {\n    constructor(scrollDispatcher, ngZone, dir) {\n        super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(document, 'scroll').pipe(takeUntil(this._destroyed)).subscribe(observer)));\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollableWindow, deps: [{ token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkVirtualScrollableWindow, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[scrollWindow]\", providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkVirtualScrollableWindow, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[scrollWindow]',\n                    providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\nclass CdkScrollableModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkScrollableModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkScrollableModule, imports: [CdkScrollable], exports: [CdkScrollable] }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkScrollableModule }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkScrollableModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [CdkScrollable],\n                    imports: [CdkScrollable],\n                }]\n        }] });\n/**\n * @docs-primary-export\n */\nclass ScrollingModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollingModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollingModule, imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport,\n            CdkFixedSizeVirtualScroll,\n            CdkVirtualForOf,\n            CdkVirtualScrollableWindow,\n            CdkVirtualScrollableElement], exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll,\n            CdkVirtualForOf,\n            CdkVirtualScrollViewport,\n            CdkVirtualScrollableWindow,\n            CdkVirtualScrollableElement] }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollingModule, imports: [BidiModule,\n            CdkScrollableModule, BidiModule, CdkScrollableModule] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: ScrollingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        BidiModule,\n                        CdkScrollableModule,\n                        CdkVirtualScrollViewport,\n                        CdkFixedSizeVirtualScroll,\n                        CdkVirtualForOf,\n                        CdkVirtualScrollableWindow,\n                        CdkVirtualScrollableElement,\n                    ],\n                    exports: [\n                        BidiModule,\n                        CdkScrollableModule,\n                        CdkFixedSizeVirtualScroll,\n                        CdkVirtualForOf,\n                        CdkVirtualScrollViewport,\n                        CdkVirtualScrollableWindow,\n                        CdkVirtualScrollableElement,\n                    ],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollable, CdkVirtualScrollableElement, CdkVirtualScrollableWindow, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLLABLE, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };\n","import * as i1 from '@angular/cdk/a11y';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig, OverlayRef, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform, _getFocusedElementPierceShadowDom } from '@angular/cdk/platform';\nimport { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { inject, ChangeDetectorRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Inject, ViewChild, InjectionToken, Injector, TemplateRef, Injectable, SkipSelf, NgModule } from '@angular/core';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport { Subject, defer, of } from 'rxjs';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith } from 'rxjs/operators';\n\n/** Configuration for opening a modal dialog. */\nclass DialogConfig {\n    constructor() {\n        /** The ARIA role of the dialog element. */\n        this.role = 'dialog';\n        /** Optional CSS class or classes applied to the overlay panel. */\n        this.panelClass = '';\n        /** Whether the dialog has a backdrop. */\n        this.hasBackdrop = true;\n        /** Optional CSS class or classes applied to the overlay backdrop. */\n        this.backdropClass = '';\n        /** Whether the dialog closes with the escape key or pointer events outside the panel element. */\n        this.disableClose = false;\n        /** Width of the dialog. */\n        this.width = '';\n        /** Height of the dialog. */\n        this.height = '';\n        /** Data being injected into the child component. */\n        this.data = null;\n        /** ID of the element that describes the dialog. */\n        this.ariaDescribedBy = null;\n        /** ID of the element that labels the dialog. */\n        this.ariaLabelledBy = null;\n        /** Dialog label applied via `aria-label` */\n        this.ariaLabel = null;\n        /** Whether this is a modal dialog. Used to set the `aria-modal` attribute. */\n        this.ariaModal = true;\n        /**\n         * Where the dialog should focus on open.\n         * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n         * AutoFocusTarget instead.\n         */\n        this.autoFocus = 'first-tabbable';\n        /**\n         * Whether the dialog should restore focus to the previously-focused element upon closing.\n         * Has the following behavior based on the type that is passed in:\n         * - `boolean` - when true, will return focus to the element that was focused before the dialog\n         *    was opened, otherwise won't restore focus at all.\n         * - `string` - focus will be restored to the first element that matches the CSS selector.\n         * - `HTMLElement` - focus will be restored to the specific element.\n         */\n        this.restoreFocus = true;\n        /**\n         * Whether the dialog should close when the user navigates backwards or forwards through browser\n         * history. This does not apply to navigation via anchor element unless using URL-hash based\n         * routing (`HashLocationStrategy` in the Angular router).\n         */\n        this.closeOnNavigation = true;\n        /**\n         * Whether the dialog should close when the dialog service is destroyed. This is useful if\n         * another service is wrapping the dialog and is managing the destruction instead.\n         */\n        this.closeOnDestroy = true;\n        /**\n         * Whether the dialog should close when the underlying overlay is detached. This is useful if\n         * another service is wrapping the dialog and is managing the destruction instead. E.g. an\n         * external detachment can happen as a result of a scroll strategy triggering it or when the\n         * browser location changes.\n         */\n        this.closeOnOverlayDetachments = true;\n    }\n}\n\nfunction throwDialogContentAlreadyAttachedError() {\n    throw Error('Attempting to attach dialog content after content is already attached');\n}\n/**\n * Internal component that wraps user-provided dialog content.\n * @docs-private\n */\nclass CdkDialogContainer extends BasePortalOutlet {\n    constructor(_elementRef, _focusTrapFactory, _document, _config, _interactivityChecker, _ngZone, _overlayRef, _focusMonitor) {\n        super();\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this._config = _config;\n        this._interactivityChecker = _interactivityChecker;\n        this._ngZone = _ngZone;\n        this._overlayRef = _overlayRef;\n        this._focusMonitor = _focusMonitor;\n        this._platform = inject(Platform);\n        /** The class that traps and manages focus within the dialog. */\n        this._focusTrap = null;\n        /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n        this._elementFocusedBeforeDialogWasOpened = null;\n        /**\n         * Type of interaction that led to the dialog being closed. This is used to determine\n         * whether the focus style will be applied when returning focus to its original location\n         * after the dialog is closed.\n         */\n        this._closeInteractionType = null;\n        /**\n         * Queue of the IDs of the dialog's label element, based on their definition order. The first\n         * ID will be used as the `aria-labelledby` value. We use a queue here to handle the case\n         * where there are two or more titles in the DOM at a time and the first one is destroyed while\n         * the rest are present.\n         */\n        this._ariaLabelledByQueue = [];\n        this._changeDetectorRef = inject(ChangeDetectorRef);\n        /**\n         * Attaches a DOM portal to the dialog container.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throwDialogContentAlreadyAttachedError();\n            }\n            const result = this._portalOutlet.attachDomPortal(portal);\n            this._contentAttached();\n            return result;\n        };\n        this._document = _document;\n        if (this._config.ariaLabelledBy) {\n            this._ariaLabelledByQueue.push(this._config.ariaLabelledBy);\n        }\n    }\n    _addAriaLabelledBy(id) {\n        this._ariaLabelledByQueue.push(id);\n        this._changeDetectorRef.markForCheck();\n    }\n    _removeAriaLabelledBy(id) {\n        const index = this._ariaLabelledByQueue.indexOf(id);\n        if (index > -1) {\n            this._ariaLabelledByQueue.splice(index, 1);\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    _contentAttached() {\n        this._initializeFocusTrap();\n        this._handleBackdropClicks();\n        this._captureInitialFocus();\n    }\n    /**\n     * Can be used by child classes to customize the initial focus\n     * capturing behavior (e.g. if it's tied to an animation).\n     */\n    _captureInitialFocus() {\n        this._trapFocus();\n    }\n    ngOnDestroy() {\n        this._restoreFocus();\n    }\n    /**\n     * Attach a ComponentPortal as content to this dialog container.\n     * @param portal Portal to be attached as the dialog content.\n     */\n    attachComponentPortal(portal) {\n        if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throwDialogContentAlreadyAttachedError();\n        }\n        const result = this._portalOutlet.attachComponentPortal(portal);\n        this._contentAttached();\n        return result;\n    }\n    /**\n     * Attach a TemplatePortal as content to this dialog container.\n     * @param portal Portal to be attached as the dialog content.\n     */\n    attachTemplatePortal(portal) {\n        if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throwDialogContentAlreadyAttachedError();\n        }\n        const result = this._portalOutlet.attachTemplatePortal(portal);\n        this._contentAttached();\n        return result;\n    }\n    // TODO(crisbeto): this shouldn't be exposed, but there are internal references to it.\n    /** Captures focus if it isn't already inside the dialog. */\n    _recaptureFocus() {\n        if (!this._containsFocus()) {\n            this._trapFocus();\n        }\n    }\n    /**\n     * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n     * attribute to forcefully focus it. The attribute is removed after focus is moved.\n     * @param element The element to focus.\n     */\n    _forceFocus(element, options) {\n        if (!this._interactivityChecker.isFocusable(element)) {\n            element.tabIndex = -1;\n            // The tabindex attribute should be removed to avoid navigating to that element again\n            this._ngZone.runOutsideAngular(() => {\n                const callback = () => {\n                    element.removeEventListener('blur', callback);\n                    element.removeEventListener('mousedown', callback);\n                    element.removeAttribute('tabindex');\n                };\n                element.addEventListener('blur', callback);\n                element.addEventListener('mousedown', callback);\n            });\n        }\n        element.focus(options);\n    }\n    /**\n     * Focuses the first element that matches the given selector within the focus trap.\n     * @param selector The CSS selector for the element to set focus to.\n     */\n    _focusByCssSelector(selector, options) {\n        let elementToFocus = this._elementRef.nativeElement.querySelector(selector);\n        if (elementToFocus) {\n            this._forceFocus(elementToFocus, options);\n        }\n    }\n    /**\n     * Moves the focus inside the focus trap. When autoFocus is not set to 'dialog', if focus\n     * cannot be moved then focus will go to the dialog container.\n     */\n    _trapFocus() {\n        const element = this._elementRef.nativeElement;\n        // If were to attempt to focus immediately, then the content of the dialog would not yet be\n        // ready in instances where change detection has to run first. To deal with this, we simply\n        // wait for the microtask queue to be empty when setting focus when autoFocus isn't set to\n        // dialog. If the element inside the dialog can't be focused, then the container is focused\n        // so the user can't tab into other elements behind it.\n        switch (this._config.autoFocus) {\n            case false:\n            case 'dialog':\n                // Ensure that focus is on the dialog container. It's possible that a different\n                // component tried to move focus while the open animation was running. See:\n                // https://github.com/angular/components/issues/16215. Note that we only want to do this\n                // if the focus isn't inside the dialog already, because it's possible that the consumer\n                // turned off `autoFocus` in order to move focus themselves.\n                if (!this._containsFocus()) {\n                    element.focus();\n                }\n                break;\n            case true:\n            case 'first-tabbable':\n                this._focusTrap?.focusInitialElementWhenReady().then(focusedSuccessfully => {\n                    // If we weren't able to find a focusable element in the dialog, then focus the dialog\n                    // container instead.\n                    if (!focusedSuccessfully) {\n                        this._focusDialogContainer();\n                    }\n                });\n                break;\n            case 'first-heading':\n                this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]');\n                break;\n            default:\n                this._focusByCssSelector(this._config.autoFocus);\n                break;\n        }\n    }\n    /** Restores focus to the element that was focused before the dialog opened. */\n    _restoreFocus() {\n        const focusConfig = this._config.restoreFocus;\n        let focusTargetElement = null;\n        if (typeof focusConfig === 'string') {\n            focusTargetElement = this._document.querySelector(focusConfig);\n        }\n        else if (typeof focusConfig === 'boolean') {\n            focusTargetElement = focusConfig ? this._elementFocusedBeforeDialogWasOpened : null;\n        }\n        else if (focusConfig) {\n            focusTargetElement = focusConfig;\n        }\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\n        if (this._config.restoreFocus &&\n            focusTargetElement &&\n            typeof focusTargetElement.focus === 'function') {\n            const activeElement = _getFocusedElementPierceShadowDom();\n            const element = this._elementRef.nativeElement;\n            // Make sure that focus is still inside the dialog or is on the body (usually because a\n            // non-focusable element like the backdrop was clicked) before moving it. It's possible that\n            // the consumer moved it themselves before the animation was done, in which case we shouldn't\n            // do anything.\n            if (!activeElement ||\n                activeElement === this._document.body ||\n                activeElement === element ||\n                element.contains(activeElement)) {\n                if (this._focusMonitor) {\n                    this._focusMonitor.focusVia(focusTargetElement, this._closeInteractionType);\n                    this._closeInteractionType = null;\n                }\n                else {\n                    focusTargetElement.focus();\n                }\n            }\n        }\n        if (this._focusTrap) {\n            this._focusTrap.destroy();\n        }\n    }\n    /** Focuses the dialog container. */\n    _focusDialogContainer() {\n        // Note that there is no focus method when rendering on the server.\n        if (this._elementRef.nativeElement.focus) {\n            this._elementRef.nativeElement.focus();\n        }\n    }\n    /** Returns whether focus is inside the dialog. */\n    _containsFocus() {\n        const element = this._elementRef.nativeElement;\n        const activeElement = _getFocusedElementPierceShadowDom();\n        return element === activeElement || element.contains(activeElement);\n    }\n    /** Sets up the focus trap. */\n    _initializeFocusTrap() {\n        if (this._platform.isBrowser) {\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n            // Save the previously focused element. This element will be re-focused\n            // when the dialog closes.\n            if (this._document) {\n                this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();\n            }\n        }\n    }\n    /** Sets up the listener that handles clicks on the dialog backdrop. */\n    _handleBackdropClicks() {\n        // Clicking on the backdrop will move focus out of dialog.\n        // Recapture it if closing via the backdrop is disabled.\n        this._overlayRef.backdropClick().subscribe(() => {\n            if (this._config.disableClose) {\n                this._recaptureFocus();\n            }\n        });\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkDialogContainer, deps: [{ token: i0.ElementRef }, { token: i1.FocusTrapFactory }, { token: DOCUMENT, optional: true }, { token: DialogConfig }, { token: i1.InteractivityChecker }, { token: i0.NgZone }, { token: i1$1.OverlayRef }, { token: i1.FocusMonitor }], target: i0.FactoryTarget.Component }); }\n    static { this.cmp = i0.ngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.2.0\", type: CdkDialogContainer, isStandalone: true, selector: \"cdk-dialog-container\", host: { attributes: { \"tabindex\": \"-1\" }, properties: { \"attr.id\": \"_config.id || null\", \"attr.role\": \"_config.role\", \"attr.aria-modal\": \"_config.ariaModal\", \"attr.aria-labelledby\": \"_config.ariaLabel ? null : _ariaLabelledByQueue[0]\", \"attr.aria-label\": \"_config.ariaLabel\", \"attr.aria-describedby\": \"_config.ariaDescribedBy || null\" }, classAttribute: \"cdk-dialog-container\" }, viewQueries: [{ propertyName: \"_portalOutlet\", first: true, predicate: CdkPortalOutlet, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: \"<ng-template cdkPortalOutlet />\\n\", styles: [\".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}\"], dependencies: [{ kind: \"directive\", type: CdkPortalOutlet, selector: \"[cdkPortalOutlet]\", inputs: [\"cdkPortalOutlet\"], outputs: [\"attached\"], exportAs: [\"cdkPortalOutlet\"] }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: CdkDialogContainer, decorators: [{\n            type: Component,\n            args: [{ selector: 'cdk-dialog-container', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.Default, standalone: true, imports: [CdkPortalOutlet], host: {\n                        'class': 'cdk-dialog-container',\n                        'tabindex': '-1',\n                        '[attr.id]': '_config.id || null',\n                        '[attr.role]': '_config.role',\n                        '[attr.aria-modal]': '_config.ariaModal',\n                        '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledByQueue[0]',\n                        '[attr.aria-label]': '_config.ariaLabel',\n                        '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\n                    }, template: \"<ng-template cdkPortalOutlet />\\n\", styles: [\".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.FocusTrapFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DialogConfig]\n                }] }, { type: i1.InteractivityChecker }, { type: i0.NgZone }, { type: i1$1.OverlayRef }, { type: i1.FocusMonitor }], propDecorators: { _portalOutlet: [{\n                type: ViewChild,\n                args: [CdkPortalOutlet, { static: true }]\n            }] } });\n\n/**\n * Reference to a dialog opened via the Dialog service.\n */\nclass DialogRef {\n    constructor(overlayRef, config) {\n        this.overlayRef = overlayRef;\n        this.config = config;\n        /** Emits when the dialog has been closed. */\n        this.closed = new Subject();\n        this.disableClose = config.disableClose;\n        this.backdropClick = overlayRef.backdropClick();\n        this.keydownEvents = overlayRef.keydownEvents();\n        this.outsidePointerEvents = overlayRef.outsidePointerEvents();\n        this.id = config.id; // By the time the dialog is created we are guaranteed to have an ID.\n        this.keydownEvents.subscribe(event => {\n            if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n                event.preventDefault();\n                this.close(undefined, { focusOrigin: 'keyboard' });\n            }\n        });\n        this.backdropClick.subscribe(() => {\n            if (!this.disableClose) {\n                this.close(undefined, { focusOrigin: 'mouse' });\n            }\n        });\n        this._detachSubscription = overlayRef.detachments().subscribe(() => {\n            // Check specifically for `false`, because we want `undefined` to be treated like `true`.\n            if (config.closeOnOverlayDetachments !== false) {\n                this.close();\n            }\n        });\n    }\n    /**\n     * Close the dialog.\n     * @param result Optional result to return to the dialog opener.\n     * @param options Additional options to customize the closing behavior.\n     */\n    close(result, options) {\n        if (this.containerInstance) {\n            const closedSubject = this.closed;\n            this.containerInstance._closeInteractionType = options?.focusOrigin || 'program';\n            // Drop the detach subscription first since it can be triggered by the\n            // `dispose` call and override the result of this closing sequence.\n            this._detachSubscription.unsubscribe();\n            this.overlayRef.dispose();\n            closedSubject.next(result);\n            closedSubject.complete();\n            this.componentInstance = this.containerInstance = null;\n        }\n    }\n    /** Updates the position of the dialog based on the current position strategy. */\n    updatePosition() {\n        this.overlayRef.updatePosition();\n        return this;\n    }\n    /**\n     * Updates the dialog's width and height.\n     * @param width New width of the dialog.\n     * @param height New height of the dialog.\n     */\n    updateSize(width = '', height = '') {\n        this.overlayRef.updateSize({ width, height });\n        return this;\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        this.overlayRef.addPanelClass(classes);\n        return this;\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        this.overlayRef.removePanelClass(classes);\n        return this;\n    }\n}\n\n/** Injection token for the Dialog's ScrollStrategy. */\nconst DIALOG_SCROLL_STRATEGY = new InjectionToken('DialogScrollStrategy', {\n    providedIn: 'root',\n    factory: () => {\n        const overlay = inject(Overlay);\n        return () => overlay.scrollStrategies.block();\n    },\n});\n/** Injection token for the Dialog's Data. */\nconst DIALOG_DATA = new InjectionToken('DialogData');\n/** Injection token that can be used to provide default options for the dialog module. */\nconst DEFAULT_DIALOG_CONFIG = new InjectionToken('DefaultDialogConfig');\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nfunction DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.block();\n}\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nconst DIALOG_SCROLL_STRATEGY_PROVIDER = {\n    provide: DIALOG_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n/** Unique id for the created dialog. */\nlet uniqueId = 0;\nclass Dialog {\n    /** Keeps track of the currently-open dialogs. */\n    get openDialogs() {\n        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n    }\n    /** Stream that emits when a dialog has been opened. */\n    get afterOpened() {\n        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n    }\n    constructor(_overlay, _injector, _defaultOptions, _parentDialog, _overlayContainer, scrollStrategy) {\n        this._overlay = _overlay;\n        this._injector = _injector;\n        this._defaultOptions = _defaultOptions;\n        this._parentDialog = _parentDialog;\n        this._overlayContainer = _overlayContainer;\n        this._openDialogsAtThisLevel = [];\n        this._afterAllClosedAtThisLevel = new Subject();\n        this._afterOpenedAtThisLevel = new Subject();\n        this._ariaHiddenElements = new Map();\n        /**\n         * Stream that emits when all open dialog have finished closing.\n         * Will emit on subscribe if there are no open dialogs to begin with.\n         */\n        this.afterAllClosed = defer(() => this.openDialogs.length\n            ? this._getAfterAllClosed()\n            : this._getAfterAllClosed().pipe(startWith(undefined)));\n        this._scrollStrategy = scrollStrategy;\n    }\n    open(componentOrTemplateRef, config) {\n        const defaults = (this._defaultOptions || new DialogConfig());\n        config = { ...defaults, ...config };\n        config.id = config.id || `cdk-dialog-${uniqueId++}`;\n        if (config.id &&\n            this.getDialogById(config.id) &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n        }\n        const overlayConfig = this._getOverlayConfig(config);\n        const overlayRef = this._overlay.create(overlayConfig);\n        const dialogRef = new DialogRef(overlayRef, config);\n        const dialogContainer = this._attachContainer(overlayRef, dialogRef, config);\n        dialogRef.containerInstance = dialogContainer;\n        this._attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config);\n        // If this is the first dialog that we're opening, hide all the non-overlay content.\n        if (!this.openDialogs.length) {\n            this._hideNonDialogContentFromAssistiveTechnology();\n        }\n        this.openDialogs.push(dialogRef);\n        dialogRef.closed.subscribe(() => this._removeOpenDialog(dialogRef, true));\n        this.afterOpened.next(dialogRef);\n        return dialogRef;\n    }\n    /**\n     * Closes all of the currently-open dialogs.\n     */\n    closeAll() {\n        reverseForEach(this.openDialogs, dialog => dialog.close());\n    }\n    /**\n     * Finds an open dialog by its id.\n     * @param id ID to use when looking up the dialog.\n     */\n    getDialogById(id) {\n        return this.openDialogs.find(dialog => dialog.id === id);\n    }\n    ngOnDestroy() {\n        // Make one pass over all the dialogs that need to be untracked, but should not be closed. We\n        // want to stop tracking the open dialog even if it hasn't been closed, because the tracking\n        // determines when `aria-hidden` is removed from elements outside the dialog.\n        reverseForEach(this._openDialogsAtThisLevel, dialog => {\n            // Check for `false` specifically since we want `undefined` to be interpreted as `true`.\n            if (dialog.config.closeOnDestroy === false) {\n                this._removeOpenDialog(dialog, false);\n            }\n        });\n        // Make a second pass and close the remaining dialogs. We do this second pass in order to\n        // correctly dispatch the `afterAllClosed` event in case we have a mixed array of dialogs\n        // that should be closed and dialogs that should not.\n        reverseForEach(this._openDialogsAtThisLevel, dialog => dialog.close());\n        this._afterAllClosedAtThisLevel.complete();\n        this._afterOpenedAtThisLevel.complete();\n        this._openDialogsAtThisLevel = [];\n    }\n    /**\n     * Creates an overlay config from a dialog config.\n     * @param config The dialog configuration.\n     * @returns The overlay configuration.\n     */\n    _getOverlayConfig(config) {\n        const state = new OverlayConfig({\n            positionStrategy: config.positionStrategy ||\n                this._overlay.position().global().centerHorizontally().centerVertically(),\n            scrollStrategy: config.scrollStrategy || this._scrollStrategy(),\n            panelClass: config.panelClass,\n            hasBackdrop: config.hasBackdrop,\n            direction: config.direction,\n            minWidth: config.minWidth,\n            minHeight: config.minHeight,\n            maxWidth: config.maxWidth,\n            maxHeight: config.maxHeight,\n            width: config.width,\n            height: config.height,\n            disposeOnNavigation: config.closeOnNavigation,\n        });\n        if (config.backdropClass) {\n            state.backdropClass = config.backdropClass;\n        }\n        return state;\n    }\n    /**\n     * Attaches a dialog container to a dialog's already-created overlay.\n     * @param overlay Reference to the dialog's underlying overlay.\n     * @param config The dialog configuration.\n     * @returns A promise resolving to a ComponentRef for the attached container.\n     */\n    _attachContainer(overlay, dialogRef, config) {\n        const userInjector = config.injector || config.viewContainerRef?.injector;\n        const providers = [\n            { provide: DialogConfig, useValue: config },\n            { provide: DialogRef, useValue: dialogRef },\n            { provide: OverlayRef, useValue: overlay },\n        ];\n        let containerType;\n        if (config.container) {\n            if (typeof config.container === 'function') {\n                containerType = config.container;\n            }\n            else {\n                containerType = config.container.type;\n                providers.push(...config.container.providers(config));\n            }\n        }\n        else {\n            containerType = CdkDialogContainer;\n        }\n        const containerPortal = new ComponentPortal(containerType, config.viewContainerRef, Injector.create({ parent: userInjector || this._injector, providers }), config.componentFactoryResolver);\n        const containerRef = overlay.attach(containerPortal);\n        return containerRef.instance;\n    }\n    /**\n     * Attaches the user-provided component to the already-created dialog container.\n     * @param componentOrTemplateRef The type of component being loaded into the dialog,\n     *     or a TemplateRef to instantiate as the content.\n     * @param dialogRef Reference to the dialog being opened.\n     * @param dialogContainer Component that is going to wrap the dialog content.\n     * @param config Configuration used to open the dialog.\n     */\n    _attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config) {\n        if (componentOrTemplateRef instanceof TemplateRef) {\n            const injector = this._createInjector(config, dialogRef, dialogContainer, undefined);\n            let context = { $implicit: config.data, dialogRef };\n            if (config.templateContext) {\n                context = {\n                    ...context,\n                    ...(typeof config.templateContext === 'function'\n                        ? config.templateContext()\n                        : config.templateContext),\n                };\n            }\n            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, context, injector));\n        }\n        else {\n            const injector = this._createInjector(config, dialogRef, dialogContainer, this._injector);\n            const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector, config.componentFactoryResolver));\n            dialogRef.componentRef = contentRef;\n            dialogRef.componentInstance = contentRef.instance;\n        }\n    }\n    /**\n     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\n     * of a dialog to close itself and, optionally, to return a value.\n     * @param config Config object that is used to construct the dialog.\n     * @param dialogRef Reference to the dialog being opened.\n     * @param dialogContainer Component that is going to wrap the dialog content.\n     * @param fallbackInjector Injector to use as a fallback when a lookup fails in the custom\n     * dialog injector, if the user didn't provide a custom one.\n     * @returns The custom injector that can be used inside the dialog.\n     */\n    _createInjector(config, dialogRef, dialogContainer, fallbackInjector) {\n        const userInjector = config.injector || config.viewContainerRef?.injector;\n        const providers = [\n            { provide: DIALOG_DATA, useValue: config.data },\n            { provide: DialogRef, useValue: dialogRef },\n        ];\n        if (config.providers) {\n            if (typeof config.providers === 'function') {\n                providers.push(...config.providers(dialogRef, config, dialogContainer));\n            }\n            else {\n                providers.push(...config.providers);\n            }\n        }\n        if (config.direction &&\n            (!userInjector ||\n                !userInjector.get(Directionality, null, { optional: true }))) {\n            providers.push({\n                provide: Directionality,\n                useValue: { value: config.direction, change: of() },\n            });\n        }\n        return Injector.create({ parent: userInjector || fallbackInjector, providers });\n    }\n    /**\n     * Removes a dialog from the array of open dialogs.\n     * @param dialogRef Dialog to be removed.\n     * @param emitEvent Whether to emit an event if this is the last dialog.\n     */\n    _removeOpenDialog(dialogRef, emitEvent) {\n        const index = this.openDialogs.indexOf(dialogRef);\n        if (index > -1) {\n            this.openDialogs.splice(index, 1);\n            // If all the dialogs were closed, remove/restore the `aria-hidden`\n            // to a the siblings and emit to the `afterAllClosed` stream.\n            if (!this.openDialogs.length) {\n                this._ariaHiddenElements.forEach((previousValue, element) => {\n                    if (previousValue) {\n                        element.setAttribute('aria-hidden', previousValue);\n                    }\n                    else {\n                        element.removeAttribute('aria-hidden');\n                    }\n                });\n                this._ariaHiddenElements.clear();\n                if (emitEvent) {\n                    this._getAfterAllClosed().next();\n                }\n            }\n        }\n    }\n    /** Hides all of the content that isn't an overlay from assistive technology. */\n    _hideNonDialogContentFromAssistiveTechnology() {\n        const overlayContainer = this._overlayContainer.getContainerElement();\n        // Ensure that the overlay container is attached to the DOM.\n        if (overlayContainer.parentElement) {\n            const siblings = overlayContainer.parentElement.children;\n            for (let i = siblings.length - 1; i > -1; i--) {\n                const sibling = siblings[i];\n                if (sibling !== overlayContainer &&\n                    sibling.nodeName !== 'SCRIPT' &&\n                    sibling.nodeName !== 'STYLE' &&\n                    !sibling.hasAttribute('aria-live')) {\n                    this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\n                    sibling.setAttribute('aria-hidden', 'true');\n                }\n            }\n        }\n    }\n    _getAfterAllClosed() {\n        const parent = this._parentDialog;\n        return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: Dialog, deps: [{ token: i1$1.Overlay }, { token: i0.Injector }, { token: DEFAULT_DIALOG_CONFIG, optional: true }, { token: Dialog, optional: true, skipSelf: true }, { token: i1$1.OverlayContainer }, { token: DIALOG_SCROLL_STRATEGY }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: Dialog, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: Dialog, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1$1.Overlay }, { type: i0.Injector }, { type: DialogConfig, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DEFAULT_DIALOG_CONFIG]\n                }] }, { type: Dialog, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: i1$1.OverlayContainer }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DIALOG_SCROLL_STRATEGY]\n                }] }] });\n/**\n * Executes a callback against all elements in an array while iterating in reverse.\n * Useful if the array is being modified as it is being iterated.\n */\nfunction reverseForEach(items, callback) {\n    let i = items.length;\n    while (i--) {\n        callback(items[i]);\n    }\n}\n\nclass DialogModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: DialogModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: DialogModule, imports: [OverlayModule, PortalModule, A11yModule, CdkDialogContainer], exports: [\n            // Re-export the PortalModule so that people extending the `CdkDialogContainer`\n            // don't have to remember to import it or be faced with an unhelpful error.\n            PortalModule,\n            CdkDialogContainer] }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: DialogModule, providers: [Dialog], imports: [OverlayModule, PortalModule, A11yModule, \n            // Re-export the PortalModule so that people extending the `CdkDialogContainer`\n            // don't have to remember to import it or be faced with an unhelpful error.\n            PortalModule] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: DialogModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [OverlayModule, PortalModule, A11yModule, CdkDialogContainer],\n                    exports: [\n                        // Re-export the PortalModule so that people extending the `CdkDialogContainer`\n                        // don't have to remember to import it or be faced with an unhelpful error.\n                        PortalModule,\n                        CdkDialogContainer,\n                    ],\n                    providers: [Dialog],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkDialogContainer, DEFAULT_DIALOG_CONFIG, DIALOG_DATA, DIALOG_SCROLL_STRATEGY, DIALOG_SCROLL_STRATEGY_PROVIDER, DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, Dialog, DialogConfig, DialogModule, DialogRef, throwDialogContentAlreadyAttachedError };\n","import * as i1$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayModule } from '@angular/cdk/overlay';\nimport * as i2 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, ANIMATION_MODULE_TYPE, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Inject, InjectionToken, inject, Injectable, SkipSelf, Directive, Input, NgModule } from '@angular/core';\nimport * as i1 from '@angular/cdk/a11y';\nimport { CdkDialogContainer, Dialog, DialogConfig, DialogModule } from '@angular/cdk/dialog';\nimport { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { CdkPortalOutlet, PortalModule } from '@angular/cdk/portal';\nimport { Subject, merge, defer } from 'rxjs';\nimport { filter, take, startWith } from 'rxjs/operators';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport { MatCommonModule } from '@angular/material/core';\nimport { trigger, state, style, transition, group, animate, query, animateChild } from '@angular/animations';\n\n/**\n * Configuration for opening a modal dialog with the MatDialog service.\n */\nclass MatDialogConfig {\n    constructor() {\n        /** The ARIA role of the dialog element. */\n        this.role = 'dialog';\n        /** Custom class for the overlay pane. */\n        this.panelClass = '';\n        /** Whether the dialog has a backdrop. */\n        this.hasBackdrop = true;\n        /** Custom class for the backdrop. */\n        this.backdropClass = '';\n        /** Whether the user can use escape or clicking on the backdrop to close the modal. */\n        this.disableClose = false;\n        /** Width of the dialog. */\n        this.width = '';\n        /** Height of the dialog. */\n        this.height = '';\n        /** Data being injected into the child component. */\n        this.data = null;\n        /** ID of the element that describes the dialog. */\n        this.ariaDescribedBy = null;\n        /** ID of the element that labels the dialog. */\n        this.ariaLabelledBy = null;\n        /** Aria label to assign to the dialog element. */\n        this.ariaLabel = null;\n        /** Whether this is a modal dialog. Used to set the `aria-modal` attribute. */\n        this.ariaModal = true;\n        /**\n         * Where the dialog should focus on open.\n         * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n         * AutoFocusTarget instead.\n         */\n        this.autoFocus = 'first-tabbable';\n        /**\n         * Whether the dialog should restore focus to the\n         * previously-focused element, after it's closed.\n         */\n        this.restoreFocus = true;\n        /** Whether to wait for the opening animation to finish before trapping focus. */\n        this.delayFocusTrap = true;\n        /**\n         * Whether the dialog should close when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.closeOnNavigation = true;\n        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.\n    }\n}\n\n/** Class added when the dialog is open. */\nconst OPEN_CLASS = 'mdc-dialog--open';\n/** Class added while the dialog is opening. */\nconst OPENING_CLASS = 'mdc-dialog--opening';\n/** Class added while the dialog is closing. */\nconst CLOSING_CLASS = 'mdc-dialog--closing';\n/** Duration of the opening animation in milliseconds. */\nconst OPEN_ANIMATION_DURATION = 150;\n/** Duration of the closing animation in milliseconds. */\nconst CLOSE_ANIMATION_DURATION = 75;\nclass MatDialogContainer extends CdkDialogContainer {\n    constructor(elementRef, focusTrapFactory, _document, dialogConfig, interactivityChecker, ngZone, overlayRef, _animationMode, focusMonitor) {\n        super(elementRef, focusTrapFactory, _document, dialogConfig, interactivityChecker, ngZone, overlayRef, focusMonitor);\n        this._animationMode = _animationMode;\n        /** Emits when an animation state changes. */\n        this._animationStateChanged = new EventEmitter();\n        /** Whether animations are enabled. */\n        this._animationsEnabled = this._animationMode !== 'NoopAnimations';\n        /** Number of actions projected in the dialog. */\n        this._actionSectionCount = 0;\n        /** Host element of the dialog container component. */\n        this._hostElement = this._elementRef.nativeElement;\n        /** Duration of the dialog open animation. */\n        this._enterAnimationDuration = this._animationsEnabled\n            ? parseCssTime(this._config.enterAnimationDuration) ?? OPEN_ANIMATION_DURATION\n            : 0;\n        /** Duration of the dialog close animation. */\n        this._exitAnimationDuration = this._animationsEnabled\n            ? parseCssTime(this._config.exitAnimationDuration) ?? CLOSE_ANIMATION_DURATION\n            : 0;\n        /** Current timer for dialog animations. */\n        this._animationTimer = null;\n        /**\n         * Completes the dialog open by clearing potential animation classes, trapping\n         * focus and emitting an opened event.\n         */\n        this._finishDialogOpen = () => {\n            this._clearAnimationClasses();\n            this._openAnimationDone(this._enterAnimationDuration);\n        };\n        /**\n         * Completes the dialog close by clearing potential animation classes, restoring\n         * focus and emitting a closed event.\n         */\n        this._finishDialogClose = () => {\n            this._clearAnimationClasses();\n            this._animationStateChanged.emit({ state: 'closed', totalTime: this._exitAnimationDuration });\n        };\n    }\n    _contentAttached() {\n        // Delegate to the original dialog-container initialization (i.e. saving the\n        // previous element, setting up the focus trap and moving focus to the container).\n        super._contentAttached();\n        // Note: Usually we would be able to use the MDC dialog foundation here to handle\n        // the dialog animation for us, but there are a few reasons why we just leverage\n        // their styles and not use the runtime foundation code:\n        //   1. Foundation does not allow us to disable animations.\n        //   2. Foundation contains unnecessary features we don't need and aren't\n        //      tree-shakeable. e.g. background scrim, keyboard event handlers for ESC button.\n        //   3. Foundation uses unnecessary timers for animations to work around limitations\n        //      in React's `setState` mechanism.\n        //      https://github.com/material-components/material-components-web/pull/3682.\n        this._startOpenAnimation();\n    }\n    /** Starts the dialog open animation if enabled. */\n    _startOpenAnimation() {\n        this._animationStateChanged.emit({ state: 'opening', totalTime: this._enterAnimationDuration });\n        if (this._animationsEnabled) {\n            this._hostElement.style.setProperty(TRANSITION_DURATION_PROPERTY, `${this._enterAnimationDuration}ms`);\n            // We need to give the `setProperty` call from above some time to be applied.\n            // One would expect that the open class is added once the animation finished, but MDC\n            // uses the open class in combination with the opening class to start the animation.\n            this._requestAnimationFrame(() => this._hostElement.classList.add(OPENING_CLASS, OPEN_CLASS));\n            this._waitForAnimationToComplete(this._enterAnimationDuration, this._finishDialogOpen);\n        }\n        else {\n            this._hostElement.classList.add(OPEN_CLASS);\n            // Note: We could immediately finish the dialog opening here with noop animations,\n            // but we defer until next tick so that consumers can subscribe to `afterOpened`.\n            // Executing this immediately would mean that `afterOpened` emits synchronously\n            // on `dialog.open` before the consumer had a change to subscribe to `afterOpened`.\n            Promise.resolve().then(() => this._finishDialogOpen());\n        }\n    }\n    /**\n     * Starts the exit animation of the dialog if enabled. This method is\n     * called by the dialog ref.\n     */\n    _startExitAnimation() {\n        this._animationStateChanged.emit({ state: 'closing', totalTime: this._exitAnimationDuration });\n        this._hostElement.classList.remove(OPEN_CLASS);\n        if (this._animationsEnabled) {\n            this._hostElement.style.setProperty(TRANSITION_DURATION_PROPERTY, `${this._exitAnimationDuration}ms`);\n            // We need to give the `setProperty` call from above some time to be applied.\n            this._requestAnimationFrame(() => this._hostElement.classList.add(CLOSING_CLASS));\n            this._waitForAnimationToComplete(this._exitAnimationDuration, this._finishDialogClose);\n        }\n        else {\n            // This subscription to the `OverlayRef#backdropClick` observable in the `DialogRef` is\n            // set up before any user can subscribe to the backdrop click. The subscription triggers\n            // the dialog close and this method synchronously. If we'd synchronously emit the `CLOSED`\n            // animation state event if animations are disabled, the overlay would be disposed\n            // immediately and all other subscriptions to `DialogRef#backdropClick` would be silently\n            // skipped. We work around this by waiting with the dialog close until the next tick when\n            // all subscriptions have been fired as expected. This is not an ideal solution, but\n            // there doesn't seem to be any other good way. Alternatives that have been considered:\n            //   1. Deferring `DialogRef.close`. This could be a breaking change due to a new microtask.\n            //      Also this issue is specific to the MDC implementation where the dialog could\n            //      technically be closed synchronously. In the non-MDC one, Angular animations are used\n            //      and closing always takes at least a tick.\n            //   2. Ensuring that user subscriptions to `backdropClick`, `keydownEvents` in the dialog\n            //      ref are first. This would solve the issue, but has the risk of memory leaks and also\n            //      doesn't solve the case where consumers call `DialogRef.close` in their subscriptions.\n            // Based on the fact that this is specific to the MDC-based implementation of the dialog\n            // animations, the defer is applied here.\n            Promise.resolve().then(() => this._finishDialogClose());\n        }\n    }\n    /**\n     * Updates the number action sections.\n     * @param delta Increase/decrease in the number of sections.\n     */\n    _updateActionSectionCount(delta) {\n        this._actionSectionCount += delta;\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Clears all dialog animation classes. */\n    _clearAnimationClasses() {\n        this._hostElement.classList.remove(OPENING_CLASS, CLOSING_CLASS);\n    }\n    _waitForAnimationToComplete(duration, callback) {\n        if (this._animationTimer !== null) {\n            clearTimeout(this._animationTimer);\n        }\n        // Note that we want this timer to run inside the NgZone, because we want\n        // the related events like `afterClosed` to be inside the zone as well.\n        this._animationTimer = setTimeout(callback, duration);\n    }\n    /** Runs a callback in `requestAnimationFrame`, if available. */\n    _requestAnimationFrame(callback) {\n        this._ngZone.runOutsideAngular(() => {\n            if (typeof requestAnimationFrame === 'function') {\n                requestAnimationFrame(callback);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    _captureInitialFocus() {\n        if (!this._config.delayFocusTrap) {\n            this._trapFocus();\n        }\n    }\n    /**\n     * Callback for when the open dialog animation has finished. Intended to\n     * be called by sub-classes that use different animation implementations.\n     */\n    _openAnimationDone(totalTime) {\n        if (this._config.delayFocusTrap) {\n            this._trapFocus();\n        }\n        this._animationStateChanged.next({ state: 'opened', totalTime });\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._animationTimer !== null) {\n            clearTimeout(this._animationTimer);\n        }\n    }\n    attachComponentPortal(portal) {\n        // When a component is passed into the dialog, the host element interrupts\n        // the `display:flex` from affecting the dialog title, content, and\n        // actions. To fix this, we make the component host `display: contents` by\n        // marking its host with the `mat-mdc-dialog-component-host` class.\n        //\n        // Note that this problem does not exist when a template ref is used since\n        // the title, contents, and actions are then nested directly under the\n        // dialog surface.\n        const ref = super.attachComponentPortal(portal);\n        ref.location.nativeElement.classList.add('mat-mdc-dialog-component-host');\n        return ref;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogContainer, deps: [{ token: i0.ElementRef }, { token: i1.FocusTrapFactory }, { token: DOCUMENT, optional: true }, { token: MatDialogConfig }, { token: i1.InteractivityChecker }, { token: i0.NgZone }, { token: i1$1.OverlayRef }, { token: ANIMATION_MODULE_TYPE, optional: true }, { token: i1.FocusMonitor }], target: i0.FactoryTarget.Component }); }\n    static { this.cmp = i0.ngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatDialogContainer, isStandalone: true, selector: \"mat-dialog-container\", host: { attributes: { \"tabindex\": \"-1\" }, properties: { \"attr.aria-modal\": \"_config.ariaModal\", \"id\": \"_config.id\", \"attr.role\": \"_config.role\", \"attr.aria-labelledby\": \"_config.ariaLabel ? null : _ariaLabelledByQueue[0]\", \"attr.aria-label\": \"_config.ariaLabel\", \"attr.aria-describedby\": \"_config.ariaDescribedBy || null\", \"class._mat-animation-noopable\": \"!_animationsEnabled\", \"class.mat-mdc-dialog-container-with-actions\": \"_actionSectionCount > 0\" }, classAttribute: \"mat-mdc-dialog-container mdc-dialog\" }, usesInheritance: true, ngImport: i0, template: \"<div class=\\\"mdc-dialog__container\\\">\\n  <div class=\\\"mat-mdc-dialog-surface mdc-dialog__surface\\\">\\n    <ng-template cdkPortalOutlet />\\n  </div>\\n</div>\\n\", styles: [\".mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0;transform:scale(0.8)}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:\\\"\\\";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:\\\"\\\";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--closing .mdc-dialog__surface{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{opacity:1}.mdc-dialog--open .mdc-dialog__surface{transform:none}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{width:100%;height:100%}.mat-mdc-dialog-component-host{display:contents}.mat-mdc-dialog-container{--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition:opacity linear var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container .mdc-dialog__surface{transition:transform var(--mat-dialog-transition-duration, 0ms) 0ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container,.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__surface{transition:none}.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-max-width, 80vw);min-width:var(--mat-dialog-container-min-width, 0)}@media(max-width: 599px){.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-small-max-width, 80vw)}}.mat-mdc-dialog-title{padding:var(--mat-dialog-headline-padding, 0 24px 9px)}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-container .mat-mdc-dialog-content{padding:var(--mat-dialog-content-padding, 20px 24px)}.mat-mdc-dialog-container-with-actions .mat-mdc-dialog-content{padding:var(--mat-dialog-with-actions-content-padding, 20px 24px)}.mat-mdc-dialog-container .mat-mdc-dialog-title+.mat-mdc-dialog-content{padding-top:0}.mat-mdc-dialog-actions{padding:var(--mat-dialog-actions-padding, 8px);justify-content:var(--mat-dialog-actions-alignment, start)}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-start,.mat-mdc-dialog-actions[align=start]{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\"], dependencies: [{ kind: \"directive\", type: CdkPortalOutlet, selector: \"[cdkPortalOutlet]\", inputs: [\"cdkPortalOutlet\"], outputs: [\"attached\"], exportAs: [\"cdkPortalOutlet\"] }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogContainer, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-dialog-container', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.Default, standalone: true, imports: [CdkPortalOutlet], host: {\n                        'class': 'mat-mdc-dialog-container mdc-dialog',\n                        'tabindex': '-1',\n                        '[attr.aria-modal]': '_config.ariaModal',\n                        '[id]': '_config.id',\n                        '[attr.role]': '_config.role',\n                        '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledByQueue[0]',\n                        '[attr.aria-label]': '_config.ariaLabel',\n                        '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\n                        '[class._mat-animation-noopable]': '!_animationsEnabled',\n                        '[class.mat-mdc-dialog-container-with-actions]': '_actionSectionCount > 0',\n                    }, template: \"<div class=\\\"mdc-dialog__container\\\">\\n  <div class=\\\"mat-mdc-dialog-surface mdc-dialog__surface\\\">\\n    <ng-template cdkPortalOutlet />\\n  </div>\\n</div>\\n\", styles: [\".mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0;transform:scale(0.8)}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:\\\"\\\";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:\\\"\\\";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--closing .mdc-dialog__surface{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{opacity:1}.mdc-dialog--open .mdc-dialog__surface{transform:none}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{width:100%;height:100%}.mat-mdc-dialog-component-host{display:contents}.mat-mdc-dialog-container{--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition:opacity linear var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container .mdc-dialog__surface{transition:transform var(--mat-dialog-transition-duration, 0ms) 0ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container,.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__surface{transition:none}.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-max-width, 80vw);min-width:var(--mat-dialog-container-min-width, 0)}@media(max-width: 599px){.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-small-max-width, 80vw)}}.mat-mdc-dialog-title{padding:var(--mat-dialog-headline-padding, 0 24px 9px)}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-container .mat-mdc-dialog-content{padding:var(--mat-dialog-content-padding, 20px 24px)}.mat-mdc-dialog-container-with-actions .mat-mdc-dialog-content{padding:var(--mat-dialog-with-actions-content-padding, 20px 24px)}.mat-mdc-dialog-container .mat-mdc-dialog-title+.mat-mdc-dialog-content{padding-top:0}.mat-mdc-dialog-actions{padding:var(--mat-dialog-actions-padding, 8px);justify-content:var(--mat-dialog-actions-alignment, start)}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-start,.mat-mdc-dialog-actions[align=start]{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.FocusTrapFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: MatDialogConfig }, { type: i1.InteractivityChecker }, { type: i0.NgZone }, { type: i1$1.OverlayRef }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ANIMATION_MODULE_TYPE]\n                }] }, { type: i1.FocusMonitor }] });\nconst TRANSITION_DURATION_PROPERTY = '--mat-dialog-transition-duration';\n// TODO(mmalerba): Remove this function after animation durations are required\n//  to be numbers.\n/**\n * Converts a CSS time string to a number in ms. If the given time is already a\n * number, it is assumed to be in ms.\n */\nfunction parseCssTime(time) {\n    if (time == null) {\n        return null;\n    }\n    if (typeof time === 'number') {\n        return time;\n    }\n    if (time.endsWith('ms')) {\n        return coerceNumberProperty(time.substring(0, time.length - 2));\n    }\n    if (time.endsWith('s')) {\n        return coerceNumberProperty(time.substring(0, time.length - 1)) * 1000;\n    }\n    if (time === '0') {\n        return 0;\n    }\n    return null; // anything else is invalid.\n}\n\nvar MatDialogState;\n(function (MatDialogState) {\n    MatDialogState[MatDialogState[\"OPEN\"] = 0] = \"OPEN\";\n    MatDialogState[MatDialogState[\"CLOSING\"] = 1] = \"CLOSING\";\n    MatDialogState[MatDialogState[\"CLOSED\"] = 2] = \"CLOSED\";\n})(MatDialogState || (MatDialogState = {}));\n/**\n * Reference to a dialog opened via the MatDialog service.\n */\nclass MatDialogRef {\n    constructor(_ref, config, _containerInstance) {\n        this._ref = _ref;\n        this._containerInstance = _containerInstance;\n        /** Subject for notifying the user that the dialog has finished opening. */\n        this._afterOpened = new Subject();\n        /** Subject for notifying the user that the dialog has started closing. */\n        this._beforeClosed = new Subject();\n        /** Current state of the dialog. */\n        this._state = MatDialogState.OPEN;\n        this.disableClose = config.disableClose;\n        this.id = _ref.id;\n        // Used to target panels specifically tied to dialogs.\n        _ref.addPanelClass('mat-mdc-dialog-panel');\n        // Emit when opening animation completes\n        _containerInstance._animationStateChanged\n            .pipe(filter(event => event.state === 'opened'), take(1))\n            .subscribe(() => {\n            this._afterOpened.next();\n            this._afterOpened.complete();\n        });\n        // Dispose overlay when closing animation is complete\n        _containerInstance._animationStateChanged\n            .pipe(filter(event => event.state === 'closed'), take(1))\n            .subscribe(() => {\n            clearTimeout(this._closeFallbackTimeout);\n            this._finishDialogClose();\n        });\n        _ref.overlayRef.detachments().subscribe(() => {\n            this._beforeClosed.next(this._result);\n            this._beforeClosed.complete();\n            this._finishDialogClose();\n        });\n        merge(this.backdropClick(), this.keydownEvents().pipe(filter(event => event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)))).subscribe(event => {\n            if (!this.disableClose) {\n                event.preventDefault();\n                _closeDialogVia(this, event.type === 'keydown' ? 'keyboard' : 'mouse');\n            }\n        });\n    }\n    /**\n     * Close the dialog.\n     * @param dialogResult Optional result to return to the dialog opener.\n     */\n    close(dialogResult) {\n        this._result = dialogResult;\n        // Transition the backdrop in parallel to the dialog.\n        this._containerInstance._animationStateChanged\n            .pipe(filter(event => event.state === 'closing'), take(1))\n            .subscribe(event => {\n            this._beforeClosed.next(dialogResult);\n            this._beforeClosed.complete();\n            this._ref.overlayRef.detachBackdrop();\n            // The logic that disposes of the overlay depends on the exit animation completing, however\n            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback\n            // timeout which will clean everything up if the animation hasn't fired within the specified\n            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the\n            // vast majority of cases the timeout will have been cleared before it has the chance to fire.\n            this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), event.totalTime + 100);\n        });\n        this._state = MatDialogState.CLOSING;\n        this._containerInstance._startExitAnimation();\n    }\n    /**\n     * Gets an observable that is notified when the dialog is finished opening.\n     */\n    afterOpened() {\n        return this._afterOpened;\n    }\n    /**\n     * Gets an observable that is notified when the dialog is finished closing.\n     */\n    afterClosed() {\n        return this._ref.closed;\n    }\n    /**\n     * Gets an observable that is notified when the dialog has started closing.\n     */\n    beforeClosed() {\n        return this._beforeClosed;\n    }\n    /**\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\n     */\n    backdropClick() {\n        return this._ref.backdropClick;\n    }\n    /**\n     * Gets an observable that emits when keydown events are targeted on the overlay.\n     */\n    keydownEvents() {\n        return this._ref.keydownEvents;\n    }\n    /**\n     * Updates the dialog's position.\n     * @param position New dialog position.\n     */\n    updatePosition(position) {\n        let strategy = this._ref.config.positionStrategy;\n        if (position && (position.left || position.right)) {\n            position.left ? strategy.left(position.left) : strategy.right(position.right);\n        }\n        else {\n            strategy.centerHorizontally();\n        }\n        if (position && (position.top || position.bottom)) {\n            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\n        }\n        else {\n            strategy.centerVertically();\n        }\n        this._ref.updatePosition();\n        return this;\n    }\n    /**\n     * Updates the dialog's width and height.\n     * @param width New width of the dialog.\n     * @param height New height of the dialog.\n     */\n    updateSize(width = '', height = '') {\n        this._ref.updateSize(width, height);\n        return this;\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        this._ref.addPanelClass(classes);\n        return this;\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        this._ref.removePanelClass(classes);\n        return this;\n    }\n    /** Gets the current state of the dialog's lifecycle. */\n    getState() {\n        return this._state;\n    }\n    /**\n     * Finishes the dialog close by updating the state of the dialog\n     * and disposing the overlay.\n     */\n    _finishDialogClose() {\n        this._state = MatDialogState.CLOSED;\n        this._ref.close(this._result, { focusOrigin: this._closeInteractionType });\n        this.componentInstance = null;\n    }\n}\n/**\n * Closes the dialog with the specified interaction type. This is currently not part of\n * `MatDialogRef` as that would conflict with custom dialog ref mocks provided in tests.\n * More details. See: https://github.com/angular/components/pull/9257#issuecomment-651342226.\n */\n// TODO: Move this back into `MatDialogRef` when we provide an official mock dialog ref.\nfunction _closeDialogVia(ref, interactionType, result) {\n    ref._closeInteractionType = interactionType;\n    return ref.close(result);\n}\n\n/** Injection token that can be used to access the data that was passed in to a dialog. */\nconst MAT_DIALOG_DATA = new InjectionToken('MatMdcDialogData');\n/** Injection token that can be used to specify default dialog options. */\nconst MAT_DIALOG_DEFAULT_OPTIONS = new InjectionToken('mat-mdc-dialog-default-options');\n/** Injection token that determines the scroll handling while the dialog is open. */\nconst MAT_DIALOG_SCROLL_STRATEGY = new InjectionToken('mat-mdc-dialog-scroll-strategy', {\n    providedIn: 'root',\n    factory: () => {\n        const overlay = inject(Overlay);\n        return () => overlay.scrollStrategies.block();\n    },\n});\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nfunction MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.block();\n}\n/**\n * @docs-private\n * @deprecated No longer used. To be removed.\n * @breaking-change 19.0.0\n */\nconst MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_DIALOG_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n// Counter for unique dialog ids.\nlet uniqueId = 0;\n/**\n * Service to open Material Design modal dialogs.\n */\nclass MatDialog {\n    /** Keeps track of the currently-open dialogs. */\n    get openDialogs() {\n        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n    }\n    /** Stream that emits when a dialog has been opened. */\n    get afterOpened() {\n        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n    }\n    _getAfterAllClosed() {\n        const parent = this._parentDialog;\n        return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n    }\n    constructor(_overlay, injector, \n    /**\n     * @deprecated `_location` parameter to be removed.\n     * @breaking-change 10.0.0\n     */\n    location, _defaultOptions, _scrollStrategy, _parentDialog, \n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 15.0.0\n     */\n    _overlayContainer, \n    /**\n     * @deprecated No longer used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    _animationMode) {\n        this._overlay = _overlay;\n        this._defaultOptions = _defaultOptions;\n        this._scrollStrategy = _scrollStrategy;\n        this._parentDialog = _parentDialog;\n        this._openDialogsAtThisLevel = [];\n        this._afterAllClosedAtThisLevel = new Subject();\n        this._afterOpenedAtThisLevel = new Subject();\n        this.dialogConfigClass = MatDialogConfig;\n        /**\n         * Stream that emits when all open dialog have finished closing.\n         * Will emit on subscribe if there are no open dialogs to begin with.\n         */\n        this.afterAllClosed = defer(() => this.openDialogs.length\n            ? this._getAfterAllClosed()\n            : this._getAfterAllClosed().pipe(startWith(undefined)));\n        this._dialog = injector.get(Dialog);\n        this._dialogRefConstructor = MatDialogRef;\n        this._dialogContainerType = MatDialogContainer;\n        this._dialogDataToken = MAT_DIALOG_DATA;\n    }\n    open(componentOrTemplateRef, config) {\n        let dialogRef;\n        config = { ...(this._defaultOptions || new MatDialogConfig()), ...config };\n        config.id = config.id || `mat-mdc-dialog-${uniqueId++}`;\n        config.scrollStrategy = config.scrollStrategy || this._scrollStrategy();\n        const cdkRef = this._dialog.open(componentOrTemplateRef, {\n            ...config,\n            positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(),\n            // Disable closing since we need to sync it up to the animation ourselves.\n            disableClose: true,\n            // Disable closing on destroy, because this service cleans up its open dialogs as well.\n            // We want to do the cleanup here, rather than the CDK service, because the CDK destroys\n            // the dialogs immediately whereas we want it to wait for the animations to finish.\n            closeOnDestroy: false,\n            // Disable closing on detachments so that we can sync up the animation.\n            // The Material dialog ref handles this manually.\n            closeOnOverlayDetachments: false,\n            container: {\n                type: this._dialogContainerType,\n                providers: () => [\n                    // Provide our config as the CDK config as well since it has the same interface as the\n                    // CDK one, but it contains the actual values passed in by the user for things like\n                    // `disableClose` which we disable for the CDK dialog since we handle it ourselves.\n                    { provide: this.dialogConfigClass, useValue: config },\n                    { provide: DialogConfig, useValue: config },\n                ],\n            },\n            templateContext: () => ({ dialogRef }),\n            providers: (ref, cdkConfig, dialogContainer) => {\n                dialogRef = new this._dialogRefConstructor(ref, config, dialogContainer);\n                dialogRef.updatePosition(config?.position);\n                return [\n                    { provide: this._dialogContainerType, useValue: dialogContainer },\n                    { provide: this._dialogDataToken, useValue: cdkConfig.data },\n                    { provide: this._dialogRefConstructor, useValue: dialogRef },\n                ];\n            },\n        });\n        // This can't be assigned in the `providers` callback, because\n        // the instance hasn't been assigned to the CDK ref yet.\n        dialogRef.componentRef = cdkRef.componentRef;\n        dialogRef.componentInstance = cdkRef.componentInstance;\n        this.openDialogs.push(dialogRef);\n        this.afterOpened.next(dialogRef);\n        dialogRef.afterClosed().subscribe(() => {\n            const index = this.openDialogs.indexOf(dialogRef);\n            if (index > -1) {\n                this.openDialogs.splice(index, 1);\n                if (!this.openDialogs.length) {\n                    this._getAfterAllClosed().next();\n                }\n            }\n        });\n        return dialogRef;\n    }\n    /**\n     * Closes all of the currently-open dialogs.\n     */\n    closeAll() {\n        this._closeDialogs(this.openDialogs);\n    }\n    /**\n     * Finds an open dialog by its id.\n     * @param id ID to use when looking up the dialog.\n     */\n    getDialogById(id) {\n        return this.openDialogs.find(dialog => dialog.id === id);\n    }\n    ngOnDestroy() {\n        // Only close the dialogs at this level on destroy\n        // since the parent service may still be active.\n        this._closeDialogs(this._openDialogsAtThisLevel);\n        this._afterAllClosedAtThisLevel.complete();\n        this._afterOpenedAtThisLevel.complete();\n    }\n    _closeDialogs(dialogs) {\n        let i = dialogs.length;\n        while (i--) {\n            dialogs[i].close();\n        }\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialog, deps: [{ token: i1$1.Overlay }, { token: i0.Injector }, { token: i2.Location, optional: true }, { token: MAT_DIALOG_DEFAULT_OPTIONS, optional: true }, { token: MAT_DIALOG_SCROLL_STRATEGY }, { token: MatDialog, optional: true, skipSelf: true }, { token: i1$1.OverlayContainer }, { token: ANIMATION_MODULE_TYPE, optional: true }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialog, providedIn: 'root' }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialog, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1$1.Overlay }, { type: i0.Injector }, { type: i2.Location, decorators: [{\n                    type: Optional\n                }] }, { type: MatDialogConfig, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_DIALOG_DEFAULT_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_DIALOG_SCROLL_STRATEGY]\n                }] }, { type: MatDialog, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: i1$1.OverlayContainer }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ANIMATION_MODULE_TYPE]\n                }] }] });\n\n/** Counter used to generate unique IDs for dialog elements. */\nlet dialogElementUid = 0;\n/**\n * Button that will close the current dialog.\n */\nclass MatDialogClose {\n    constructor(\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\n    // tslint:disable-next-line: lightweight-tokens\n    dialogRef, _elementRef, _dialog) {\n        this.dialogRef = dialogRef;\n        this._elementRef = _elementRef;\n        this._dialog = _dialog;\n        /** Default to \"button\" to prevents accidental form submits. */\n        this.type = 'button';\n    }\n    ngOnInit() {\n        if (!this.dialogRef) {\n            // When this directive is included in a dialog via TemplateRef (rather than being\n            // in a Component), the DialogRef isn't available via injection because embedded\n            // views cannot be given a custom injector. Instead, we look up the DialogRef by\n            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't\n            // be resolved at constructor time.\n            this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);\n        }\n    }\n    ngOnChanges(changes) {\n        const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];\n        if (proxiedChange) {\n            this.dialogResult = proxiedChange.currentValue;\n        }\n    }\n    _onButtonClick(event) {\n        // Determinate the focus origin using the click event, because using the FocusMonitor will\n        // result in incorrect origins. Most of the time, close buttons will be auto focused in the\n        // dialog, and therefore clicking the button won't result in a focus change. This means that\n        // the FocusMonitor won't detect any origin change, and will always output `program`.\n        _closeDialogVia(this.dialogRef, event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse', this.dialogResult);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogClose, deps: [{ token: MatDialogRef, optional: true }, { token: i0.ElementRef }, { token: MatDialog }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatDialogClose, isStandalone: true, selector: \"[mat-dialog-close], [matDialogClose]\", inputs: { ariaLabel: [\"aria-label\", \"ariaLabel\"], type: \"type\", dialogResult: [\"mat-dialog-close\", \"dialogResult\"], _matDialogClose: [\"matDialogClose\", \"_matDialogClose\"] }, host: { listeners: { \"click\": \"_onButtonClick($event)\" }, properties: { \"attr.aria-label\": \"ariaLabel || null\", \"attr.type\": \"type\" } }, exportAs: [\"matDialogClose\"], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogClose, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-dialog-close], [matDialogClose]',\n                    exportAs: 'matDialogClose',\n                    standalone: true,\n                    host: {\n                        '(click)': '_onButtonClick($event)',\n                        '[attr.aria-label]': 'ariaLabel || null',\n                        '[attr.type]': 'type',\n                    },\n                }]\n        }], ctorParameters: () => [{ type: MatDialogRef, decorators: [{\n                    type: Optional\n                }] }, { type: i0.ElementRef }, { type: MatDialog }], propDecorators: { ariaLabel: [{\n                type: Input,\n                args: ['aria-label']\n            }], type: [{\n                type: Input\n            }], dialogResult: [{\n                type: Input,\n                args: ['mat-dialog-close']\n            }], _matDialogClose: [{\n                type: Input,\n                args: ['matDialogClose']\n            }] } });\nclass MatDialogLayoutSection {\n    constructor(\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\n    // tslint:disable-next-line: lightweight-tokens\n    _dialogRef, _elementRef, _dialog) {\n        this._dialogRef = _dialogRef;\n        this._elementRef = _elementRef;\n        this._dialog = _dialog;\n    }\n    ngOnInit() {\n        if (!this._dialogRef) {\n            this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);\n        }\n        if (this._dialogRef) {\n            Promise.resolve().then(() => {\n                this._onAdd();\n            });\n        }\n    }\n    ngOnDestroy() {\n        // Note: we null check because there are some internal\n        // tests that are mocking out `MatDialogRef` incorrectly.\n        const instance = this._dialogRef?._containerInstance;\n        if (instance) {\n            Promise.resolve().then(() => {\n                this._onRemove();\n            });\n        }\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogLayoutSection, deps: [{ token: MatDialogRef, optional: true }, { token: i0.ElementRef }, { token: MatDialog }], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatDialogLayoutSection, isStandalone: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogLayoutSection, decorators: [{\n            type: Directive,\n            args: [{ standalone: true }]\n        }], ctorParameters: () => [{ type: MatDialogRef, decorators: [{\n                    type: Optional\n                }] }, { type: i0.ElementRef }, { type: MatDialog }] });\n/**\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\n */\nclass MatDialogTitle extends MatDialogLayoutSection {\n    constructor() {\n        super(...arguments);\n        this.id = `mat-mdc-dialog-title-${dialogElementUid++}`;\n    }\n    _onAdd() {\n        // Note: we null check the queue, because there are some internal\n        // tests that are mocking out `MatDialogRef` incorrectly.\n        this._dialogRef._containerInstance?._addAriaLabelledBy?.(this.id);\n    }\n    _onRemove() {\n        this._dialogRef?._containerInstance?._removeAriaLabelledBy?.(this.id);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogTitle, deps: null, target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatDialogTitle, isStandalone: true, selector: \"[mat-dialog-title], [matDialogTitle]\", inputs: { id: \"id\" }, host: { properties: { \"id\": \"id\" }, classAttribute: \"mat-mdc-dialog-title mdc-dialog__title\" }, exportAs: [\"matDialogTitle\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogTitle, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-dialog-title], [matDialogTitle]',\n                    exportAs: 'matDialogTitle',\n                    standalone: true,\n                    host: {\n                        'class': 'mat-mdc-dialog-title mdc-dialog__title',\n                        '[id]': 'id',\n                    },\n                }]\n        }], propDecorators: { id: [{\n                type: Input\n            }] } });\n/**\n * Scrollable content container of a dialog.\n */\nclass MatDialogContent {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogContent, deps: [], target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatDialogContent, isStandalone: true, selector: \"[mat-dialog-content], mat-dialog-content, [matDialogContent]\", host: { classAttribute: \"mat-mdc-dialog-content mdc-dialog__content\" }, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogContent, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,\n                    host: { 'class': 'mat-mdc-dialog-content mdc-dialog__content' },\n                    standalone: true,\n                }]\n        }] });\n/**\n * Container for the bottom action buttons in a dialog.\n * Stays fixed to the bottom when scrolling.\n */\nclass MatDialogActions extends MatDialogLayoutSection {\n    _onAdd() {\n        this._dialogRef._containerInstance?._updateActionSectionCount?.(1);\n    }\n    _onRemove() {\n        this._dialogRef._containerInstance?._updateActionSectionCount?.(-1);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogActions, deps: null, target: i0.FactoryTarget.Directive }); }\n    static { this.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.2.0\", type: MatDialogActions, isStandalone: true, selector: \"[mat-dialog-actions], mat-dialog-actions, [matDialogActions]\", inputs: { align: \"align\" }, host: { properties: { \"class.mat-mdc-dialog-actions-align-start\": \"align === \\\"start\\\"\", \"class.mat-mdc-dialog-actions-align-center\": \"align === \\\"center\\\"\", \"class.mat-mdc-dialog-actions-align-end\": \"align === \\\"end\\\"\" }, classAttribute: \"mat-mdc-dialog-actions mdc-dialog__actions\" }, usesInheritance: true, ngImport: i0 }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogActions, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,\n                    standalone: true,\n                    host: {\n                        'class': 'mat-mdc-dialog-actions mdc-dialog__actions',\n                        '[class.mat-mdc-dialog-actions-align-start]': 'align === \"start\"',\n                        '[class.mat-mdc-dialog-actions-align-center]': 'align === \"center\"',\n                        '[class.mat-mdc-dialog-actions-align-end]': 'align === \"end\"',\n                    },\n                }]\n        }], propDecorators: { align: [{\n                type: Input\n            }] } });\n/**\n * Finds the closest MatDialogRef to an element by looking at the DOM.\n * @param element Element relative to which to look for a dialog.\n * @param openDialogs References to the currently-open dialogs.\n */\nfunction getClosestDialog(element, openDialogs) {\n    let parent = element.nativeElement.parentElement;\n    while (parent && !parent.classList.contains('mat-mdc-dialog-container')) {\n        parent = parent.parentElement;\n    }\n    return parent ? openDialogs.find(dialog => dialog.id === parent.id) : null;\n}\n\nconst DIRECTIVES = [\n    MatDialogContainer,\n    MatDialogClose,\n    MatDialogTitle,\n    MatDialogActions,\n    MatDialogContent,\n];\nclass MatDialogModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogModule, imports: [DialogModule, OverlayModule, PortalModule, MatCommonModule, MatDialogContainer,\n            MatDialogClose,\n            MatDialogTitle,\n            MatDialogActions,\n            MatDialogContent], exports: [MatCommonModule, MatDialogContainer,\n            MatDialogClose,\n            MatDialogTitle,\n            MatDialogActions,\n            MatDialogContent] }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogModule, providers: [MatDialog], imports: [DialogModule, OverlayModule, PortalModule, MatCommonModule, MatCommonModule] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.2.0\", ngImport: i0, type: MatDialogModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [DialogModule, OverlayModule, PortalModule, MatCommonModule, ...DIRECTIVES],\n                    exports: [MatCommonModule, ...DIRECTIVES],\n                    providers: [MatDialog],\n                }]\n        }] });\n\n/**\n * Default parameters for the animation for backwards compatibility.\n * @docs-private\n */\nconst _defaultParams = {\n    params: { enterAnimationDuration: '150ms', exitAnimationDuration: '75ms' },\n};\n/**\n * Animations used by MatDialog.\n * @docs-private\n */\nconst matDialogAnimations = {\n    /** Animation that is applied on the dialog container by default. */\n    dialogContainer: trigger('dialogContainer', [\n        // Note: The `enter` animation transitions to `transform: none`, because for some reason\n        // specifying the transform explicitly, causes IE both to blur the dialog content and\n        // decimate the animation performance. Leaving it as `none` solves both issues.\n        state('void, exit', style({ opacity: 0, transform: 'scale(0.7)' })),\n        state('enter', style({ transform: 'none' })),\n        transition('* => enter', group([\n            animate('{{enterAnimationDuration}} cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'none', opacity: 1 })),\n            query('@*', animateChild(), { optional: true }),\n        ]), _defaultParams),\n        transition('* => void, * => exit', group([\n            animate('{{exitAnimationDuration}} cubic-bezier(0.4, 0.0, 0.2, 1)', style({ opacity: 0 })),\n            query('@*', animateChild(), { optional: true }),\n        ]), _defaultParams),\n    ]),\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_DIALOG_DATA, MAT_DIALOG_DEFAULT_OPTIONS, MAT_DIALOG_SCROLL_STRATEGY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, MatDialog, MatDialogActions, MatDialogClose, MatDialogConfig, MatDialogContainer, MatDialogContent, MatDialogModule, MatDialogRef, MatDialogState, MatDialogTitle, _closeDialogVia, _defaultParams, matDialogAnimations };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]}