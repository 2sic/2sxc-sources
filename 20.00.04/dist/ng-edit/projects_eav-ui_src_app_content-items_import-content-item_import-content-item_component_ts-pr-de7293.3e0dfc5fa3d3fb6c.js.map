{"version":3,"file":"projects_eav-ui_src_app_content-items_import-content-item_import-content-item_component_ts-pr-de7293.3e0dfc5fa3d3fb6c.js","mappings":"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","names":["logSpecs","getAll","getAllLive","getAllOnce","ContentItemsService","HttpServiceBaseSignal","constructor","this","log","classLog","getAllPromise","contentTypeStaticName","fnIf","fetchPromise","webApiEntityList","params","appId","contentType","httpResource","url","apiUrl","refresh","getColumnsPromise","webApiFieldsAll","staticName","importItem","file","from","toBase64","pipe","switchMap","fileBase64","http","post","webApiEntityRoot","AppId","ContentBase64","map","success","Success","Messages","static","__ngFactoryType__","_angular_core__WEBPACK_IMPORTED_MODULE_10__","jDH","factory","ɵfac","ErrorStateMatcher","isErrorState","control","form","invalid","touched","submitted","i0","token","providedIn","MatFormFieldModule","type","imports","MatCommonModule","ObserversModule","MatFormField","_ErrorStateTracker","_defaultMatcher","ngControl","_parentFormGroup","_parentForm","_stateChanges","errorState","matcher","updateErrorState","oldState","parent","newState","next","ImportContentItemComponent","dialogData","uploadType","UploadTypes","ContentItem","contentItemsService","transient","title","description","allowedFileTypes","upload$","files","MAT_DIALOG_DATA","_angular_core__WEBPACK_IMPORTED_MODULE_3__","VBU","selectors","decls","vars","consts","template","rf","ctx","FileUploadDialogComponent","encapsulation","SafeHtmlPipe","sanitizer","transform","html","bypassSecurityTrustHtml","i1","_angular_core__WEBPACK_IMPORTED_MODULE_0__","EJ8","pure","_c0","MAT_ICON_DEFAULT_OPTIONS","InjectionToken","MAT_ICON_LOCATION","MAT_ICON_LOCATION_FACTORY","_document","inject","DOCUMENT","_location","location","getPathname","pathname","search","funcIriAttributes","funcIriAttributeSelector","attr","join","funcIriPattern","MatIcon","_elementRef","ElementRef","_iconRegistry","MatIconRegistry","_errorHandler","ErrorHandler","_defaultColor","color","_color","value","inline","svgIcon","_svgIcon","_updateSvgIcon","_clearSvgElement","fontSet","_fontSet","newValue","_cleanupFontValue","_updateFontIconClasses","fontIcon","_fontIcon","_previousFontSetClass","_previousFontIconClass","_svgName","_svgNamespace","_previousPath","_elementsWithExternalReferences","_currentIconFetch","Subscription","EMPTY","ariaHidden","HostAttributeToken","optional","defaults","nativeElement","setAttribute","_splitIconName","iconName","parts","split","length","Error","ngOnInit","ngAfterViewChecked","cachedElements","size","newPath","_prependPathToReferences","ngOnDestroy","unsubscribe","clear","_usingFontIcon","_setSvgElement","svg","path","_cacheChildrenWithExternalReferences","appendChild","layoutElement","childCount","childNodes","child","nodeType","nodeName","toLowerCase","remove","elem","fontSetClasses","classNameForFontAlias","getDefaultFontSetClass","filter","className","forEach","classList","add","includes","trim","elements","attrs","element","name","elementsWithFuncIri","querySelectorAll","Map","i","elementWithReference","getAttribute","match","attributes","get","set","push","rawName","namespace","getNamedSvgIcon","take","subscribe","err","handleError","message","hostAttrs","hostVars","hostBindings","inputs","booleanAttribute","exportAs","ngContentSelectors","styles","changeDetection","MatIconModule"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./projects/eav-ui/src/app/content-items/services/content-items.service.ts","./node_modules/@angular/material/fesm2022/error-options-DCNQlTOA.mjs","./node_modules/@angular/material/fesm2022/module-DzZHEh7B.mjs","./node_modules/@angular/material/fesm2022/error-state-Dtb1IHM-.mjs","./projects/eav-ui/src/app/content-items/import-content-item/import-content-item.component.ts","./projects/eav-ui/src/app/content-items/import-content-item/import-content-item.component.html","./projects/eav-ui/src/app/shared/pipes/safe-html.pipe.ts","./node_modules/@angular/material/fesm2022/icon.mjs"],"sourcesContent":["import { httpResource } from '@angular/common/http';\r\nimport { Injectable, Signal } from '@angular/core';\r\nimport { from, map, switchMap } from 'rxjs';\r\nimport { FileUploadResult } from '../../shared/components/file-upload-dialog';\r\nimport { webApiFieldsAll } from '../../shared/fields/content-types-fields.service';\r\nimport { Field } from '../../shared/fields/field.model';\r\nimport { toBase64 } from '../../shared/helpers/file-to-base64.helper';\r\nimport { classLog } from '../../shared/logging';\r\nimport { webApiEntityList, webApiEntityRoot } from '../../shared/services/entity.service';\r\nimport { HttpServiceBaseSignal } from '../../shared/services/http-service-base-signal';\r\nimport { ContentItem } from '../models/content-item.model';\r\n\r\nconst logSpecs = {\r\n  getAll: true,\r\n  getAllLive: true,\r\n  getAllOnce: true,\r\n\r\n}\r\n@Injectable()\r\nexport class ContentItemsService extends HttpServiceBaseSignal {\r\n\r\n  log = classLog({ ContentItemsService }, logSpecs);\r\n  \r\n  getAllPromise(contentTypeStaticName: string): Promise<ContentItem[]> {\r\n    this.log.fnIf('getAll', { contentTypeStaticName });\r\n    return this.fetchPromise<ContentItem[]>(webApiEntityList, {\r\n      params: { appId: this.appId, contentType: contentTypeStaticName }\r\n    });\r\n  }\r\n\r\n  getAllOnce(contentTypeStaticName: string) {\r\n    this.log.fnIf('getAllOnce', { contentTypeStaticName });\r\n    return httpResource<ContentItem[]>(() => {\r\n      return ({\r\n        url: this.apiUrl(webApiEntityList),\r\n        params: { appId: this.appId, contentType: contentTypeStaticName }\r\n      });\r\n    });\r\n  }\r\n\r\n  getAllLive(contentTypeStaticName: string, refresh: Signal<unknown>) {\r\n    this.log.fnIf('getAllLive', { contentTypeStaticName, refresh });\r\n    return httpResource<ContentItem[]>(() => {\r\n      refresh();\r\n      return ({\r\n        url: this.apiUrl(webApiEntityList),\r\n        params: { appId: this.appId, contentType: contentTypeStaticName }\r\n      });\r\n    });\r\n  }\r\n\r\n  getColumnsPromise(contentTypeStaticName: string): Promise<Field[]> {\r\n    return this.fetchPromise<Field[]>(webApiFieldsAll, {\r\n      params: { appId: this.appId, staticName: contentTypeStaticName }\r\n    });\r\n  }\r\n\r\n  importItem(file: File) {\r\n    return from(toBase64(file)).pipe(\r\n      switchMap(fileBase64 => {\r\n        return this.http.post<boolean>(this.apiUrl(webApiEntityRoot + 'upload'), {\r\n          AppId: this.appId,\r\n          ContentBase64: fileBase64,\r\n        });\r\n      }),\r\n      map(success => {\r\n        const result: FileUploadResult = {\r\n          Success: success,\r\n          Messages: [],\r\n        };\r\n        return result;\r\n      }),\r\n    );\r\n  }\r\n}\r\n","import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\n/** Error state matcher that matches when a control is invalid and dirty. */\nclass ShowOnDirtyErrorStateMatcher {\n    isErrorState(control, form) {\n        return !!(control && control.invalid && (control.dirty || (form && form.submitted)));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ShowOnDirtyErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ShowOnDirtyErrorStateMatcher });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ShowOnDirtyErrorStateMatcher, decorators: [{\n            type: Injectable\n        }] });\n/** Provider that defines how form controls behave with regards to displaying error messages. */\nclass ErrorStateMatcher {\n    isErrorState(control, form) {\n        return !!(control && control.invalid && (control.touched || (form && form.submitted)));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ErrorStateMatcher, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ErrorStateMatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nexport { ErrorStateMatcher as E, ShowOnDirtyErrorStateMatcher as S };\n","import { ObserversModule } from '@angular/cdk/observers';\nimport * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { j as MatFormField, M as MatLabel, b as MatError, c as MatHint, e as MatPrefix, g as MatSuffix } from './form-field-C9DZXojn.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\n\nclass MatFormFieldModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatFormFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.0\", ngImport: i0, type: MatFormFieldModule, imports: [MatCommonModule,\n            ObserversModule,\n            MatFormField,\n            MatLabel,\n            MatError,\n            MatHint,\n            MatPrefix,\n            MatSuffix], exports: [MatFormField, MatLabel, MatHint, MatError, MatPrefix, MatSuffix, MatCommonModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatFormFieldModule, imports: [MatCommonModule,\n            ObserversModule,\n            MatFormField, MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatFormFieldModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        MatCommonModule,\n                        ObserversModule,\n                        MatFormField,\n                        MatLabel,\n                        MatError,\n                        MatHint,\n                        MatPrefix,\n                        MatSuffix,\n                    ],\n                    exports: [MatFormField, MatLabel, MatHint, MatError, MatPrefix, MatSuffix, MatCommonModule],\n                }]\n        }] });\n\nexport { MatFormFieldModule as M };\n","/**\n * Class that tracks the error state of a component.\n * @docs-private\n */\nclass _ErrorStateTracker {\n    _defaultMatcher;\n    ngControl;\n    _parentFormGroup;\n    _parentForm;\n    _stateChanges;\n    /** Whether the tracker is currently in an error state. */\n    errorState = false;\n    /** User-defined matcher for the error state. */\n    matcher;\n    constructor(_defaultMatcher, ngControl, _parentFormGroup, _parentForm, _stateChanges) {\n        this._defaultMatcher = _defaultMatcher;\n        this.ngControl = ngControl;\n        this._parentFormGroup = _parentFormGroup;\n        this._parentForm = _parentForm;\n        this._stateChanges = _stateChanges;\n    }\n    /** Updates the error state based on the provided error state matcher. */\n    updateErrorState() {\n        const oldState = this.errorState;\n        const parent = this._parentFormGroup || this._parentForm;\n        const matcher = this.matcher || this._defaultMatcher;\n        const control = this.ngControl ? this.ngControl.control : null;\n        const newState = matcher?.isErrorState(control, parent) ?? false;\n        if (newState !== oldState) {\n            this.errorState = newState;\n            this._stateChanges.next();\n        }\n    }\n}\n\nexport { _ErrorStateTracker as _ };\n","import { Component, Inject } from '@angular/core';\r\nimport { MAT_DIALOG_DATA } from '@angular/material/dialog';\r\nimport { transient } from '../../../../../core';\r\nimport { FileUploadDialogComponent, FileUploadDialogData, UploadTypes } from '../../shared/components/file-upload-dialog';\r\nimport { ContentItemsService } from '../services/content-items.service';\r\n\r\n@Component({\r\n    selector: 'app-import-content-item',\r\n    templateUrl: './import-content-item.component.html',\r\n    imports: [FileUploadDialogComponent,]\r\n})\r\nexport class ImportContentItemComponent {\r\n\r\n  uploadType = UploadTypes.ContentItem;\r\n\r\n  private contentItemsService = transient(ContentItemsService);\r\n\r\n  constructor(@Inject(MAT_DIALOG_DATA) dialogData: FileUploadDialogData) {\r\n    dialogData.title ??= `Import Single Item`;\r\n    dialogData.description ??= `Select an item file (json) from your computer to import.`;\r\n    dialogData.allowedFileTypes ??= 'json';\r\n    dialogData.upload$ ??= (files) => this.contentItemsService.importItem(files[0]);\r\n  }\r\n\r\n}\r\n","<app-file-upload-dialog [uploadType]=\"uploadType\"></app-file-upload-dialog>\r\n","import { Pipe, PipeTransform } from '@angular/core';\r\nimport { DomSanitizer } from '@angular/platform-browser';\r\n\r\n@Pipe({\r\n  name: 'safeHtml',\r\n})\r\nexport class SafeHtmlPipe implements PipeTransform {\r\n\r\n  constructor(private sanitizer: DomSanitizer) { }\r\n\r\n  transform(html: string) {\r\n    return this.sanitizer.bypassSecurityTrustHtml(html);\r\n  }\r\n}\r\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, DOCUMENT, ElementRef, ErrorHandler, HostAttributeToken, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, NgModule } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { M as MatIconRegistry } from './icon-registry-CwOTJ7YM.mjs';\nexport { d as ICON_REGISTRY_PROVIDER, I as ICON_REGISTRY_PROVIDER_FACTORY, c as getMatIconFailedToSanitizeLiteralError, b as getMatIconFailedToSanitizeUrlError, g as getMatIconNameNotFoundError, a as getMatIconNoHttpProviderError } from './icon-registry-CwOTJ7YM.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\nimport '@angular/common/http';\nimport '@angular/platform-browser';\nimport '@angular/cdk/a11y';\nimport '@angular/cdk/bidi';\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nconst MAT_ICON_DEFAULT_OPTIONS = new InjectionToken('MAT_ICON_DEFAULT_OPTIONS');\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nconst MAT_ICON_LOCATION = new InjectionToken('mat-icon-location', {\n    providedIn: 'root',\n    factory: MAT_ICON_LOCATION_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_ICON_LOCATION_FACTORY() {\n    const _document = inject(DOCUMENT);\n    const _location = _document ? _document.location : null;\n    return {\n        // Note that this needs to be a function, rather than a property, because Angular\n        // will only resolve it once, but we want the current path on each call.\n        getPathname: () => (_location ? _location.pathname + _location.search : ''),\n    };\n}\n/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\nconst funcIriAttributes = [\n    'clip-path',\n    'color-profile',\n    'src',\n    'cursor',\n    'fill',\n    'filter',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'mask',\n    'stroke',\n];\n/** Selector that can be used to find all elements that are using a `FuncIRI`. */\nconst funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(', ');\n/** Regex that can be used to extract the id out of a FuncIRI. */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fontawesome-v4.github.io/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nclass MatIcon {\n    _elementRef = inject(ElementRef);\n    _iconRegistry = inject(MatIconRegistry);\n    _location = inject(MAT_ICON_LOCATION);\n    _errorHandler = inject(ErrorHandler);\n    _defaultColor;\n    /**\n     * Theme color of the icon. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    get color() {\n        return this._color || this._defaultColor;\n    }\n    set color(value) {\n        this._color = value;\n    }\n    _color;\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     */\n    inline = false;\n    /** Name of the icon in the SVG icon set. */\n    get svgIcon() {\n        return this._svgIcon;\n    }\n    set svgIcon(value) {\n        if (value !== this._svgIcon) {\n            if (value) {\n                this._updateSvgIcon(value);\n            }\n            else if (this._svgIcon) {\n                this._clearSvgElement();\n            }\n            this._svgIcon = value;\n        }\n    }\n    _svgIcon;\n    /** Font set that the icon is a part of. */\n    get fontSet() {\n        return this._fontSet;\n    }\n    set fontSet(value) {\n        const newValue = this._cleanupFontValue(value);\n        if (newValue !== this._fontSet) {\n            this._fontSet = newValue;\n            this._updateFontIconClasses();\n        }\n    }\n    _fontSet;\n    /** Name of an icon within a font set. */\n    get fontIcon() {\n        return this._fontIcon;\n    }\n    set fontIcon(value) {\n        const newValue = this._cleanupFontValue(value);\n        if (newValue !== this._fontIcon) {\n            this._fontIcon = newValue;\n            this._updateFontIconClasses();\n        }\n    }\n    _fontIcon;\n    _previousFontSetClass = [];\n    _previousFontIconClass;\n    _svgName;\n    _svgNamespace;\n    /** Keeps track of the current page path. */\n    _previousPath;\n    /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n    _elementsWithExternalReferences;\n    /** Subscription to the current in-progress SVG icon request. */\n    _currentIconFetch = Subscription.EMPTY;\n    constructor() {\n        const ariaHidden = inject(new HostAttributeToken('aria-hidden'), { optional: true });\n        const defaults = inject(MAT_ICON_DEFAULT_OPTIONS, { optional: true });\n        if (defaults) {\n            if (defaults.color) {\n                this.color = this._defaultColor = defaults.color;\n            }\n            if (defaults.fontSet) {\n                this.fontSet = defaults.fontSet;\n            }\n        }\n        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n        // the right thing to do for the majority of icon use-cases.\n        if (!ariaHidden) {\n            this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n        }\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     */\n    _splitIconName(iconName) {\n        if (!iconName) {\n            return ['', ''];\n        }\n        const parts = iconName.split(':');\n        switch (parts.length) {\n            case 1:\n                return ['', parts[0]]; // Use default namespace.\n            case 2:\n                return parts;\n            default:\n                throw Error(`Invalid icon name: \"${iconName}\"`); // TODO: add an ngDevMode check\n        }\n    }\n    ngOnInit() {\n        // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n        // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n        this._updateFontIconClasses();\n    }\n    ngAfterViewChecked() {\n        const cachedElements = this._elementsWithExternalReferences;\n        if (cachedElements && cachedElements.size) {\n            const newPath = this._location.getPathname();\n            // We need to check whether the URL has changed on each change detection since\n            // the browser doesn't have an API that will let us react on link clicks and\n            // we can't depend on the Angular router. The references need to be updated,\n            // because while most browsers don't care whether the URL is correct after\n            // the first render, Safari will break if the user navigates to a different\n            // page and the SVG isn't re-rendered.\n            if (newPath !== this._previousPath) {\n                this._previousPath = newPath;\n                this._prependPathToReferences(newPath);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._currentIconFetch.unsubscribe();\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n    }\n    _usingFontIcon() {\n        return !this.svgIcon;\n    }\n    _setSvgElement(svg) {\n        this._clearSvgElement();\n        // Note: we do this fix here, rather than the icon registry, because the\n        // references have to point to the URL at the time that the icon was created.\n        const path = this._location.getPathname();\n        this._previousPath = path;\n        this._cacheChildrenWithExternalReferences(svg);\n        this._prependPathToReferences(path);\n        this._elementRef.nativeElement.appendChild(svg);\n    }\n    _clearSvgElement() {\n        const layoutElement = this._elementRef.nativeElement;\n        let childCount = layoutElement.childNodes.length;\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n        // we can't use innerHTML, because IE will throw if the element has a data binding.\n        while (childCount--) {\n            const child = layoutElement.childNodes[childCount];\n            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                child.remove();\n            }\n        }\n    }\n    _updateFontIconClasses() {\n        if (!this._usingFontIcon()) {\n            return;\n        }\n        const elem = this._elementRef.nativeElement;\n        const fontSetClasses = (this.fontSet\n            ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/)\n            : this._iconRegistry.getDefaultFontSetClass()).filter(className => className.length > 0);\n        this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n        fontSetClasses.forEach(className => elem.classList.add(className));\n        this._previousFontSetClass = fontSetClasses;\n        if (this.fontIcon !== this._previousFontIconClass &&\n            !fontSetClasses.includes('mat-ligature-font')) {\n            if (this._previousFontIconClass) {\n                elem.classList.remove(this._previousFontIconClass);\n            }\n            if (this.fontIcon) {\n                elem.classList.add(this.fontIcon);\n            }\n            this._previousFontIconClass = this.fontIcon;\n        }\n    }\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     */\n    _cleanupFontValue(value) {\n        return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n    }\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     */\n    _prependPathToReferences(path) {\n        const elements = this._elementsWithExternalReferences;\n        if (elements) {\n            elements.forEach((attrs, element) => {\n                attrs.forEach(attr => {\n                    element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n                });\n            });\n        }\n    }\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     */\n    _cacheChildrenWithExternalReferences(element) {\n        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n        const elements = (this._elementsWithExternalReferences =\n            this._elementsWithExternalReferences || new Map());\n        for (let i = 0; i < elementsWithFuncIri.length; i++) {\n            funcIriAttributes.forEach(attr => {\n                const elementWithReference = elementsWithFuncIri[i];\n                const value = elementWithReference.getAttribute(attr);\n                const match = value ? value.match(funcIriPattern) : null;\n                if (match) {\n                    let attributes = elements.get(elementWithReference);\n                    if (!attributes) {\n                        attributes = [];\n                        elements.set(elementWithReference, attributes);\n                    }\n                    attributes.push({ name: attr, value: match[1] });\n                }\n            });\n        }\n    }\n    /** Sets a new SVG icon with a particular name. */\n    _updateSvgIcon(rawName) {\n        this._svgNamespace = null;\n        this._svgName = null;\n        this._currentIconFetch.unsubscribe();\n        if (rawName) {\n            const [namespace, iconName] = this._splitIconName(rawName);\n            if (namespace) {\n                this._svgNamespace = namespace;\n            }\n            if (iconName) {\n                this._svgName = iconName;\n            }\n            this._currentIconFetch = this._iconRegistry\n                .getNamedSvgIcon(iconName, namespace)\n                .pipe(take(1))\n                .subscribe(svg => this._setSvgElement(svg), (err) => {\n                const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n                this._errorHandler.handleError(new Error(errorMessage));\n            });\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIcon, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"16.1.0\", version: \"20.0.0\", type: MatIcon, isStandalone: true, selector: \"mat-icon\", inputs: { color: \"color\", inline: [\"inline\", \"inline\", booleanAttribute], svgIcon: \"svgIcon\", fontSet: \"fontSet\", fontIcon: \"fontIcon\" }, host: { attributes: { \"role\": \"img\" }, properties: { \"class\": \"color ? \\\"mat-\\\" + color : \\\"\\\"\", \"attr.data-mat-icon-type\": \"_usingFontIcon() ? \\\"font\\\" : \\\"svg\\\"\", \"attr.data-mat-icon-name\": \"_svgName || fontIcon\", \"attr.data-mat-icon-namespace\": \"_svgNamespace || fontSet\", \"attr.fontIcon\": \"_usingFontIcon() ? fontIcon : null\", \"class.mat-icon-inline\": \"inline\", \"class.mat-icon-no-color\": \"color !== \\\"primary\\\" && color !== \\\"accent\\\" && color !== \\\"warn\\\"\" }, classAttribute: \"mat-icon notranslate\" }, exportAs: [\"matIcon\"], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIcon, decorators: [{\n            type: Component,\n            args: [{ template: '<ng-content></ng-content>', selector: 'mat-icon', exportAs: 'matIcon', host: {\n                        'role': 'img',\n                        'class': 'mat-icon notranslate',\n                        '[class]': 'color ? \"mat-\" + color : \"\"',\n                        '[attr.data-mat-icon-type]': '_usingFontIcon() ? \"font\" : \"svg\"',\n                        '[attr.data-mat-icon-name]': '_svgName || fontIcon',\n                        '[attr.data-mat-icon-namespace]': '_svgNamespace || fontSet',\n                        '[attr.fontIcon]': '_usingFontIcon() ? fontIcon : null',\n                        '[class.mat-icon-inline]': 'inline',\n                        '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"] }]\n        }], ctorParameters: () => [], propDecorators: { color: [{\n                type: Input\n            }], inline: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], svgIcon: [{\n                type: Input\n            }], fontSet: [{\n                type: Input\n            }], fontIcon: [{\n                type: Input\n            }] } });\n\nclass MatIconModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, imports: [MatCommonModule, MatIcon], exports: [MatIcon, MatCommonModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, imports: [MatCommonModule, MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: MatIconModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, MatIcon],\n                    exports: [MatIcon, MatCommonModule],\n                }]\n        }] });\n\nexport { MAT_ICON_DEFAULT_OPTIONS, MAT_ICON_LOCATION, MAT_ICON_LOCATION_FACTORY, MatIcon, MatIconModule, MatIconRegistry };\n"],"x_google_ignoreList":[1,2,3,7]}