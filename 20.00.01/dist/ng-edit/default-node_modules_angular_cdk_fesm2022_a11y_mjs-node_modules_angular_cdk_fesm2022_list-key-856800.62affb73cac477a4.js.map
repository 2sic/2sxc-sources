{"version":3,"file":"default-node_modules_angular_cdk_fesm2022_a11y_mjs-node_modules_angular_cdk_fesm2022_list-key-856800.62affb73cac477a4.js","mappings":"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","names":["ListKeyManager","_items","_activeItemIndex","signal","_activeItem","_wrap","_typeaheadSubscription","Subscription","EMPTY","_itemChangesSubscription","_vertical","_horizontal","_allowedModifierKeys","_homeAndEnd","_pageUpAndDown","enabled","delta","_effectRef","_typeahead","_skipPredicateFn","item","disabled","constructor","injector","this","QueryList","changes","subscribe","newItems","_itemsChanged","toArray","isSignal","effect","tabOut","Subject","change","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","withHorizontalOrientation","direction","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","unsubscribe","items","_getItemsArray","Typeahead","undefined","selectedItem","setActiveItem","cancelTypeahead","reset","withHomeAndEnd","withPageUpDown","previousActiveItem","updateActiveItem","next","onKeydown","event","keyCode","isModifierAllowed","every","modifier","indexOf","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","targetIndex","_setActiveItemByIndex","PAGE_DOWN","itemsLength","length","hasModifierKey","handleKey","preventDefault","activeItemIndex","activeItem","isTyping","_setActiveItemByDelta","itemArray","index","set","setCurrentSelectedItemIndex","destroy","complete","_setActiveInWrapMode","_setActiveInDefaultMode","i","fallbackDelta","setItems","newIndex","coerceObservable","data","isObservable","of","_letterKeyStream","_selectedItemIndex","_pressedLetters","_selectedItem","initialItems","config","typeAheadInterval","_setupKeyHandler","key","toLocaleUpperCase","A","Z","ZERO","NINE","String","fromCharCode","pipe","tap","letter","push","debounceTime","filter","map","join","inputString","getLabel","trim","ID_DELIMITER","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","some","existingId","setAttribute","removeAriaReferencedId","filteredIds","val","removeAttribute","getAttribute","match","CDK_DESCRIBEDBY_ID_PREFIX","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","nextId","AriaDescriber","_platform","inject","Platform","_document","DOCUMENT","_messageRegistry","Map","_messagesContainer","_id","_CdkPrivateStyleLoader","load","_VisuallyHiddenLoader","APP_ID","describe","hostElement","message","role","_canBeDescribed","getKey","setMessageId","messageElement","referenceCount","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_isElementNode","_removeMessageReference","registeredMessage","get","_deleteMessageElement","childNodes","remove","ngOnDestroy","describedElements","querySelectorAll","_removeCdkDescribedByReferenceIds","clear","createElement","textContent","_createMessagesContainer","appendChild","delete","containerClassName","serverContainers","messagesContainer","style","visibility","classList","add","isBrowser","body","element","originalReferenceIds","referenceIds","messageId","trimmedMessage","ariaLabel","nodeType","ELEMENT_NODE","static","__ngFactoryType__","i0","token","factory","ɵfac","providedIn","serviceId","TreeKeyManager","_shouldActivationFollowFocus","_horizontalOrientation","_item","_trackByFn","_hasInitialFocused","_initializeFocus","activeIndex","_isItemDisabled","makeFocusable","unfocus","focusItem","_updateActiveItemIndex","shouldActivationFollowFocus","horizontalOrientation","trackBy","typeAheadDebounceInterval","_setTypeAhead","_focusNextItem","_focusPreviousItem","_collapseCurrentItem","_expandCurrentItem","_focusFirstItem","_focusLastItem","_activateCurrentItem","_expandAllItemsAtCurrentItemLevel","getActiveItemIndex","getActiveItem","_findNextAvailableItemIndex","_findPreviousAvailableItemIndex","itemOrIndex","options","emitChangeEvent","findIndex","focus","startingIndex","_isCurrentItemExpanded","collapse","parent","getParent","getChildren","take","children","firstChild","find","child","expand","isExpanded","isDisabled","itemsToExpand","activate","TREE_KEY_MANAGER","InjectionToken","TREE_KEY_MANAGER_FACTORY"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk/fesm2022/list-key-manager-C7tp3RbG.mjs","./node_modules/@angular/cdk/fesm2022/coercion/private.mjs","./node_modules/@angular/cdk/fesm2022/typeahead-9ZW4Dtsf.mjs","./node_modules/@angular/cdk/fesm2022/a11y.mjs","./node_modules/@angular/cdk/fesm2022/tree-key-manager-KnCoIkIC.mjs"],"sourcesContent":["import { signal, QueryList, isSignal, effect } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { T as Typeahead } from './typeahead-9ZW4Dtsf.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { P as PAGE_DOWN, a as PAGE_UP, E as END, H as HOME, L as LEFT_ARROW, R as RIGHT_ARROW, U as UP_ARROW, D as DOWN_ARROW, T as TAB } from './keycodes-CpHkExLC.mjs';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n    _items;\n    _activeItemIndex = signal(-1);\n    _activeItem = signal(null);\n    _wrap = false;\n    _typeaheadSubscription = Subscription.EMPTY;\n    _itemChangesSubscription;\n    _vertical = true;\n    _horizontal;\n    _allowedModifierKeys = [];\n    _homeAndEnd = false;\n    _pageUpAndDown = { enabled: false, delta: 10 };\n    _effectRef;\n    _typeahead;\n    /**\n     * Predicate function that can be used to check whether an item should be skipped\n     * by the key manager. By default, disabled items are skipped.\n     */\n    _skipPredicateFn = (item) => item.disabled;\n    constructor(_items, injector) {\n        this._items = _items;\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            this._itemChangesSubscription = _items.changes.subscribe((newItems) => this._itemsChanged(newItems.toArray()));\n        }\n        else if (isSignal(_items)) {\n            if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw new Error('ListKeyManager constructed with a signal must receive an injector');\n            }\n            this._effectRef = effect(() => this._itemsChanged(_items()), { injector });\n        }\n    }\n    /**\n     * Stream that emits any time the TAB key is pressed, so components can react\n     * when focus is shifted off of the list.\n     */\n    tabOut = new Subject();\n    /** Stream that emits whenever the active item of the list manager changes. */\n    change = new Subject();\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const items = this._getItemsArray();\n            if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n                throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n            }\n        }\n        this._typeaheadSubscription.unsubscribe();\n        const items = this._getItemsArray();\n        this._typeahead = new Typeahead(items, {\n            debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n            skipPredicate: item => this._skipPredicateFn(item),\n        });\n        this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n            this.setActiveItem(item);\n        });\n        return this;\n    }\n    /** Cancels the current typeahead sequence. */\n    cancelTypeahead() {\n        this._typeahead?.reset();\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n     * respectively when the Page-Up or Page-Down key is pressed.\n     * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n     * @param delta Whether pressing the Home or End key activates the first/last item.\n     */\n    withPageUpDown(enabled = true, delta = 10) {\n        this._pageUpAndDown = { enabled, delta };\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem();\n        this.updateActiveItem(item);\n        if (this._activeItem() !== previousActiveItem) {\n            this.change.next(this._activeItemIndex());\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_UP:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex() - this._pageUpAndDown.delta;\n                    this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_DOWN:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex() + this._pageUpAndDown.delta;\n                    const itemsLength = this._getItemsArray().length;\n                    this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    this._typeahead?.handleKey(event);\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._typeahead?.reset();\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex();\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem();\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return !!this._typeahead && this._typeahead.isTyping();\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex() < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex() < 0 && this._wrap\n            ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem.set(activeItem == null ? null : activeItem);\n        this._activeItemIndex.set(index);\n        this._typeahead?.setCurrentSelectedItemIndex(index);\n    }\n    /** Cleans up the key manager. */\n    destroy() {\n        this._typeaheadSubscription.unsubscribe();\n        this._itemChangesSubscription?.unsubscribe();\n        this._effectRef?.destroy();\n        this._typeahead?.destroy();\n        this.tabOut.complete();\n        this.change.complete();\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex() + delta * i + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex() + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        if (isSignal(this._items)) {\n            return this._items();\n        }\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    }\n    /** Callback for when the items have changed. */\n    _itemsChanged(newItems) {\n        this._typeahead?.setItems(newItems);\n        const activeItem = this._activeItem();\n        if (activeItem) {\n            const newIndex = newItems.indexOf(activeItem);\n            if (newIndex > -1 && newIndex !== this._activeItemIndex()) {\n                this._activeItemIndex.set(newIndex);\n                this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n            }\n        }\n    }\n}\n\nexport { ListKeyManager as L };\n","import { isObservable, of } from 'rxjs';\n\n/**\n * Given either an Observable or non-Observable value, returns either the original\n * Observable, or wraps it in an Observable that emits the non-Observable value.\n */\nfunction coerceObservable(data) {\n    if (!isObservable(data)) {\n        return of(data);\n    }\n    return data;\n}\n\nexport { coerceObservable };\n","import { Subject } from 'rxjs';\nimport { tap, debounceTime, filter, map } from 'rxjs/operators';\nimport { A, Z, b as ZERO, N as NINE } from './keycodes-CpHkExLC.mjs';\n\nconst DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS = 200;\n/**\n * Selects items based on keyboard inputs. Implements the typeahead functionality of\n * `role=\"listbox\"` or `role=\"tree\"` and other related roles.\n */\nclass Typeahead {\n    _letterKeyStream = new Subject();\n    _items = [];\n    _selectedItemIndex = -1;\n    /** Buffer for the letters that the user has pressed */\n    _pressedLetters = [];\n    _skipPredicateFn;\n    _selectedItem = new Subject();\n    selectedItem = this._selectedItem;\n    constructor(initialItems, config) {\n        const typeAheadInterval = typeof config?.debounceInterval === 'number'\n            ? config.debounceInterval\n            : DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS;\n        if (config?.skipPredicate) {\n            this._skipPredicateFn = config.skipPredicate;\n        }\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n            initialItems.length &&\n            initialItems.some(item => typeof item.getLabel !== 'function')) {\n            throw new Error('KeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this.setItems(initialItems);\n        this._setupKeyHandler(typeAheadInterval);\n    }\n    destroy() {\n        this._pressedLetters = [];\n        this._letterKeyStream.complete();\n        this._selectedItem.complete();\n    }\n    setCurrentSelectedItemIndex(index) {\n        this._selectedItemIndex = index;\n    }\n    setItems(items) {\n        this._items = items;\n    }\n    handleKey(event) {\n        const keyCode = event.keyCode;\n        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n        // otherwise fall back to resolving alphanumeric characters via the keyCode.\n        if (event.key && event.key.length === 1) {\n            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n        }\n        else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n            this._letterKeyStream.next(String.fromCharCode(keyCode));\n        }\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Resets the currently stored sequence of typed letters. */\n    reset() {\n        this._pressedLetters = [];\n    }\n    _setupKeyHandler(typeAheadInterval) {\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._letterKeyStream\n            .pipe(tap(letter => this._pressedLetters.push(letter)), debounceTime(typeAheadInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join('').toLocaleUpperCase()))\n            .subscribe(inputString => {\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < this._items.length + 1; i++) {\n                const index = (this._selectedItemIndex + i) % this._items.length;\n                const item = this._items[index];\n                if (!this._skipPredicateFn?.(item) &&\n                    item.getLabel?.().toLocaleUpperCase().trim().indexOf(inputString) === 0) {\n                    this._selectedItem.next(item);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n    }\n}\n\nexport { Typeahead as T };\n","export { C as CdkMonitorFocus, d as FOCUS_MONITOR_DEFAULT_OPTIONS, F as FocusMonitor, c as FocusMonitorDetectionMode, a as INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, b as INPUT_MODALITY_DETECTOR_OPTIONS, I as InputModalityDetector } from './focus-monitor-DLjkiju1.mjs';\nimport { a as FocusTrap, I as InteractivityChecker } from './a11y-module-DHa4AVFz.mjs';\nexport { A as A11yModule, d as CdkAriaLive, C as CdkTrapFocus, F as FocusTrapFactory, b as HighContrastMode, H as HighContrastModeDetector, c as IsFocusableConfig, g as LIVE_ANNOUNCER_DEFAULT_OPTIONS, e as LIVE_ANNOUNCER_ELEMENT_TOKEN, f as LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, L as LiveAnnouncer } from './a11y-module-DHa4AVFz.mjs';\nexport { _ as _IdGenerator } from './id-generator-LuoRZSid.mjs';\nimport * as i0 from '@angular/core';\nimport { inject, DOCUMENT, APP_ID, Injectable, InjectionToken, NgZone, Injector } from '@angular/core';\nimport { P as Platform } from './platform-DNDzkVcI.mjs';\nimport { _ as _CdkPrivateStyleLoader } from './style-loader-B2sGQXxD.mjs';\nimport { _VisuallyHiddenLoader } from './private.mjs';\nexport { A as ActiveDescendantKeyManager } from './activedescendant-key-manager-CZAE5aFC.mjs';\nexport { F as FocusKeyManager } from './focus-key-manager-CPmlyB_c.mjs';\nexport { L as ListKeyManager } from './list-key-manager-C7tp3RbG.mjs';\nimport { Subject } from 'rxjs';\nimport { T as TREE_KEY_MANAGER } from './tree-key-manager-KnCoIkIC.mjs';\nexport { b as TREE_KEY_MANAGER_FACTORY, c as TREE_KEY_MANAGER_FACTORY_PROVIDER, a as TreeKeyManager } from './tree-key-manager-KnCoIkIC.mjs';\nexport { i as isFakeMousedownFromScreenReader, a as isFakeTouchstartFromScreenReader } from './fake-event-detection-DWOdFTFz.mjs';\nimport 'rxjs/operators';\nimport './keycodes-CpHkExLC.mjs';\nimport './shadow-dom-B0oHn41l.mjs';\nimport './passive-listeners-esHZRgIN.mjs';\nimport './element-x4z00URv.mjs';\nimport './breakpoints-observer-QutrMj4x.mjs';\nimport './array-I1yfCXUO.mjs';\nimport './observers.mjs';\nimport '@angular/common';\nimport './typeahead-9ZW4Dtsf.mjs';\nimport './keycodes.mjs';\nimport './coercion/private.mjs';\n\n/** IDs are delimited by an empty space, as per the spec. */\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    id = id.trim();\n    if (ids.some(existingId => existingId.trim() === id)) {\n        return;\n    }\n    ids.push(id);\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    id = id.trim();\n    const filteredIds = ids.filter(val => val !== id);\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    const attrValue = el.getAttribute(attr);\n    return attrValue?.match(/\\S+/g) ?? [];\n}\n\n/**\n * ID used for the body container where all messages are appended.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 14.0.0\n */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n */\nclass AriaDescriber {\n    _platform = inject(Platform);\n    _document = inject(DOCUMENT);\n    /** Map of all registered message elements that have been placed into the document. */\n    _messageRegistry = new Map();\n    /** Container for all registered messages. */\n    _messagesContainer = null;\n    /** Unique ID for the service. */\n    _id = `${nextId++}`;\n    constructor() {\n        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n        this._id = inject(APP_ID) + '-' + nextId++;\n    }\n    describe(hostElement, message, role) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (typeof message !== 'string') {\n            // We need to ensure that the element has an ID.\n            setMessageId(message, this._id);\n            this._messageRegistry.set(key, { messageElement: message, referenceCount: 0 });\n        }\n        else if (!this._messageRegistry.has(key)) {\n            this._createMessageElement(message, role);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, key)) {\n            this._addMessageReference(hostElement, key);\n        }\n    }\n    removeDescription(hostElement, message, role) {\n        if (!message || !this._isElementNode(hostElement)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (this._isElementDescribedByMessage(hostElement, key)) {\n            this._removeMessageReference(hostElement, key);\n        }\n        // If the message is a string, it means that it's one that we created for the\n        // consumer so we can remove it safely, otherwise we should leave it in place.\n        if (typeof message === 'string') {\n            const registeredMessage = this._messageRegistry.get(key);\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\n                this._deleteMessageElement(key);\n            }\n        }\n        if (this._messagesContainer?.childNodes.length === 0) {\n            this._messagesContainer.remove();\n            this._messagesContainer = null;\n        }\n    }\n    /** Unregisters all created message elements and removes the message container. */\n    ngOnDestroy() {\n        const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}=\"${this._id}\"]`);\n        for (let i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        this._messagesContainer?.remove();\n        this._messagesContainer = null;\n        this._messageRegistry.clear();\n    }\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     */\n    _createMessageElement(message, role) {\n        const messageElement = this._document.createElement('div');\n        setMessageId(messageElement, this._id);\n        messageElement.textContent = message;\n        if (role) {\n            messageElement.setAttribute('role', role);\n        }\n        this._createMessagesContainer();\n        this._messagesContainer.appendChild(messageElement);\n        this._messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });\n    }\n    /** Deletes the message element from the global messages container. */\n    _deleteMessageElement(key) {\n        this._messageRegistry.get(key)?.messageElement?.remove();\n        this._messageRegistry.delete(key);\n    }\n    /** Creates the global container for all aria-describedby messages. */\n    _createMessagesContainer() {\n        if (this._messagesContainer) {\n            return;\n        }\n        const containerClassName = 'cdk-describedby-message-container';\n        const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform=\"server\"]`);\n        for (let i = 0; i < serverContainers.length; i++) {\n            // When going from the server to the client, we may end up in a situation where there's\n            // already a container on the page, but we don't have a reference to it. Clear the\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\n            // container, should be slightly faster.\n            serverContainers[i].remove();\n        }\n        const messagesContainer = this._document.createElement('div');\n        // We add `visibility: hidden` in order to prevent text in this container from\n        // being searchable by the browser's Ctrl + F functionality.\n        // Screen-readers will still read the description for elements with aria-describedby even\n        // when the description element is not visible.\n        messagesContainer.style.visibility = 'hidden';\n        // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n        // the description element doesn't impact page layout.\n        messagesContainer.classList.add(containerClassName);\n        messagesContainer.classList.add('cdk-visually-hidden');\n        if (!this._platform.isBrowser) {\n            messagesContainer.setAttribute('platform', 'server');\n        }\n        this._document.body.appendChild(messagesContainer);\n        this._messagesContainer = messagesContainer;\n    }\n    /** Removes all cdk-describedby messages that are hosted through the element. */\n    _removeCdkDescribedByReferenceIds(element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby').filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    }\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     */\n    _addMessageReference(element, key) {\n        const registeredMessage = this._messageRegistry.get(key);\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);\n        registeredMessage.referenceCount++;\n    }\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     */\n    _removeMessageReference(element, key) {\n        const registeredMessage = this._messageRegistry.get(key);\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    }\n    /** Returns true if the element has been described by the provided message ID. */\n    _isElementDescribedByMessage(element, key) {\n        const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        const registeredMessage = this._messageRegistry.get(key);\n        const messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    }\n    /** Determines whether a message can be described on a particular element. */\n    _canBeDescribed(element, message) {\n        if (!this._isElementNode(element)) {\n            return false;\n        }\n        if (message && typeof message === 'object') {\n            // We'd have to make some assumptions about the description element's text, if the consumer\n            // passed in an element. Assume that if an element is passed in, the consumer has verified\n            // that it can be used as a description.\n            return true;\n        }\n        const trimmedMessage = message == null ? '' : `${message}`.trim();\n        const ariaLabel = element.getAttribute('aria-label');\n        // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n        // element, because screen readers will end up reading out the same text twice in a row.\n        return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;\n    }\n    /** Checks whether a node is an Element node. */\n    _isElementNode(element) {\n        return element.nodeType === this._document.ELEMENT_NODE;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: AriaDescriber, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: AriaDescriber, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: AriaDescriber, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message, role) {\n    return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element, serviceId) {\n    if (!element.id) {\n        element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;\n    }\n}\n\n// NoopTreeKeyManager is a \"noop\" implementation of TreeKeyMangerStrategy. Methods are noops. Does\n// not emit to streams.\n//\n// Used for applications built before TreeKeyManager to opt-out of TreeKeyManager and revert to\n// legacy behavior.\n/**\n * @docs-private\n *\n * Opt-out of Tree of key manager behavior.\n *\n * When provided, Tree has same focus management behavior as before TreeKeyManager was introduced.\n *  - Tree does not respond to keyboard interaction\n *  - Tree node allows tabindex to be set by Input binding\n *  - Tree node allows tabindex to be set by attribute binding\n *\n * @deprecated NoopTreeKeyManager deprecated. Use TreeKeyManager or inject a\n * TreeKeyManagerStrategy instead. To be removed in a future version.\n *\n * @breaking-change 21.0.0\n */\nclass NoopTreeKeyManager {\n    _isNoopTreeKeyManager = true;\n    // Provide change as required by TreeKeyManagerStrategy. NoopTreeKeyManager is a \"noop\"\n    // implementation that does not emit to streams.\n    change = new Subject();\n    destroy() {\n        this.change.complete();\n    }\n    onKeydown() {\n        // noop\n    }\n    getActiveItemIndex() {\n        // Always return null. NoopTreeKeyManager is a \"noop\" implementation that does not maintain\n        // the active item.\n        return null;\n    }\n    getActiveItem() {\n        // Always return null. NoopTreeKeyManager is a \"noop\" implementation that does not maintain\n        // the active item.\n        return null;\n    }\n    focusItem() {\n        // noop\n    }\n}\n/**\n * @docs-private\n *\n * Opt-out of Tree of key manager behavior.\n *\n * When provided, Tree has same focus management behavior as before TreeKeyManager was introduced.\n *  - Tree does not respond to keyboard interaction\n *  - Tree node allows tabindex to be set by Input binding\n *  - Tree node allows tabindex to be set by attribute binding\n *\n * @deprecated NoopTreeKeyManager deprecated. Use TreeKeyManager or inject a\n * TreeKeyManagerStrategy instead. To be removed in a future version.\n *\n * @breaking-change 21.0.0\n */\nfunction NOOP_TREE_KEY_MANAGER_FACTORY() {\n    return () => new NoopTreeKeyManager();\n}\n/**\n * @docs-private\n *\n * Opt-out of Tree of key manager behavior.\n *\n * When provided, Tree has same focus management behavior as before TreeKeyManager was introduced.\n *  - Tree does not respond to keyboard interaction\n *  - Tree node allows tabindex to be set by Input binding\n *  - Tree node allows tabindex to be set by attribute binding\n *\n * @deprecated NoopTreeKeyManager deprecated. Use TreeKeyManager or inject a\n * TreeKeyManagerStrategy instead. To be removed in a future version.\n *\n * @breaking-change 21.0.0\n */\nconst NOOP_TREE_KEY_MANAGER_FACTORY_PROVIDER = {\n    provide: TREE_KEY_MANAGER,\n    useFactory: NOOP_TREE_KEY_MANAGER_FACTORY,\n};\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends FocusTrap {\n    _focusTrapManager;\n    _inertStrategy;\n    /** Whether the FocusTrap is enabled. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config, injector) {\n        super(_element, _checker, _ngZone, _document, config.defer, injector);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    /** Focus event handler. */\n    _listener = null;\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (target && !focusTrapRoot.contains(target) && !target.closest?.('div.cdk-overlay-pane')) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = new InjectionToken('FOCUS_TRAP_INERT_STRATEGY');\n\n/** Injectable that ensures only the most recently enabled FocusTrap is active. */\nclass FocusTrapManager {\n    // A stack of the FocusTraps on the page. Only the FocusTrap at the\n    // top of the stack is active.\n    _focusTrapStack = [];\n    /**\n     * Disables the FocusTrap at the top of the stack, and then pushes\n     * the new FocusTrap onto the stack.\n     */\n    register(focusTrap) {\n        // Dedupe focusTraps that register multiple times.\n        this._focusTrapStack = this._focusTrapStack.filter(ft => ft !== focusTrap);\n        let stack = this._focusTrapStack;\n        if (stack.length) {\n            stack[stack.length - 1]._disable();\n        }\n        stack.push(focusTrap);\n        focusTrap._enable();\n    }\n    /**\n     * Removes the FocusTrap from the stack, and activates the\n     * FocusTrap that is the new top of the stack.\n     */\n    deregister(focusTrap) {\n        focusTrap._disable();\n        const stack = this._focusTrapStack;\n        const i = stack.indexOf(focusTrap);\n        if (i !== -1) {\n            stack.splice(i, 1);\n            if (stack.length) {\n                stack[stack.length - 1]._enable();\n            }\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: FocusTrapManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: FocusTrapManager, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: FocusTrapManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/** Factory that allows easy instantiation of configurable focus traps. */\nclass ConfigurableFocusTrapFactory {\n    _checker = inject(InteractivityChecker);\n    _ngZone = inject(NgZone);\n    _focusTrapManager = inject(FocusTrapManager);\n    _document = inject(DOCUMENT);\n    _inertStrategy;\n    _injector = inject(Injector);\n    constructor() {\n        const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, { optional: true });\n        // TODO split up the strategies into different modules, similar to DateAdapter.\n        this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();\n    }\n    create(element, config = { defer: false }) {\n        let configObject;\n        if (typeof config === 'boolean') {\n            configObject = { defer: config };\n        }\n        else {\n            configObject = config;\n        }\n        return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject, this._injector);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ConfigurableFocusTrapFactory, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ConfigurableFocusTrapFactory, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.0.0\", ngImport: i0, type: ConfigurableFocusTrapFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nexport { AriaDescriber, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, CDK_DESCRIBEDBY_ID_PREFIX, ConfigurableFocusTrap, ConfigurableFocusTrapFactory, EventListenerFocusTrapInertStrategy, FOCUS_TRAP_INERT_STRATEGY, FocusTrap, InteractivityChecker, MESSAGES_CONTAINER_ID, NOOP_TREE_KEY_MANAGER_FACTORY, NOOP_TREE_KEY_MANAGER_FACTORY_PROVIDER, NoopTreeKeyManager, TREE_KEY_MANAGER, addAriaReferencedId, getAriaReferenceIds, removeAriaReferencedId };\n","import { QueryList, InjectionToken } from '@angular/core';\nimport { Subscription, isObservable, Subject, of } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { T as Typeahead } from './typeahead-9ZW4Dtsf.mjs';\nimport { coerceObservable } from './coercion/private.mjs';\n\n/**\n * This class manages keyboard events for trees. If you pass it a QueryList or other list of tree\n * items, it will set the active item, focus, handle expansion and typeahead correctly when\n * keyboard events occur.\n */\nclass TreeKeyManager {\n    /** The index of the currently active (focused) item. */\n    _activeItemIndex = -1;\n    /** The currently active (focused) item. */\n    _activeItem = null;\n    /** Whether or not we activate the item when it's focused. */\n    _shouldActivationFollowFocus = false;\n    /**\n     * The orientation that the tree is laid out in. In `rtl` mode, the behavior of Left and\n     * Right arrow are switched.\n     */\n    _horizontalOrientation = 'ltr';\n    /**\n     * Predicate function that can be used to check whether an item should be skipped\n     * by the key manager.\n     *\n     * The default value for this doesn't skip any elements in order to keep tree items focusable\n     * when disabled. This aligns with ARIA guidelines:\n     * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols.\n     */\n    _skipPredicateFn = (_item) => false;\n    /** Function to determine equivalent items. */\n    _trackByFn = (item) => item;\n    /** Synchronous cache of the items to manage. */\n    _items = [];\n    _typeahead;\n    _typeaheadSubscription = Subscription.EMPTY;\n    _hasInitialFocused = false;\n    _initializeFocus() {\n        if (this._hasInitialFocused || this._items.length === 0) {\n            return;\n        }\n        let activeIndex = 0;\n        for (let i = 0; i < this._items.length; i++) {\n            if (!this._skipPredicateFn(this._items[i]) && !this._isItemDisabled(this._items[i])) {\n                activeIndex = i;\n                break;\n            }\n        }\n        const activeItem = this._items[activeIndex];\n        // Use `makeFocusable` here, because we want the item to just be focusable, not actually\n        // capture the focus since the user isn't interacting with it. See #29628.\n        if (activeItem.makeFocusable) {\n            this._activeItem?.unfocus();\n            this._activeItemIndex = activeIndex;\n            this._activeItem = activeItem;\n            this._typeahead?.setCurrentSelectedItemIndex(activeIndex);\n            activeItem.makeFocusable();\n        }\n        else {\n            // Backwards compatibility for items that don't implement `makeFocusable`.\n            this.focusItem(activeIndex);\n        }\n        this._hasInitialFocused = true;\n    }\n    /**\n     *\n     * @param items List of TreeKeyManager options. Can be synchronous or asynchronous.\n     * @param config Optional configuration options. By default, use 'ltr' horizontal orientation. By\n     * default, do not skip any nodes. By default, key manager only calls `focus` method when items\n     * are focused and does not call `activate`. If `typeaheadDefaultInterval` is `true`, use a\n     * default interval of 200ms.\n     */\n    constructor(items, config) {\n        // We allow for the items to be an array or Observable because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (items instanceof QueryList) {\n            this._items = items.toArray();\n            items.changes.subscribe((newItems) => {\n                this._items = newItems.toArray();\n                this._typeahead?.setItems(this._items);\n                this._updateActiveItemIndex(this._items);\n                this._initializeFocus();\n            });\n        }\n        else if (isObservable(items)) {\n            items.subscribe(newItems => {\n                this._items = newItems;\n                this._typeahead?.setItems(newItems);\n                this._updateActiveItemIndex(newItems);\n                this._initializeFocus();\n            });\n        }\n        else {\n            this._items = items;\n            this._initializeFocus();\n        }\n        if (typeof config.shouldActivationFollowFocus === 'boolean') {\n            this._shouldActivationFollowFocus = config.shouldActivationFollowFocus;\n        }\n        if (config.horizontalOrientation) {\n            this._horizontalOrientation = config.horizontalOrientation;\n        }\n        if (config.skipPredicate) {\n            this._skipPredicateFn = config.skipPredicate;\n        }\n        if (config.trackBy) {\n            this._trackByFn = config.trackBy;\n        }\n        if (typeof config.typeAheadDebounceInterval !== 'undefined') {\n            this._setTypeAhead(config.typeAheadDebounceInterval);\n        }\n    }\n    /** Stream that emits any time the focused item changes. */\n    change = new Subject();\n    /** Cleans up the key manager. */\n    destroy() {\n        this._typeaheadSubscription.unsubscribe();\n        this._typeahead?.destroy();\n        this.change.complete();\n    }\n    /**\n     * Handles a keyboard event on the tree.\n     * @param event Keyboard event that represents the user interaction with the tree.\n     */\n    onKeydown(event) {\n        const key = event.key;\n        switch (key) {\n            case 'Tab':\n                // Return early here, in order to allow Tab to actually tab out of the tree\n                return;\n            case 'ArrowDown':\n                this._focusNextItem();\n                break;\n            case 'ArrowUp':\n                this._focusPreviousItem();\n                break;\n            case 'ArrowRight':\n                this._horizontalOrientation === 'rtl'\n                    ? this._collapseCurrentItem()\n                    : this._expandCurrentItem();\n                break;\n            case 'ArrowLeft':\n                this._horizontalOrientation === 'rtl'\n                    ? this._expandCurrentItem()\n                    : this._collapseCurrentItem();\n                break;\n            case 'Home':\n                this._focusFirstItem();\n                break;\n            case 'End':\n                this._focusLastItem();\n                break;\n            case 'Enter':\n            case ' ':\n                this._activateCurrentItem();\n                break;\n            default:\n                if (event.key === '*') {\n                    this._expandAllItemsAtCurrentItemLevel();\n                    break;\n                }\n                this._typeahead?.handleKey(event);\n                // Return here, in order to avoid preventing the default action of non-navigational\n                // keys or resetting the buffer of pressed letters.\n                return;\n        }\n        // Reset the typeahead since the user has used a navigational key.\n        this._typeahead?.reset();\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    getActiveItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The currently active item. */\n    getActiveItem() {\n        return this._activeItem;\n    }\n    /** Focus the first available item. */\n    _focusFirstItem() {\n        this.focusItem(this._findNextAvailableItemIndex(-1));\n    }\n    /** Focus the last available item. */\n    _focusLastItem() {\n        this.focusItem(this._findPreviousAvailableItemIndex(this._items.length));\n    }\n    /** Focus the next available item. */\n    _focusNextItem() {\n        this.focusItem(this._findNextAvailableItemIndex(this._activeItemIndex));\n    }\n    /** Focus the previous available item. */\n    _focusPreviousItem() {\n        this.focusItem(this._findPreviousAvailableItemIndex(this._activeItemIndex));\n    }\n    focusItem(itemOrIndex, options = {}) {\n        // Set default options\n        options.emitChangeEvent ??= true;\n        let index = typeof itemOrIndex === 'number'\n            ? itemOrIndex\n            : this._items.findIndex(item => this._trackByFn(item) === this._trackByFn(itemOrIndex));\n        if (index < 0 || index >= this._items.length) {\n            return;\n        }\n        const activeItem = this._items[index];\n        // If we're just setting the same item, don't re-call activate or focus\n        if (this._activeItem !== null &&\n            this._trackByFn(activeItem) === this._trackByFn(this._activeItem)) {\n            return;\n        }\n        const previousActiveItem = this._activeItem;\n        this._activeItem = activeItem ?? null;\n        this._activeItemIndex = index;\n        this._typeahead?.setCurrentSelectedItemIndex(index);\n        this._activeItem?.focus();\n        previousActiveItem?.unfocus();\n        if (options.emitChangeEvent) {\n            this.change.next(this._activeItem);\n        }\n        if (this._shouldActivationFollowFocus) {\n            this._activateCurrentItem();\n        }\n    }\n    _updateActiveItemIndex(newItems) {\n        const activeItem = this._activeItem;\n        if (!activeItem) {\n            return;\n        }\n        const newIndex = newItems.findIndex(item => this._trackByFn(item) === this._trackByFn(activeItem));\n        if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n            this._activeItemIndex = newIndex;\n            this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n        }\n    }\n    _setTypeAhead(debounceInterval) {\n        this._typeahead = new Typeahead(this._items, {\n            debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n            skipPredicate: item => this._skipPredicateFn(item),\n        });\n        this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n            this.focusItem(item);\n        });\n    }\n    _findNextAvailableItemIndex(startingIndex) {\n        for (let i = startingIndex + 1; i < this._items.length; i++) {\n            if (!this._skipPredicateFn(this._items[i])) {\n                return i;\n            }\n        }\n        return startingIndex;\n    }\n    _findPreviousAvailableItemIndex(startingIndex) {\n        for (let i = startingIndex - 1; i >= 0; i--) {\n            if (!this._skipPredicateFn(this._items[i])) {\n                return i;\n            }\n        }\n        return startingIndex;\n    }\n    /**\n     * If the item is already expanded, we collapse the item. Otherwise, we will focus the parent.\n     */\n    _collapseCurrentItem() {\n        if (!this._activeItem) {\n            return;\n        }\n        if (this._isCurrentItemExpanded()) {\n            this._activeItem.collapse();\n        }\n        else {\n            const parent = this._activeItem.getParent();\n            if (!parent || this._skipPredicateFn(parent)) {\n                return;\n            }\n            this.focusItem(parent);\n        }\n    }\n    /**\n     * If the item is already collapsed, we expand the item. Otherwise, we will focus the first child.\n     */\n    _expandCurrentItem() {\n        if (!this._activeItem) {\n            return;\n        }\n        if (!this._isCurrentItemExpanded()) {\n            this._activeItem.expand();\n        }\n        else {\n            coerceObservable(this._activeItem.getChildren())\n                .pipe(take(1))\n                .subscribe(children => {\n                const firstChild = children.find(child => !this._skipPredicateFn(child));\n                if (!firstChild) {\n                    return;\n                }\n                this.focusItem(firstChild);\n            });\n        }\n    }\n    _isCurrentItemExpanded() {\n        if (!this._activeItem) {\n            return false;\n        }\n        return typeof this._activeItem.isExpanded === 'boolean'\n            ? this._activeItem.isExpanded\n            : this._activeItem.isExpanded();\n    }\n    _isItemDisabled(item) {\n        return typeof item.isDisabled === 'boolean' ? item.isDisabled : item.isDisabled?.();\n    }\n    /** For all items that are the same level as the current item, we expand those items. */\n    _expandAllItemsAtCurrentItemLevel() {\n        if (!this._activeItem) {\n            return;\n        }\n        const parent = this._activeItem.getParent();\n        let itemsToExpand;\n        if (!parent) {\n            itemsToExpand = of(this._items.filter(item => item.getParent() === null));\n        }\n        else {\n            itemsToExpand = coerceObservable(parent.getChildren());\n        }\n        itemsToExpand.pipe(take(1)).subscribe(items => {\n            for (const item of items) {\n                item.expand();\n            }\n        });\n    }\n    _activateCurrentItem() {\n        this._activeItem?.activate();\n    }\n}\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction TREE_KEY_MANAGER_FACTORY() {\n    return (items, options) => new TreeKeyManager(items, options);\n}\n/** Injection token that determines the key manager to use. */\nconst TREE_KEY_MANAGER = new InjectionToken('tree-key-manager', {\n    providedIn: 'root',\n    factory: TREE_KEY_MANAGER_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst TREE_KEY_MANAGER_FACTORY_PROVIDER = {\n    provide: TREE_KEY_MANAGER,\n    useFactory: TREE_KEY_MANAGER_FACTORY,\n};\n\nexport { TREE_KEY_MANAGER as T, TreeKeyManager as a, TREE_KEY_MANAGER_FACTORY as b, TREE_KEY_MANAGER_FACTORY_PROVIDER as c };\n"],"x_google_ignoreList":[0,1,2,3,4]}